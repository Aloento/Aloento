<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>Basics of Computer Science - Aloento</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#f0f0f0"><meta name="application-name" content="Aloento"><meta name="msapplication-TileImage" content="/img/Aloento.png"><meta name="msapplication-TileColor" content="#f0f0f0"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Aloento"><meta name="apple-mobile-web-app-status-bar-style" content="default"><link rel="apple-touch-icon" sizes="72x72" href="/img/Aloento.png"><link rel="apple-touch-icon" sizes="96x96" href="/img/Aloento.png"><link rel="apple-touch-icon" sizes="128x128" href="/img/Aloento.png"><link rel="apple-touch-icon" sizes="256x256" href="/img/Aloento.png"><meta name="description" content="我是真没搞明白这老师在干什么所以我按着她的板书，自己搓了一遍她写的那个字，就跟狗爬的一样"><meta property="og:type" content="blog"><meta property="og:title" content="Basics of Computer Science"><meta property="og:url" content="https://aloen.to/Algorithm/Basics-of-Computer-Science/"><meta property="og:site_name" content="Aloento"><meta property="og:description" content="我是真没搞明白这老师在干什么所以我按着她的板书，自己搓了一遍她写的那个字，就跟狗爬的一样"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://aloen.to/Algorithm/Basics-of-Computer-Science/0.png"><meta property="og:image" content="https://raw.githubusercontent.com/hustcc/JS-Sorting-Algorithm/master/res/countingSort.gif"><meta property="og:image" content="https://raw.githubusercontent.com/hustcc/JS-Sorting-Algorithm/master/res/radixSort.gif"><meta property="og:image" content="https://raw.githubusercontent.com/hustcc/JS-Sorting-Algorithm/master/res/mergeSort.gif"><meta property="og:image" content="https://raw.githubusercontent.com/hustcc/JS-Sorting-Algorithm/master/res/quickSort.gif"><meta property="og:image" content="https://raw.githubusercontent.com/hustcc/JS-Sorting-Algorithm/master/res/heapSort.gif"><meta property="og:image" content="https://raw.githubusercontent.com/hustcc/JS-Sorting-Algorithm/master/res/bubbleSort.gif"><meta property="og:image" content="https://raw.githubusercontent.com/hustcc/JS-Sorting-Algorithm/master/res/selectionSort.gif"><meta property="og:image" content="https://raw.githubusercontent.com/hustcc/JS-Sorting-Algorithm/master/res/insertionSort.gif"><meta property="og:image" content="https://upload.wikimedia.org/wikipedia/commons/thumb/1/1f/Depth-first-tree.svg/300px-Depth-first-tree.svg.png"><meta property="og:image" content="https://upload.wikimedia.org/wikipedia/commons/thumb/1/1b/Breadth-first_tree.svg/300px-Breadth-first_tree.svg.png"><meta property="og:image" content="https://aloen.to/Algorithm/Basics-of-Computer-Science/1.png"><meta property="og:image" content="https://aloen.to/Algorithm/Basics-of-Computer-Science/3.png"><meta property="og:image" content="https://aloen.to/Algorithm/Basics-of-Computer-Science/4.png"><meta property="og:image" content="https://upload.wikimedia.org/wikipedia/commons/thumb/8/86/6n-graf-clique.svg/300px-6n-graf-clique.svg.png"><meta property="og:image" content="https://aloen.to/Algorithm/Basics-of-Computer-Science/5.png"><meta property="og:image" content="https://aloen.to/Algorithm/Basics-of-Computer-Science/6.png"><meta property="og:image" content="https://sailist.github.io/AdAlgo/GraphTheory/fig/2.png"><meta property="og:image" content="https://aloen.to/Algorithm/Basics-of-Computer-Science/7.png"><meta property="og:image" content="https://aloen.to/Algorithm/Basics-of-Computer-Science/8.png"><meta property="og:image" content="https://aloen.to/Algorithm/Basics-of-Computer-Science/9.png"><meta property="og:image" content="https://aloen.to/Algorithm/Basics-of-Computer-Science/10.png"><meta property="og:image" content="https://aloen.to/Algorithm/Basics-of-Computer-Science/11.png"><meta property="og:image" content="https://aloen.to/Algorithm/Basics-of-Computer-Science/12.png"><meta property="og:image" content="https://aloen.to/Algorithm/Basics-of-Computer-Science/13.png"><meta property="og:image" content="https://aloen.to/Algorithm/Basics-of-Computer-Science/14.png"><meta property="article:published_time" content="2022-12-07T07:37:00.000Z"><meta property="article:modified_time" content="2024-10-10T20:02:46.667Z"><meta property="article:author" content="Aloento"><meta property="article:tag" content="算法"><meta property="article:tag" content="笔记"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://aloen.to/Algorithm/Basics-of-Computer-Science/0.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://aloen.to/Algorithm/Basics-of-Computer-Science/"},"headline":"Basics of Computer Science","image":["https://aloen.to/Algorithm/Basics-of-Computer-Science/0.png","https://raw.githubusercontent.com/hustcc/JS-Sorting-Algorithm/master/res/countingSort.gif","https://raw.githubusercontent.com/hustcc/JS-Sorting-Algorithm/master/res/radixSort.gif","https://raw.githubusercontent.com/hustcc/JS-Sorting-Algorithm/master/res/mergeSort.gif","https://raw.githubusercontent.com/hustcc/JS-Sorting-Algorithm/master/res/quickSort.gif","https://raw.githubusercontent.com/hustcc/JS-Sorting-Algorithm/master/res/heapSort.gif","https://raw.githubusercontent.com/hustcc/JS-Sorting-Algorithm/master/res/bubbleSort.gif","https://raw.githubusercontent.com/hustcc/JS-Sorting-Algorithm/master/res/selectionSort.gif","https://raw.githubusercontent.com/hustcc/JS-Sorting-Algorithm/master/res/insertionSort.gif","https://upload.wikimedia.org/wikipedia/commons/thumb/1/1f/Depth-first-tree.svg/300px-Depth-first-tree.svg.png","https://upload.wikimedia.org/wikipedia/commons/thumb/1/1b/Breadth-first_tree.svg/300px-Breadth-first_tree.svg.png","https://aloen.to/Algorithm/Basics-of-Computer-Science/1.png","https://aloen.to/Algorithm/Basics-of-Computer-Science/3.png","https://aloen.to/Algorithm/Basics-of-Computer-Science/4.png","https://upload.wikimedia.org/wikipedia/commons/thumb/8/86/6n-graf-clique.svg/300px-6n-graf-clique.svg.png","https://aloen.to/Algorithm/Basics-of-Computer-Science/5.png","https://aloen.to/Algorithm/Basics-of-Computer-Science/6.png","https://sailist.github.io/AdAlgo/GraphTheory/fig/2.png","https://aloen.to/Algorithm/Basics-of-Computer-Science/7.png","https://aloen.to/Algorithm/Basics-of-Computer-Science/8.png","https://aloen.to/Algorithm/Basics-of-Computer-Science/9.png","https://aloen.to/Algorithm/Basics-of-Computer-Science/10.png","https://aloen.to/Algorithm/Basics-of-Computer-Science/11.png","https://aloen.to/Algorithm/Basics-of-Computer-Science/12.png","https://aloen.to/Algorithm/Basics-of-Computer-Science/13.png","https://aloen.to/Algorithm/Basics-of-Computer-Science/14.png"],"datePublished":"2022-12-07T07:37:00.000Z","dateModified":"2024-10-10T20:02:46.667Z","author":{"@type":"Person","name":"Aloento"},"publisher":{"@type":"Organization","name":"Aloento","logo":{"@type":"ImageObject","url":"https://aloen.to/Algorithm/Basics-of-Computer-Science/"}},"description":"我是真没搞明白这老师在干什么所以我按着她的板书，自己搓了一遍她写的那个字，就跟狗爬的一样"}</script><link rel="canonical" href="https://aloen.to/Algorithm/Basics-of-Computer-Science/"><link rel="icon" href="/img/Aloento.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.lug.ustc.edu.cn/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/lightgallery/1.10.0/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.8.1/css/justifiedGallery.min.css"><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.css"><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js"></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">Aloento</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" target="_blank" rel="noopener" href="https://Q-Audio.org/Aloento">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Q-Audio" href="https://Q-Audio.org"><i class="fas fa-compact-disc"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="MusiLand" href="https://Musi.Land/"><i class="fab fa-dashcube"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="GitHub" href="https://github.com/Aloento"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-12-07T07:37:00.000Z" title="12/7/2022, 7:37:00 AM">2022-12-07</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-10-10T20:02:46.667Z" title="10/10/2024, 8:02:46 PM">2024-10-11</time></span><span class="level-item"><a class="link-muted" href="/categories/Algorithm/">Algorithm</a></span><span class="level-item">an hour read (About 10402 words)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>&nbsp;visits</span></div></div><h1 class="title is-3 is-size-4-mobile">Basics of Computer Science</h1><div class="content"><p><del>我是真没搞明白这老师在干什么</del><br>所以我按着她的板书，自己搓了一遍<br>她写的那个字，就跟狗爬的一样</p>
<span id="more"></span>

<h1 id="Algorithmic-problems-modelling"><a href="#Algorithmic-problems-modelling" class="headerlink" title="Algorithmic problems, modelling"></a>Algorithmic problems, modelling</h1><p>theory of computation, modelling tools, examples</p>
<h2 id="What-is-it-good-for"><a href="#What-is-it-good-for" class="headerlink" title="What is it good for"></a>What is it good for</h2><ul>
<li>Create efficient algorithms</li>
<li>Programming language research</li>
<li>Efficient compiler design and construction</li>
</ul>
<hr>
<p>我们为什么要研究算法？</p>
<ul>
<li>构建高效算法</li>
<li>编程语言研究</li>
<li>高效编译器设计和构建</li>
</ul>
<h2 id="Branches-of-ToC"><a href="#Branches-of-ToC" class="headerlink" title="Branches of ToC"></a>Branches of ToC</h2><h3 id="Automata-theory"><a href="#Automata-theory" class="headerlink" title="Automata theory"></a>Automata theory</h3><ul>
<li>is the study of abstract computational devices</li>
<li>formal framework for designing and analyzing computing devices</li>
<li>we will discuss Turing Machines.</li>
</ul>
<hr>
<p>自动机理论</p>
<ul>
<li>是对抽象计算机的研究</li>
<li>用于设计和分析计算机的形式框架</li>
<li>我们将讨论图灵机</li>
</ul>
<h3 id="Computability-Theory"><a href="#Computability-Theory" class="headerlink" title="Computability Theory"></a>Computability Theory</h3><ul>
<li>defines whether a problem is “solvable” by any abstract machines</li>
<li>some problems are computable, some are not (e.g. travelling salesman problem)</li>
</ul>
<hr>
<p>可计算性理论</p>
<ul>
<li>定义了一个问题是否可以被任何抽象机器解决</li>
<li>有些问题是可计算的，有些不是（例如旅行推销员问题）</li>
</ul>
<h3 id="Complexity-Theory"><a href="#Complexity-Theory" class="headerlink" title="Complexity Theory"></a>Complexity Theory</h3><ul>
<li>studying the cost of solving problems</li>
<li>cost &#x3D; resources (e.g. time, memory)</li>
<li>running time of algorithms varies with inputs and usually grows with the site of inputs</li>
<li>we will discuss how to measure complexity</li>
</ul>
<hr>
<p>复杂度理论</p>
<ul>
<li>研究解决问题的成本</li>
<li>成本 &#x3D; 资源（例如时间，内存）</li>
<li>算法的运行时间随着输入而变化，通常随着输入的增大而增长</li>
<li>我们将讨论如何衡量复杂度</li>
</ul>
<h2 id="Modlling"><a href="#Modlling" class="headerlink" title="Modlling"></a>Modlling</h2><p>Problem -&gt; (Model) -&gt; Mathematica Frame -&gt; (Algorithm) -&gt; Solution</p>
<hr>
<p>问题 -&gt; (模型) -&gt; 数学框架 -&gt; (算法) -&gt; 解决方案</p>
<h3 id="Tools-of-modelling"><a href="#Tools-of-modelling" class="headerlink" title="Tools of modelling"></a>Tools of modelling</h3><ul>
<li>sets</li>
<li>function</li>
<li>number systems, coding</li>
<li>graphs</li>
</ul>
<hr>
<ul>
<li>集合</li>
<li>函数</li>
<li>数制，编码</li>
<li>图</li>
</ul>
<h3 id="Graph-definition"><a href="#Graph-definition" class="headerlink" title="Graph definition"></a>Graph definition</h3><p>G&#x3D;(V,E) where V is finite and not empty set, V &#x3D; edges, E &#x3D; vertices</p>
<hr>
<p>G&#x3D;(V,E) 其中 V 是有限且非空的集合，V &#x3D; 边，E &#x3D; 顶点</p>
<h3 id="Graph-Representations"><a href="#Graph-Representations" class="headerlink" title="Graph Representations"></a>Graph Representations</h3><ul>
<li>drawing</li>
<li>edge and vertex list</li>
<li>adjacency matrix</li>
</ul>
<hr>
<p>图形表示法</p>
<ul>
<li>绘图</li>
<li>边和顶点的列表</li>
<li>邻接矩阵</li>
</ul>
<h3 id="Examples-of-graph-models"><a href="#Examples-of-graph-models" class="headerlink" title="Examples of graph models"></a>Examples of graph models</h3><h4 id="Complicated-intersection-traffic-lights"><a href="#Complicated-intersection-traffic-lights" class="headerlink" title="Complicated intersection traffic lights"></a>Complicated intersection traffic lights</h4><p><img src="/Algorithm/Basics-of-Computer-Science/0.png" alt="traffic lights"></p>
<p>Translates to graph coloring problem and maximal independent set problem too</p>
<h4 id="King-Arthur-and-the-knights-of-the-Round-Table"><a href="#King-Arthur-and-the-knights-of-the-Round-Table" class="headerlink" title="King Arthur and the knights of the Round Table"></a>King Arthur and the knights of the Round Table</h4><h4 id="Noblemen-and-Noble-Maidens"><a href="#Noblemen-and-Noble-Maidens" class="headerlink" title="Noblemen and Noble Maidens"></a>Noblemen and Noble Maidens</h4><h1 id="Turing-Machines"><a href="#Turing-Machines" class="headerlink" title="Turing Machines"></a>Turing Machines</h1><p>definition, construction, properties, transition functions</p>
<h2 id="What-is-a-Turing-Machine"><a href="#What-is-a-Turing-Machine" class="headerlink" title="What is a Turing Machine"></a>What is a Turing Machine</h2><ul>
<li>TMS are abstract models for real computers having an infinite memory<br>(in the form of a tape) and a reading head</li>
<li>has finite number of internal states</li>
<li>has distinguished starting and final states (termination: accept &#x2F; reject)</li>
<li>has transition functions (Tt) (graphs)</li>
</ul>
<hr>
<ul>
<li>图灵机是对真实计算机的抽象模型，它具有无限内存（以磁带的形式）和读写头</li>
<li>具有有限数量的内部状态</li>
<li>具有特殊的起始和终止状态（终止：接受&#x2F;拒绝）</li>
<li>具有转换函数（Tt）（图）</li>
</ul>
<hr>
<ul>
<li>TM accepts the initial content of the tape if it terminates in an accepting<br>state. Otherwise TM rejects it.</li>
<li>TM terminates, if there is no rule with watching conditions<br>for certain state and input symbols.</li>
<li>TM is ND (non-deterministic), if such a state and set of input symbols<br>exist, for which there are multiple rules defined.<br>(&#x3D; from the same set of starting state and input symbols the TM has multiple outcomes)</li>
</ul>
<hr>
<ul>
<li>如果图灵机终止于接受状态，则它接受磁带的初始内容。否则拒绝。</li>
<li>如果没有匹配的规则，则图灵机终止。</li>
<li>如果存在某个状态和输入符号集，对于该状态和输入符号集，有多个规则，则图灵机是非确定性的（ND）。<br>（&#x3D;从同一组起始状态和输入符号集，图灵机具有多个结果）</li>
</ul>
<hr>
<ul>
<li>NDTM accepts the initial content of the tape if there is<br>a sequence of transition functions that accepts it.</li>
</ul>
<p>Thesis: For All NDTM Exsist equivalent DTM</p>
<p>对于所有的非确定性图灵机，都存在等价的确定性图灵机</p>
<h2 id="Defining-a-Turing-Machine"><a href="#Defining-a-Turing-Machine" class="headerlink" title="Defining a Turing Machine"></a>Defining a Turing Machine</h2><ul>
<li>defining the number of tapes &amp; head</li>
<li>defining the tape alphabets</li>
<li>defining the net of state, initial and terminating states,<br>accepting and rejection terminal states</li>
</ul>
<p>From an already existing machine it is possible to head the followings:</p>
<ul>
<li>number of heads</li>
<li>set of states constructed from the states mentioned in the TFS</li>
</ul>
<p>Universal TM: TM, which can simulate All other TM</p>
<p>Church - Turing thesis:<br>A function (problem) can be effectively solved &lt;&#x3D;&gt; it is computable with a TM</p>
<p>The same problems can be solved by a TM and modern computers</p>
<h1 id="Complexity-of-algorithms"><a href="#Complexity-of-algorithms" class="headerlink" title="Complexity of algorithms"></a>Complexity of algorithms</h1><p>measuring complexity, complexity classes</p>
<p>算法会消耗时间和内存，复杂度就是衡量消耗的指标</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>时间复杂度主要是循环导致的，我们不必把它想得太复杂<br>下面列出的时间复杂度越来越大，执行的效率越来越低</p>
<h3 id="常数阶-O-1"><a href="#常数阶-O-1" class="headerlink" title="常数阶 O(1)"></a>常数阶 O(1)</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line">i = i + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>说白了就是没有循环，即便它有几百万行</p>
<h3 id="对数阶-O-logN"><a href="#对数阶-O-logN" class="headerlink" title="对数阶 O(logN)"></a>对数阶 O(logN)</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">  i = i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，每次循环都会把 i 乘 2<br>设循环 x 次后，i 大于 n<br>则 2^x &gt; n，即 x &gt; log2(n)</p>
<h3 id="线性阶-O-N"><a href="#线性阶-O-N" class="headerlink" title="线性阶 O(N)"></a>线性阶 O(N)</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个就更好理解了，循环 n 次<br>它的前进速度明显就没有之前乘 2 的那个快了</p>
<h3 id="线性对数阶-O-NlogN"><a href="#线性对数阶-O-NlogN" class="headerlink" title="线性对数阶 O(NlogN)"></a>线性对数阶 O(NlogN)</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n; i = i * <span class="number">2</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(j);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>名字看的很奇怪，但实际上<br>把 O(logN) 的代码，再循环 N 次<br>那它的时间复杂度就是 <code>n * logn</code> 了</p>
<p>当然你也可以把 O(N) 的代码，再循环 logN 次<br>就像上面的例子一样</p>
<h3 id="平方阶-O-N-2"><a href="#平方阶-O-N-2" class="headerlink" title="平方阶 O(N^2)"></a>平方阶 O(N^2)</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(j);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>n * n</code> 不就是 <code>n^2</code> 吗<br>把 O(N) 的代码，再循环 N 次<br>比之前那个还好理解</p>
<p>当然也可以是 <code>m * n</code><br>那时间复杂度就是 O(MN) 了</p>
<hr>
<p>其他的还有</p>
<ul>
<li>K 次方阶 O(N^k)</li>
<li>指数阶 O(2^N)<br>一般是递归算法</li>
<li>O(3^N)</li>
<li>etc.</li>
</ul>
<h3 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h3><p>T(n) 算法的执行次数<br>T(n) &#x3D; O(f(n))</p>
<ol>
<li><p>嵌套循环<br>由内向外分析，并相乘</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// O(n)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">  <span class="comment">// O(n)</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(j); <span class="comment">// O(1)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为 <code>O(n * n * 1) = O(n^2)</code></p>
</li>
<li><p>顺序执行<br>你可以把它们的时间复杂度相加<br>在不要求精度的情况下可以直接等于其中最大的时间复杂度</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// O(n)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(n^2)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(j);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为 <code>O(n + n^2)</code> 或者不要求精度 <code>O(n^2)</code></p>
</li>
<li><p>条件分支<br>时间复杂度等于所有分支中最大的时间复杂度<br>说人话就是：最麻烦的那个情况</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (n &gt; <span class="number">10</span>) &#123;</span><br><span class="line">  <span class="comment">// O(n)</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// O(1)</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为 <code>O(n)</code></p>
</li>
</ol>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>很显然，时间复杂度并没有真正计算算法实际的执行时间<br>那么空间复杂度一样也不是真正的占用空间</p>
<h3 id="O-1"><a href="#O-1" class="headerlink" title="O(1)"></a>O(1)</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line">i = i + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>代码中的变量所分配的空间，都不随数据量的变化而变化<br>所以空间复杂度为 O(1)</p>
<h3 id="O-N"><a href="#O-N" class="headerlink" title="O(N)"></a>O(N)</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">  arr.<span class="title function_">push</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到数组就表明，空间是随着 n 增大而增大的<br>所以空间复杂度为 O(N)</p>
<h3 id="计算-1"><a href="#计算-1" class="headerlink" title="计算"></a>计算</h3><p>所以说的简单一点</p>
<ul>
<li>如果 n 增大，程序占用的空间不变，则空间复杂度为 O(1)</li>
<li>如果 n 增大，程序占用的空间成线性增长，那么空间复杂度就是 O(N)</li>
<li>如果 n 增大，程序占用的空间成平方增长，那么空间复杂度就是 O(N^2)</li>
</ul>
<p>以此类推<br>当然也有 O(N + M), O(logN)等</p>
<h1 id="Sorting-algorithms-and-their-complexity"><a href="#Sorting-algorithms-and-their-complexity" class="headerlink" title="Sorting algorithms and their complexity"></a>Sorting algorithms and their complexity</h1><p>selection sort, bubble sort, insertion sort and optimization, their analysis, theorem about maximum complexity case runtime steps</p>
<p>我们按时间复杂度区分，并介绍十大常用的排序算法<br>由于这门课并不教怎么写代码，所以我们只需要了解它是怎么工作的就行了</p>
<p><del>学计算机不学写代码，行吧，当数学课上</del></p>
<h2 id="O-N-1"><a href="#O-N-1" class="headerlink" title="O(N)"></a>O(N)</h2><p>它们都是非比较算法，不适合大量或大范围数据</p>
<h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p>Counting Sort<br>每个桶只存储单一键值<br><code>O(N + K)</code></p>
<p><img src="https://raw.githubusercontent.com/hustcc/JS-Sorting-Algorithm/master/res/countingSort.gif" alt="动图演示"></p>
<p>对于给定的输入，统计每个元素出现的次数，然后依次把元素输出</p>
<h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p>Bucket Sort 每个桶存储一定范围的数值<br>它需要调用其他的排序算法来完成排序<br>所以它的实际时间复杂度受到其使用的排序算法的影响<br><code>O(N * K)</code></p>
<p>基本思路是，把数据分到有限数量的桶里，然后对每个桶内部的数据进行排序<br>最后将各个桶内的数据依次取出，得到结果</p>
<p>让我们看一个例子<br>假设我们有 20 个数据，要分成 5 个桶</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bucketSort</span>(<span class="params"><span class="attr">arr</span>: <span class="built_in">number</span>[], <span class="attr">bucketSize</span>: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="comment">// 创建大小为 bucketSize 的桶数组</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">bucket</span>: <span class="built_in">number</span>[][] = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化桶数组</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; bucketSize; i++) &#123;</span><br><span class="line">    bucket[i] = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取数组中的最大值和最小值</span></span><br><span class="line">  <span class="keyword">const</span> max = <span class="title class_">Math</span>.<span class="title function_">max</span>(...arr); <span class="comment">// 194</span></span><br><span class="line">  <span class="keyword">const</span> min = <span class="title class_">Math</span>.<span class="title function_">min</span>(...arr); <span class="comment">// 13</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算桶的范围</span></span><br><span class="line">  <span class="comment">// (194 - 13 + 1) / 5 = 36.4</span></span><br><span class="line">  <span class="keyword">const</span> range = (max - min + <span class="number">1</span>) / bucketSize;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将数据放入对应的桶中</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 计算数据应该放入的桶的索引</span></span><br><span class="line">    <span class="comment">// 比如 63：floor(63 - 13) / 36.4) = 1</span></span><br><span class="line">    <span class="keyword">const</span> index = <span class="title class_">Math</span>.<span class="title function_">floor</span>((arr[i] - min) / range);</span><br><span class="line">    bucket[index].<span class="title function_">push</span>(arr[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用其他算法，对桶内的数据进行排序</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; bucketSize; i++) &#123;</span><br><span class="line">    bucket[i].<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将桶内排好序的数据依次取出，得到有序序列</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">result</span>: <span class="built_in">number</span>[] = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; bucketSize; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; bucketSize; j++) &#123;</span><br><span class="line">      result.<span class="title function_">push</span>(bucket[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>Radix Sort<br>根据键值的每位数字来分配桶<br>O(d(n+r))，其中 d 是基数，n 是要排序的数据个数，r 是每个关键字的基数</p>
<p><img src="https://raw.githubusercontent.com/hustcc/JS-Sorting-Algorithm/master/res/radixSort.gif" alt="动图演示"></p>
<p>将所有待比较数值统一为同样的数位长度，数位较短的数前面补零<br>然后，从最低位开始，依次进行一次排序<br>这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列</p>
<h2 id="O-NlogN"><a href="#O-NlogN" class="headerlink" title="O(NlogN)"></a>O(NlogN)</h2><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>Shell Sort，也称递减增量排序<br>是插入排序的一种更高效的改进版本，它会优先比较距离较远的元素</p>
<p>先将整个序列，分割成若干个子序列，分别进行插入排序<br>待整个序列基本有序时，再对整体进行插入排序</p>
<hr>
<p>我们有 <code>[7, 6, 9, 3, 1, 5, 2, 4]</code> 需要排序<br>首先我们确定增量为 4，每次缩小一半</p>
<p>所以我们有 4 个子序列</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">7</span>, <span class="number">1</span>];</span><br><span class="line">[<span class="number">6</span>, <span class="number">5</span>];</span><br><span class="line">[<span class="number">9</span>, <span class="number">2</span>];</span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>];</span><br></pre></td></tr></table></figure>

<p>分别排序它们</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">7</span>];</span><br><span class="line">[<span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line">[<span class="number">2</span>, <span class="number">9</span>];</span><br><span class="line">[<span class="number">3</span>, <span class="number">4</span>];</span><br></pre></td></tr></table></figure>

<p>得到</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">4</span>];</span><br></pre></td></tr></table></figure>

<p>然后缩小增量为 2，再次分割</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">9</span>];</span><br><span class="line">[<span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>];</span><br></pre></td></tr></table></figure>

<p>排序得到</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>];</span><br></pre></td></tr></table></figure>

<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>Merge Sort，是一种分治算法<br>将两个或两个以上的有序表合并成一个新的有序表</p>
<ol>
<li>把长度为 n 的序列分成两个长度为 n&#x2F;2 的子序列</li>
<li>对这两个子序列分别采用归并排序（递归）</li>
<li>将两个排序好的子序列合并成一个最终的排序序列</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hustcc/JS-Sorting-Algorithm/master/res/mergeSort.gif" alt="动图演示"></p>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>Quick Sort<br>应该算是在冒泡排序基础上的递归分治法</p>
<ol>
<li>随便选择一个元素</li>
<li>将比这个元素小的放在左边，比这个元素大的放在右边</li>
<li>对左右两边的元素重复第二步，直到各区间只有一个元素</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hustcc/JS-Sorting-Algorithm/master/res/quickSort.gif" alt="动图演示"></p>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>Heap Sort</p>
<ol>
<li>构建一个大顶堆，此时，整个序列的最大值就是堆顶的根节点</li>
<li>将其与末尾元素进行交换，此时末尾就为最大值</li>
<li>然后将剩余的 n-1 个元素重新构建成一个堆，这样会得到 n 个元素的次小值</li>
<li>如此反复执行，便能得到一个有序序列了</li>
</ol>
<p><img src="https://raw.githubusercontent.com/hustcc/JS-Sorting-Algorithm/master/res/heapSort.gif" alt="动图演示"></p>
<h2 id="O-N-2"><a href="#O-N-2" class="headerlink" title="O(N^2)"></a>O(N^2)</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>Bubble Sort<br>比较相邻的元素，如果第一个比第二个大，就交换他们两个，一直向上冒泡</p>
<p><img src="https://raw.githubusercontent.com/hustcc/JS-Sorting-Algorithm/master/res/bubbleSort.gif" alt="动图演示"></p>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>Selection Sort<br>也就是每次找到最小的元素，放到前面，重复</p>
<p><img src="https://raw.githubusercontent.com/hustcc/JS-Sorting-Algorithm/master/res/selectionSort.gif" alt="动图演示"></p>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>可以在找到最小元素时记录下它的位置，并在最后交换元素的时候使用该位置。<br>这样可以避免每次都将最小元素与已排序序列的最后一个元素交换，减少了不必要的操作</p>
<p>例如，对于序列[5, 3, 8, 1, 9]，优化的过程如下：</p>
<ol>
<li>第一次遍历，找到最小元素 1，然后将 1 与 5 交换<br>[1, 3, 8, 5, 9]</li>
<li>第三次遍历，在剩下的序列 [5, 8, 9] 中找到最小的元素 5，然后将 5 与 8 交换<br>[1, 3, 5, 8, 9]</li>
</ol>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>Insertion Sort<br>像打扑克时整理手牌一样，将每张牌插入到合适的位置</p>
<p><img src="https://raw.githubusercontent.com/hustcc/JS-Sorting-Algorithm/master/res/insertionSort.gif" alt="动图演示"></p>
<h1 id="Basic-graph-algorithms"><a href="#Basic-graph-algorithms" class="headerlink" title="Basic graph algorithms"></a>Basic graph algorithms</h1><p>graph searches (BFS, DFS, Dijsktra), tree traversals, longest path problems</p>
<h2 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h2><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/1f/Depth-first-tree.svg/300px-Depth-first-tree.svg.png" alt="节点进行深度优先搜索的顺序"></p>
<h2 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h2><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/1b/Breadth-first_tree.svg/300px-Breadth-first_tree.svg.png" alt="节点进行广度优先搜索的顺序"></p>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>前序遍历：根结点 —&gt; 左子树 —&gt; 右子树<br>是从最上层往下走</p>
<p>中序遍历：左子树 —&gt; 根结点 —&gt; 右子树<br>是从最左边往右走</p>
<p>后序遍历：左子树 —&gt; 右子树 —&gt; 根结点<br>是从最下层往上走</p>
<p>层次遍历：只需按层遍历即可</p>
<h2 id="Dijsktra"><a href="#Dijsktra" class="headerlink" title="Dijsktra"></a>Dijsktra</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">5</span></span><br><span class="line">A ----- B</span><br><span class="line">|       |</span><br><span class="line">|       |</span><br><span class="line"><span class="number">4</span>       <span class="number">6</span></span><br><span class="line">|       |</span><br><span class="line">|       |</span><br><span class="line">C ----- D</span><br><span class="line">    <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>首先，我们将 A 设为原点，并初始化每个顶点到原点的距离为无穷大</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 每个顶点到原点的距离</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">dist</span>: <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, <span class="built_in">number</span>&gt; = &#123;</span><br><span class="line">  <span class="attr">A</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">B</span>: <span class="title class_">Infinity</span>,</span><br><span class="line">  <span class="attr">C</span>: <span class="title class_">Infinity</span>,</span><br><span class="line">  <span class="attr">D</span>: <span class="title class_">Infinity</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取两个顶点之间的权重</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">weight</span>(<span class="params"><span class="attr">node1</span>: <span class="built_in">string</span>, <span class="attr">node2</span>: <span class="built_in">string</span></span>): <span class="built_in">number</span>;</span><br></pre></td></tr></table></figure>

<p>接下来，我们要不断迭代更新每个顶点到原点的最短距离，<br>直到所有顶点的最短距离，都被更新为最终值。</p>
<p>在每次迭代中，我们首先找到所有未被更新的顶点中，距离原点最近的顶点，<br>然后更新它到原点的最短距离，并根据新的距离，更新其他顶点，到原点的距离。</p>
<p>从 A 向外扩散</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dist.<span class="property">B</span> =</span><br><span class="line">  <span class="title class_">Math</span>.<span class="title function_">min</span>(dist.<span class="property">B</span>, dist.<span class="property">A</span> + <span class="title function_">weight</span>(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>)) =</span><br><span class="line">  <span class="title class_">Math</span>.<span class="title function_">min</span>(<span class="title class_">Infinity</span>, <span class="number">0</span> + <span class="number">5</span>) =</span><br><span class="line">    <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dist.<span class="property">C</span> =</span><br><span class="line">  <span class="title class_">Math</span>.<span class="title function_">min</span>(dist.<span class="property">C</span>, dist.<span class="property">A</span> + <span class="title function_">weight</span>(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;C&quot;</span>)) =</span><br><span class="line">  <span class="title class_">Math</span>.<span class="title function_">min</span>(<span class="title class_">Infinity</span>, <span class="number">0</span> + <span class="number">4</span>) =</span><br><span class="line">    <span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<p>从 B 向外扩散</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dist.<span class="property">D</span> =</span><br><span class="line">  <span class="title class_">Math</span>.<span class="title function_">min</span>(dist.<span class="property">D</span>, dist.<span class="property">B</span> + <span class="title function_">weight</span>(<span class="string">&quot;B&quot;</span>, <span class="string">&quot;D&quot;</span>)) =</span><br><span class="line">  <span class="title class_">Math</span>.<span class="title function_">min</span>(<span class="title class_">Infinity</span>, <span class="number">5</span> + <span class="number">6</span>) =</span><br><span class="line">    <span class="number">11</span>;</span><br></pre></td></tr></table></figure>

<p>从 C 向外扩散</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dist.<span class="property">D</span> = <span class="title class_">Math</span>.<span class="title function_">min</span>(dist.<span class="property">D</span>, dist.<span class="property">C</span> + <span class="title function_">weight</span>(<span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>)) = <span class="title class_">Math</span>.<span class="title function_">min</span>(<span class="number">11</span>, <span class="number">4</span> + <span class="number">5</span>) = <span class="number">9</span>;</span><br></pre></td></tr></table></figure>

<p>得到结果</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dist = &#123;</span><br><span class="line">  <span class="attr">A</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">B</span>: <span class="number">5</span>,</span><br><span class="line">  <span class="attr">C</span>: <span class="number">4</span>,</span><br><span class="line">  <span class="attr">D</span>: <span class="number">9</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>所以，从 A 到 D 的最短距离为 9</p>
<h1 id="Graph-diagnostics"><a href="#Graph-diagnostics" class="headerlink" title="Graph diagnostics"></a>Graph diagnostics</h1><p>Graph diagnostic problems are graph problems that can be answered with Y&#x2F;N.</p>
<h2 id="Connectivity"><a href="#Connectivity" class="headerlink" title="Connectivity"></a>Connectivity</h2><p><img src="/Algorithm/Basics-of-Computer-Science/1.png" alt="G"></p>
<p>A graph G is connected, if for any two nodes there exists a walk between them.</p>
<hr>
<p>连通性是指图中任意两个顶点之间是否存在一条路径，使得两个顶点可以互相到达。如果一个图中的任意两个顶点都可以互相到达，那么这个图就被称为连通图。</p>
<p>要判断一个图是否连通，可以使用搜索算法，如广度优先搜索或深度优先搜索。搜索时，从图中的任意一个顶点开始，并尝试访问该顶点的所有邻接点。如果能够访问到图中所有的顶点，那么这个图就是连通图。</p>
<h2 id="Absolute-winner"><a href="#Absolute-winner" class="headerlink" title="Absolute winner"></a>Absolute winner</h2><p>绝对赢家指的是一个结点，它在一个博弈论游戏中总是能够获胜。这意味着，不论对手采取什么策略，该结点都有某种优势，使它能够获胜。例如，如果一个结点具有更多的邻居，那么它就可能是一个绝对赢家，因为它可以通过与其他结点交换信息来获得更多的有利条件。</p>
<p>绝对赢家与相对赢家有所不同。相对赢家指的是在某些情况下，某个结点比其他结点更有优势，从而使它有可能获胜。但是，如果对手采取了特定的策略，那么这个结点可能就不再是赢家了。而绝对赢家则不存在这种情况，它总是能够获能，不管对手采取什么策略。</p>
<h2 id="Complete-node-logical-formulas"><a href="#Complete-node-logical-formulas" class="headerlink" title="Complete node, logical formulas"></a>Complete node, logical formulas</h2><p>完全节点是指，这个节点与其他任何节点都至少存在一条边</p>
<p>至于 logical formulas，指的是 FDNF disjunctive normal form<br>它与 DNF 不同点似乎是每个出现的变量都会出现在每个子句中</p>
<h2 id="Graph-coloring"><a href="#Graph-coloring" class="headerlink" title="Graph coloring"></a>Graph coloring</h2><h3 id="Vertex"><a href="#Vertex" class="headerlink" title="Vertex"></a>Vertex</h3><p>顶点着色的规则是，任意两个相邻的顶点不能有相同的颜色。<br>并且我们使用尽可能少的颜色来着色。</p>
<p>我们从图中的一个顶点开始，为它分配一种颜色。然后，我们按照顶点的顺序遍历图中的其他顶点，为每个顶点分配一种与相邻顶点不同的颜色</p>
<h4 id="Brooks-theorem"><a href="#Brooks-theorem" class="headerlink" title="Brooks theorem"></a>Brooks theorem</h4><p>描述了图的着色数与图中最大度数的关系，提供了图着色数的一个上界</p>
<p>如果一个无向图 G 满足以下条件，那么它可以用 Δ(G) 或更少的颜色染色：</p>
<ul>
<li>G 是一个连通图（即它不包含任何脱离的部分）</li>
<li>G 不包含任何奇环（即它不包含任何长度为奇数的环）</li>
<li>Δ(G) 指的是图 G 中最大的度数。</li>
</ul>
<h4 id="Degree"><a href="#Degree" class="headerlink" title="Degree"></a>Degree</h4><p>度数指的是一个顶点与其相邻顶点之间的边的数量<br>度数可以用来衡量一个顶点与其他顶点的连通性。<br>通常情况下，一个顶点的度数越大，它与其他顶点的连通性就越强</p>
<h4 id="Four-color-theorem"><a href="#Four-color-theorem" class="headerlink" title="Four color theorem"></a>Four color theorem</h4><p>如果一个平面图 G 不包含任何环，那么它可以用不超过 4 种颜色染色，使得相邻的两个区域拥有不同的颜色。</p>
<h4 id="Subgraph"><a href="#Subgraph" class="headerlink" title="Subgraph"></a>Subgraph</h4><p>在原图中选择一些节点和边，并从原图中删除其他的节点和边。这样得到的图就是原图的一个子图。<br>如果一个节点的度数为 2，那么我们可以删除该节点，并将它与其他两个节点之间的两条边”合并”成一条边。</p>
<h3 id="Edge"><a href="#Edge" class="headerlink" title="Edge"></a>Edge</h3><p>给图中的边分配颜色，使得图中相邻的边拥有不同的颜色</p>
<p>Chromatic index 是图的最小着色度，指需要多少种不同的颜色</p>
<p>Vising theorem 指 对于任意一个无向图，它的染色度（chromatic number）不会超过其度数（degree）的上限</p>
<p>Bipartite graphs 是一种二分图，它由两个部分组成，每个部分内部的点互不相邻，而两个部分之间的点才会相互相邻。</p>
<p>Planar graphs 则是一种平面图，它是指图中任意两条边都不会相交，也就是说，图中的边可以在平面上放置而不会交叉。</p>
<hr>
<p>Scheduling problems</p>
<p>例如，在一个工厂生产线上，有许多不同的机器和工人，他们需要按照特定的顺序来完成各种任务。为了让生产流程顺利进行，我们可以使用 edge coloring 算法来给每个任务分配一种颜色，并确保相邻的任务颜色不同。这样，工人和机器就可以按照颜色顺序来执行任务，从而保证生产流程的顺利进行。</p>
<h1 id="Packing-and-Covering"><a href="#Packing-and-Covering" class="headerlink" title="Packing and Covering"></a>Packing and Covering</h1><h2 id="Generalization"><a href="#Generalization" class="headerlink" title="Generalization"></a>Generalization</h2><p>General, “everyday” problems, which have suboptimal solutions:</p>
<ol>
<li><p>Put in objects into one container!<br>Some pairs are incompatible, those cannot be put into the container together.<br>Question: how to put the maximal number of objects into the container?</p>
</li>
<li><p>n people at a meeting.<br>Find the largest subgroup of them, in which everybody knows everybody!</p>
</li>
<li><p>Trucker delivering goods with no going back<br>Question: how can they deliver the maximum number of goods?</p>
</li>
<li><p>Big piece of leather, cutting out small shapes.<br>Question: how to cut out the largest amount of smaller shapes?</p>
</li>
</ol>
<p>Common property of these problems: representable with a graph similarly.<br>Is there any connection between their solutions?</p>
<p>Let’s look at the problems solutions, starting with the “easiest”:</p>
<hr>
<p>一般来说，“日常” 问题，它们有着次优解：</p>
<ol>
<li><p>把物品放入一个容器中<br>有些物品是不兼容的，它们不能放在同一个容器中<br>问题：如何把最多的物品放入容器中？</p>
</li>
<li><p>n 个人在会议中<br>找到其中最大的一个子集，其中每个人都认识</p>
</li>
<li><p>卡车司机送货，不允许回头</p>
</li>
<li><p>大块皮革，切割成小块。<br>问题：如何切割出最多的小块？</p>
</li>
</ol>
<p>这些问题的共同特点：它们可以用图来表示</p>
<h3 id="Disjoint-Interval-Search"><a href="#Disjoint-Interval-Search" class="headerlink" title="Disjoint Interval Search"></a>Disjoint Interval Search</h3><ol start="3">
<li>Trucker delivering goods with no going back<br>Question: how can they deliver the maximum number of goods?</li>
</ol>
<p><img src="/Algorithm/Basics-of-Computer-Science/3.png" alt="Transfers"></p>
<p>Disjoint Interval Search (DIS)<br>This problem is also called interval packing.</p>
<hr>
<p><del>绎演丁真，鉴定为史</del></p>
<p>如果一个卡车司机要把货物送到多个不同的地方，而且一旦离开一个地方就不能再回去，<br>那么他应该怎样才能把尽可能多的货物送到目的地呢？</p>
<p>我寻思着这问题应该用 TSP 来解才对<br>总之先看看什么是 DIS</p>
<p>DIS 是一种用于处理区间数据的算法。<br>区间数据是指一组由起始和结束点表示的区间，例如：[1, 5]、[10, 15] 等。<br>它能够快速检索出与给定的区间不相交的区间。</p>
<ol>
<li>将区间数据存储在能够快速查找和插入的数据结构中，例如红黑树、平衡树或 B 树</li>
<li>查找与给定区间不相交的区间<br>检查区间数据中的每一个区间，并判断它们是否与给定区间不相交<br>如果一个区间与给定区间不相交，则将其加入结果集。</li>
<li>返回结果集</li>
</ol>
<h3 id="Clique"><a href="#Clique" class="headerlink" title="Clique"></a>Clique</h3><p>n people at a meeting.<br>Find the largest subgroup of them, in which everybody knows everybody!</p>
<p><img src="/Algorithm/Basics-of-Computer-Science/4.png" alt="Clique"></p>
<p>Can we find three people like that?<br>Can we find four people like that?<br>Can we find five people like that? Why not?<br>Clique search</p>
<hr>
<p><del>衣掩丁真，鉴定为衣驼使</del></p>
<p>这是一个分团问题<br>Clique search 是一种用于寻找图中的完全子图（即“clique”）的算法<br>完全子图是指一个子图中所有节点都相互连通<br>算法需要枚举所有可能的完全子图，并确定哪些子图满足给定的条件</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/86/6n-graf-clique.svg/300px-6n-graf-clique.svg.png" alt="一个大小为3的clique"></p>
<h3 id="Maximal-Independent-Set"><a href="#Maximal-Independent-Set" class="headerlink" title="Maximal Independent Set"></a>Maximal Independent Set</h3><p>Put in objects into one container!<br>Some pairs are incompatible, those cannot be put into the container together.<br>Question: how to put the maximal number of objects into the container?</p>
<p><img src="/Algorithm/Basics-of-Computer-Science/5.png" alt="MIS"></p>
<p>Edges code incompatibility.<br>We are searching for independent node subsets.<br>Maximal Independent Set (MIS)</p>
<p>We found a maximal empty subgraph.</p>
<p>Connection with the previous problem?<br>If we create the complimenting graph from this (where we had an edge, now we don’t have one, and vice versa), and consider the same chosen nodes, then that is a clique.</p>
<p>So we can convert this problem into the previous one: MIS → Clique search</p>
<p>These problems are basically the same, only their representation is different.</p>
<p>In this sense, even problem no.3 is the same as no.1 and no.2.</p>
<p>Converting problem no. 3 to the present form:</p>
<p><img src="/Algorithm/Basics-of-Computer-Science/6.png" alt="6"></p>
<p>Intervals are going to turn into vertices of a graph.<br>If two intervals are incompatible, we draw an edge between the corresponding nodes.</p>
<p>We converted DIS into MIS.</p>
<hr>
<p>Maximal Independent Set 是指一个图中没有一个节点与其他节点相邻，<br>并且该集合不能再增加任何节点而保持这种性质的节点集合</p>
<p>一个独立集（也称为稳定集）是一个图中一些两两不相邻的顶点所形成的集合，<br>如果两个点没有公共边，那么这两个点可以被放到一个独立集中</p>
<p><img src="https://sailist.github.io/AdAlgo/GraphTheory/fig/2.png" alt="MIS"></p>
<blockquote>
<p>对于三个点组成的完全图而言，每个点自身是一个独立集（且是最大独立集）<br>对四个点构成的四边形图而言，对角的两个点组成一个独立集（且是最大独立集）</p>
</blockquote>
<p>如果往图 G 的独立集 S 中添加任一个顶点都会使独立性丧失（亦即造成某两点间有边），那么称 S 是极大独立集。</p>
<p>如果 S 是图中所有独立集之中基数最大的，那么称 S 是最大独立集，且将该基数称为 G 的独立数，记为 α(G)。一般来讲，图 G 中可能存在多个极大独立集和最大独立集。</p>
<blockquote>
<p>根据定义，最大独立集一定是极大独立集，但反之未必。</p>
</blockquote>
<h3 id="Cut"><a href="#Cut" class="headerlink" title="Cut"></a>Cut</h3><p>Big piece of leather, cutting out small shapes.<br>Question: how to cut out the largest amount of smaller shapes?</p>
<p>大块的皮革，切出小的形状。<br>问：如何切出最多的小形状？</p>
<p><img src="/Algorithm/Basics-of-Computer-Science/7.png" alt="7"></p>
<p>We can rotate the sample, but we still have to fit into the big piece of leather.</p>
<p>我们可以旋转样本，但我们仍然要贴合大块皮革。</p>
<p>This is the most difficult problem out of the four, because the main “philosophical” difference between them is that the first three were obvious finite problems (finite number of people, objects, intervals), whereas this problem cannot produce obvious finite number of nodes.</p>
<p>这是四个问题中最困难的一个，因为它们之间的主要“哲学”区别在于前三个是显然的有限问题（人数、物品数、区间数都是有限的），而这个问题不能产生显然的有限节点数。</p>
<p><img src="/Algorithm/Basics-of-Computer-Science/8.png" alt="8"></p>
<p>So we make a grid on the big leather, place a node on the shape, and say that the shape can only be cut out of that node fits on one of the grid points.</p>
<p>因此，我们在大皮革上做一个网格，在形状上放一个节点，并说形状只能在该节点适合网格点之一时被切出来。</p>
<p>The grid points create a finite set. But since we can still rotate the shape around the grid point, our choices are infinite again. Solution: we only consider a few angles. So now we can only cut out the shape if the node is ou a grid point, and the line on the sample can only parallel to one of our predefined angle lines.</p>
<p>网格点创建了一个有限集。但是，由于我们仍然可以围绕网格点旋转形状，所以我们的选择又是无限的。解决方案：我们只考虑几个角度。因此，现在我们只能在节点在网格点上并且样本上的线只能与我们预定义的角度线平行时切出形状。</p>
<p>So to make an infinite problem finite we need to add restrictions.</p>
<p>因此，要使无限问题变为有限，我们需要增加限制。</p>
<p><img src="/Algorithm/Basics-of-Computer-Science/9.png" alt="9"></p>
<p>We can code the placement with the number of the grid point and the number of the angle.<br>Eg: (5; 6) and (14; 6).</p>
<p>我们可以用网格点的编号和角度的编号来编码放置位置。例如：（5；6）和（14；6）。</p>
<p>However, these two overlap, so they cannot be cut out together. This incompatibility can be represented in a graph by adding an edge between these two number pains.</p>
<p>然而，这两个重叠了，因此它们不能一起切出来。这种不兼容可以通过在这两个数字之间添加一条边来表示在图中。</p>
<p>This way we can create a graph, and the maximum number of cutouts on the leather is reduced to finding the maximal number of independent nodes in the corresponding graph.</p>
<p>这样我们就可以创建一个图，皮革上的最大切割次数就被减少到在相应图中找到最大的独立节点数。</p>
<p>What is the problem with this method?<br>The restrictions can cause a result with less cutouts, than if we could freely place the shape.</p>
<p>这种方法有什么问题？<br>限制可能导致切割次数比我们可以自由放置形状时少的结果。</p>
<p>Solution: let’s use a denser grid and consider none rotational angles!</p>
<p>解决方案：让我们使用更密集的网格并考虑非旋转角度！</p>
<p>Problem with the solution: as we have more gridpoints and angles, the graph becomes larger, so finding the MI5 is more complicated.</p>
<p>解决方案的问题：随着我们有更多的网格点和角度，图变得更大，因此找到 MI5 变得更复杂。</p>
<p>So this method is a digitalization, which has a resolution. The bigger the resolution is, the closer to the optimal solution we are.</p>
<p>因此，这种方法是一种数字化，它具有分辨率。分辨率越大，我们越接近最优解。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Ater examining these four problems, we have a general framework:</p>
<p>在经过对这四个问题的检查后，我们得出了一个总体框架：</p>
<p>Given is a graph. Find the maximal number of nodes such that those are never connected to each other. &lt;&#x3D;&gt; We want to find the maximal independent set of nodes. → MIS problem.</p>
<p>给定一张图。找到一个节点的最大数量，这些节点从不相互连接。&lt;&#x3D;&gt;我们想找到节点的最大独立集合。→MIS 问题。</p>
<p>This can be solved in exponential time.</p>
<p>这可以在指数时间内解决。</p>
<p>The trivial algorithm for finding MIS:</p>
<p>找到 MIS 的简单算法：</p>
<p>We want to find MIS of { 1, 2, 3, 4, 5, 6 }. We try to find an independent subset of size 2. Start with 41,2}. Is this independent? No! So try { 1, 3 }. This is good! But then can we find an independent subset of nite 3? We need to check all site 3 subsets.</p>
<p>我们想找到 {1,2,3,4,5,6} 的 MIS。我们试图找到大小为 2 的独立子集。从 {1,2} 开始。这是独立的吗？不是！所以尝试 {1,3}。这很好！但是然后我们能找到大小为 3 的独立子集吗？我们需要检查所有大小为 3 的子集。</p>
<p>In the worst case we need to investigate all subsets of { 1, 2, 3, 4, 5, 6 }</p>
<p>在最坏的情况下，我们需要调查 {1,2,3,4,5,6} 的所有子集</p>
<p>Theorem: If |x| &#x3D; n, then |p(x)| &#x3D; 2^n.</p>
<p>(p(x) &#x3D; { y | y &lt;&#x3D; x } -&gt; power set &#x3D; set of all subsets)</p>
<p>In our example n &#x3D; 6, so we have 2^6 &#x3D; 64 subsets.</p>
<p>How to code subsets?</p>
<p>{ 1, 2, 3, 4, 5, 6 }</p>
<table>
<thead>
<tr>
<th>1</th>
<th>0</th>
<th>1</th>
<th>0</th>
<th>0</th>
<th>0</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
</tbody></table>
<p>-&gt; this will code { 1; 3 }<br>-&gt; this will code { 1; 2; 6 }</p>
<p>Since it is a one-to-one correspondence between subsets and outshines,<br>then |p(x)| &#x3D; |{ binary string of length 8 }|</p>
<p>因为子集和出现之间是一一对应的，所以 |p(x)| &#x3D; |{长度为 8 的二进制字符串}|</p>
<p>because a choice codes 1 On 0 &#x3D; yes or no</p>
<p>因为选择编码 1 On 0 &#x3D; yes or no</p>
<p>In terms of our MIS - finding problem: if we count checking a binary string for independence, then this trivial algorithm has an exponential runtime, exactly 2^n.</p>
<p>就我们的 MIS 查找问题而言：如果我们算出检查一个二进制字符串是否独立的次数，那么这个简单算法的运行时间是指数级别的，精确地说是 2^n。</p>
<p>A more refined algorithm for the same problem:<br>Find a method, where we only check already independent sets.</p>
<p>同一问题的一种更优秀的算法：<br>找到一种方法，只检查已经独立的集合。</p>
<p>Example:</p>
<p><img src="/Algorithm/Basics-of-Computer-Science/10.png" alt="10"></p>
<p>The independent set is called S.<br>We always ask the nodes whether they are an element of S. → “yes” branches and “no” branches. Next question is based on already existing elements.</p>
<p>独立集合称为 S。<br>我们总是问节点是否是 S 的元素。→“是”和“否”分支。下一个问题是基于已存在的元素。</p>
<p>This is a labelled and rooted binary thee.<br>Can be done faster, if we are only considering paths that have a chance to have enough nodes on them.<br>“if it’s not there, don’t even look”</p>
<p>这是一棵带标签和根的二叉树。<br>如果我们只考虑可能有足够节点的路径，可以更快地完成。<br>“如果它不在那里，甚至都不用看”。</p>
<h2 id="Interval-packing-dominating-sets"><a href="#Interval-packing-dominating-sets" class="headerlink" title="Interval packing, dominating sets"></a>Interval packing, dominating sets</h2><p>A little help for the next algorithm: the Pidgeon-hole principle.</p>
<p>下一算法的一点帮助：鸽巢原理。</p>
<p><img src="/Algorithm/Basics-of-Computer-Science/11.png" alt="11"></p>
<p>Question: when the pigeons go to their pigeon-holes, what can we state for sure?<br>Whichever houses they choose, there is going to be at least one hole with two pigeons in it.</p>
<p>问题：当鸽子去它们的鸽巢时，我们能肯定什么？<br>无论它们选择哪所房子，至少会有一个洞有两只鸽子。</p>
<p>So the pigeon-hole principle says that if there are more pigeons than houses, then there will be at least one hole with at least two pigeons in it.</p>
<p>因此，鸽巢原理说，如果有比房子更多的鸽子，那么至少会有一个洞至少有两只鸽子。</p>
<p>If this weren’t true, and all houses tould contain one pigeon at worst, then there would be only as many pigeons as houses. Whereas we had more pigeons.</p>
<p>如果这不是真的，并且所有的房子里最多只有一只鸽子，那么只会有和房子一样多的鸽子。但我们有更多的鸽子。</p>
<p>If we use our previous example 3, we can apply the pigeon-hole principle to the problem:</p>
<p>如果我们用之前的例子 3，我们可以将鸽巢原理应用于问题：</p>
<p><img src="/Algorithm/Basics-of-Computer-Science/12.png" alt="12"></p>
<p>The algorithm: choose closest destination, if starting point is still ahead<br>&#x3D;&gt; maximal number of &#x3D;&gt; independent intervals &#x3D;&gt; Interval packing algorithm</p>
<p>算法：如果起点仍然在前面，则选择最近的目的地<br>&#x3D;&gt;最大数量的&#x3D;&gt;独立区间&#x3D;&gt;区间打包算法</p>
<p>If we only consider the destinations as pink dots, then we can choose any interval, there will always be a pink dot on it - at least one dot.<br>&#x3D;&gt; the set of pink dots is a dominating set.</p>
<p>如果我们只考虑目的地作为粉红色点，那么我们可以选择任何区间，它上面总会有一个粉点——至少有一个点。<br>&#x3D;&gt;粉点集是一个支配集。</p>
<p>A set X is a dominating set, if for every you find at least one element of the set on that interval.</p>
<p>一个集合 X 是支配集，如果对于每个区间都能找到集合中的至少一个元素。</p>
<p>Femina: X is a dominating set, 4 is an independent set of intervals.<br>Then |x| &gt;&#x3D; |y|.</p>
<p>X 是支配集，4 是区间的独立集。</p>
<p>The chosen intervals corresponding to the transportation is an independent set with three intervals. There are also three pink dots as the dominant set. So based on the lemma, there can be no more independent intervals.</p>
<p>选择的区间对应于运输是具有三个区间的独立集。还有三个粉红色的点作为支配集。因此，根据引理，不能有更多的独立区间。</p>
<p>Proof: Indirectly. New statement: |x|birds &lt; |y|houses.</p>
<p>Let’s have one more independent interval. But according to the pigeon-hole principle, there is at least one pint dominating dot on every interval. In order to dominate the all intervals, we would need at 1 different pink dots.</p>
<p>让我们再来一个独立区间。但根据鸽巢原理，每个区间都至少有一个主要点。为了控制所有区间，我们需要至少 1 个不同的粉点。</p>
<p>&#x3D;&gt; There must be at least two intervals with the same pink dot,but then they’re not independent.</p>
<p>&#x3D;&gt; 必须有至少两个区间有相同的粉点，但这样它们就不是独立的了。</p>
<p>Even though there is no general quick (polynomial) solution for<br>finding MIS, the Interval pairing algorithm is fast. How fast?</p>
<p>尽管没有求解 MIS 的通用快速（多项式）解决方案，但 Interval pairing 算法是快速的。它有多快？</p>
<p>We shone all starting and destination point somehow - e.g. by numbers.<br>So we only have to order them, and find the “smallest” endpoint first.</p>
<p>我们用某种方式给所有起点和终点标号——例如，用数字。<br>所以我们只需要按顺序排序，找到“最小”的终点。</p>
<p>~n steps needed to find the closest destination<br>we need to repeat it at worst a times &#x3D;&gt; polynomial algorithm</p>
<p>找到最近目的地需要 ~n 步<br>最坏情况下，我们需要重复 a 次，所以这是一个多项式算法</p>
<p>How can it be that MI5 can’t be solved quickly, but this algorithm has quadratic runtime?!</p>
<p>为什么 MI5 无法快速解决，但这个算法的运行时间是二次的呢？</p>
<p>The intervals are represented as nodes and overlaps as edges in the graph.<br>So did we just solve MI5 in quadratic time?!</p>
<p>区间在图中表示为节点，重叠部分表示为边。<br>所以我们刚刚在二次时间内解决了 MI5 吗？</p>
<p>No! Because not all graphs can be processed by this method. (Not all graphs with a nodes occur this way.) so we only solved MI5 for a subset of graphs having a nodes.</p>
<p>不是的！因为并不是所有图都可以用这种方法处理。（不是所有带有 n 个节点的图都是这样出现的。）所以我们只为一个带有 n 个节点的图子集解决了 MI5。</p>
<p>So for a subset of cases we have a solution, but not for the general case.<br>(e.g. 5th degree polynomials)</p>
<p>所以对于一个子集的情况，我们有一个解决方案，但不是通用情况。（例如，五次多项式）</p>
<hr>
<p>区间打包，用于找到最多可以放在一个容器内的不相交区间的最大数量。是指把一系列区间尽可能多地放到一个集合中，使得它们都不重叠。</p>
<p>支配集指在一张图中，存在一组节点，每个节点都与它相邻的节点相连，或者至少有一个节点在该组中。其中的元素可以覆盖整个集合，即每个元素都与至少一个其他元素有交集。</p>
<h2 id="Suboptimal-algorithms"><a href="#Suboptimal-algorithms" class="headerlink" title="Suboptimal algorithms"></a>Suboptimal algorithms</h2><p>次优算法</p>
<p>what is the basic problem?<br>→ polynomial algorithms are “quick”<br>→ exponential algorithms are “very slow”</p>
<p>基本问题是什么？<br>→ 多项式算法“快”<br>→ 指数算法“非常慢”</p>
<p>There is a set of problems for which there is no quick algorithm.</p>
<p>有一类问题没有快速算法。</p>
<p>Their runtime is proportionate to f(a) &#x3D;2^n. To put this in perspective, there are no more than 2^350 atoms in the whole universe.</p>
<p>它们的运行时间与 f(a) &#x3D; 2^n 成比例。<br>为了更好地理解这一点，整个宇宙中没有超过 2^350 种原子。</p>
<p>Therefore we can just use this disadvantage to our advantage by using these kind of problems for coding protocols, as decoding them would tale over a million years.</p>
<p>因此，我们可以利用这个缺点，通过使用这类问题来编写编码协议，因为解码它们需要超过一百万年。</p>
<p>Good example for this is finding a Hamiltonian cycle in a graph. Creating is easy, but then we can obfuscate it.</p>
<p>寻找图中的汉密尔顿回路是一个很好的例子。<br>创建容易，但是我们可以混淆它。</p>
<p><img src="/Algorithm/Basics-of-Computer-Science/13.png" alt="13"></p>
<p>Problem is, that there are a lot of real-life situations that can only be converted into these kinds of problems, where the solution is exponential, or even worse.</p>
<p>问题是，有很多现实生活中的情况只能转换为这类问题，其解是指数级的，甚至更糟。</p>
<p>Good example is the traveling agent problem. This is understood on weighed graphs, and the point is to touch all the nodes with a minimal sum of edge weights. (Hamiltonian path problem).</p>
<p>一个很好的例子是旅行代理问题。这在加权图上是可以理解的，其目的是以最小的边权和触摸所有节点。（汉密尔顿路径问题）</p>
<p>In this case we can imagine a package delivery service, in which case we need the shortest possible combination &#x2F; permutation of the packages in order to make the least amount of kilometers. Though, this is a hard problem, meaning, there exists not a quick algorithm for this.</p>
<p>在这种情况下，我们可以想象一个包裹配送服务，在这种情况下，我们需要包裹的最短可能组合&#x2F;排列，以便减少尽可能多的公里数。尽管这是一个难题，即不存在一个快速的算法来解决这个问题。</p>
<p>&#x3D;&gt; suboptimal algorithms<br>-&gt; We don’t want to (&#x3D; can’t) find the best solution, but something that is pretty close this best solution.</p>
<p>&#x3D;&gt; 次优算法<br>-&gt; 我们不想（也不能）找到最优解，而是找到一个非常接近最优解的解决方案。</p>
<p>So in case of the traveling agent, we don’t want to find the optimal route, but we want a route such that it is sure that it uses at more Klia as many kilometers as the optimal one. It would be a 2-optimal algorithm.</p>
<p>所以在旅行代理的情况下，我们不想找到最优路线，而是想找到一条路线，使得它确保它使用的公里数至少与最优路线相同。这将是一个 2-optimal 算法。</p>
<p>So the suboptimality of algorithms has nothing to do with running time.</p>
<p>因此，算法的次优性与运行时间无关。</p>
<p>In the traveling agent situation a 3-optimal algorithm would find a solution that is at most three times worse than the optimal one, meaning, it would find a permutation of the target adnesses such that if the driver follows that order, than at most three times as many kilometers are used as in case of the optimal solution.</p>
<p>在旅行代理的情况下，3-optimal 算法将找到一个至多比最优解差三倍的解决方案，这意味着它会找到目标地址的一个排列，如果司机遵循这种顺序，那么至多会使用三倍于最优解情况下的公里数。</p>
<p>An algorithm is called k-optimal (k ≥ 1) if its output is at most b-times worse than the best output would be.</p>
<p>如果其输出最多比最佳输出差 b 倍，则称该算法为 k-optimal（k ≥ 1）。</p>
<h2 id="Bin-packing-problem"><a href="#Bin-packing-problem" class="headerlink" title="Bin packing problem"></a>Bin packing problem</h2><p><img src="/Algorithm/Basics-of-Computer-Science/14.png" alt="14"></p>
<p>Objects with volumes:<br>V1, V2, V3 … Vn.</p>
<p>Vi &lt;&#x3D; (i &#x3D; 1, …, n)</p>
<p>Problem: use the least amount of containers to store all objects.</p>
<p>问题：使用最少的容器来存储所有物品。</p>
<p>(The sum of the volumes of objects in one container can’t exceed volume of the container.)</p>
<p>（一个容器中物品的总体积不能超过容器的体积。）</p>
<p>This is a hard problem. But there exists a 2-optimal algorithm for that.</p>
<p>这是一个难题。但是存在一个 2-optimal 算法。</p>
<p>First Fit Algorithm: Choose the first container in which the object fits. (This is greedy.)</p>
<p>首次适应算法：选择第一个容器，其中的物品适合。（这是贪婪的。）</p>
<h3 id="降序首次适应算法"><a href="#降序首次适应算法" class="headerlink" title="降序首次适应算法"></a>降序首次适应算法</h3><p>First Fit Decreasing</p>
<ol>
<li>将物品按照价值从大到小排序</li>
<li>找到一个能放下物品的背包，放入物品</li>
<li>重复 2，直到所有物品都放入</li>
</ol>
<p>简而言之，FFD 按照大小降序排列项目，然后放入第一合适的背包</p>
<h1 id="Algebraic-algorithms"><a href="#Algebraic-algorithms" class="headerlink" title="Algebraic algorithms"></a>Algebraic algorithms</h1><h2 id="Divisibility-Euclidean-algorithm"><a href="#Divisibility-Euclidean-algorithm" class="headerlink" title="Divisibility, Euclidean algorithm"></a>Divisibility, Euclidean algorithm</h2><h2 id="Faster-multiplication-and-division-of-large-numbers"><a href="#Faster-multiplication-and-division-of-large-numbers" class="headerlink" title="Faster multiplication and division of large numbers"></a>Faster multiplication and division of large numbers</h2></div><div class="article-licensing box"><div class="licensing-title"><p>Basics of Computer Science</p><p><a href="https://aloen.to/Algorithm/Basics-of-Computer-Science/">https://aloen.to/Algorithm/Basics-of-Computer-Science/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>Aloento</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2022-12-07</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2024-10-11</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a><a class="" rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E7%AE%97%E6%B3%95/">算法</a><a class="link-muted mr-2" rel="tag" href="/tags/%E7%AC%94%E8%AE%B0/">笔记</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/Math/Matlab/Numerical-Methods-II/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Numerical Methods II</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/Math/Logic/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%912-B%E5%8D%B7/"><span class="level-item">数理逻辑2 B卷</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/Aloento.png" alt="Aloento"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Aloento</p><p class="is-size-6 is-block">Reindeer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Foot of Sacred Mountain</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">32</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">19</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">34</p></a></div></div></nav></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/AI/"><span class="level-start"><span class="level-item">AI</span></span><span class="level-end"><span class="level-item tag">10</span></span></a><ul><li><a class="level is-mobile" href="/categories/AI/NLP/"><span class="level-start"><span class="level-item">NLP</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Algorithm/"><span class="level-start"><span class="level-item">Algorithm</span></span><span class="level-end"><span class="level-item tag">7</span></span></a><ul><li><a class="level is-mobile" href="/categories/Algorithm/TM/"><span class="level-start"><span class="level-item">TM</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Cloud/"><span class="level-start"><span class="level-item">Cloud</span></span><span class="level-end"><span class="level-item tag">2</span></span></a><ul><li><a class="level is-mobile" href="/categories/Cloud/OpenStack/"><span class="level-start"><span class="level-item">OpenStack</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Data-Science/"><span class="level-start"><span class="level-item">Data Science</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Database/"><span class="level-start"><span class="level-item">Database</span></span><span class="level-end"><span class="level-item tag">2</span></span></a><ul><li><a class="level is-mobile" href="/categories/Database/MSSQL/"><span class="level-start"><span class="level-item">MSSQL</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Database/Theory/"><span class="level-start"><span class="level-item">Theory</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Math/"><span class="level-start"><span class="level-item">Math</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul><li><a class="level is-mobile" href="/categories/Math/Logic/"><span class="level-start"><span class="level-item">Logic</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Math/Matlab/"><span class="level-start"><span class="level-item">Matlab</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Memo/"><span class="level-start"><span class="level-item">Memo</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Program/"><span class="level-start"><span class="level-item">Program</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/Program/C/"><span class="level-start"><span class="level-item">C++</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/Program/C/CLI/"><span class="level-start"><span class="level-item">CLI</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Program/Python/"><span class="level-start"><span class="level-item">Python</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Program/WebCodecs/"><span class="level-start"><span class="level-item">WebCodecs</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/NET/"><span class="tag">.NET</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/AI/"><span class="tag">AI</span><span class="tag">10</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C#</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C++</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CLI/"><span class="tag">CLI</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JS/"><span class="tag">JS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/LINQ/"><span class="tag">LINQ</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Matplotlib/"><span class="tag">Matplotlib</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/NLP/"><span class="tag">NLP</span><span class="tag">10</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OpenStack/"><span class="tag">OpenStack</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SQL/"><span class="tag">SQL</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SQLServer/"><span class="tag">SQLServer</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/WebCodecs/"><span class="tag">WebCodecs</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%B9%A0%E9%A2%98/"><span class="tag">习题</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BA%91/"><span class="tag">云</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%89%8D%E7%AB%AF/"><span class="tag">前端</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8C%88%E7%89%99%E5%88%A9/"><span class="tag">匈牙利</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9B%BE%E7%81%B5%E6%9C%BA/"><span class="tag">图灵机</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%94%BB%E7%95%A5/"><span class="tag">攻略</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E5%80%BC%E6%96%B9%E6%B3%95/"><span class="tag">数值方法</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E5%AD%A6/"><span class="tag">数学</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="tag">数据库</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"><span class="tag">数据科学</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%95%99%E5%AD%A6/"><span class="tag">留学</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AC%94%E8%AE%B0/"><span class="tag">笔记</span><span class="tag">21</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BC%96%E7%A8%8B/"><span class="tag">编程</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BF%BB%E8%AF%91/"><span class="tag">翻译</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%80%83%E8%AF%95/"><span class="tag">考试</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%80%BB%E8%BE%91/"><span class="tag">逻辑</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%9D%A2%E8%AF%95/"><span class="tag">面试</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"><span class="tag">音视频</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://Q-Audio.org" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Q-Audio</span></span><span class="level-right"><span class="level-item tag">q-audio.org</span></span></a></li><li><a class="level is-mobile" href="https://Musi.Land" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">MusiLand</span></span><span class="level-right"><span class="level-item tag">musi.land</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#Algorithmic-problems-modelling"><span class="level-left"><span class="level-item">1</span><span class="level-item">Algorithmic problems, modelling</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#What-is-it-good-for"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">What is it good for</span></span></a></li><li><a class="level is-mobile" href="#Branches-of-ToC"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">Branches of ToC</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Automata-theory"><span class="level-left"><span class="level-item">1.2.1</span><span class="level-item">Automata theory</span></span></a></li><li><a class="level is-mobile" href="#Computability-Theory"><span class="level-left"><span class="level-item">1.2.2</span><span class="level-item">Computability Theory</span></span></a></li><li><a class="level is-mobile" href="#Complexity-Theory"><span class="level-left"><span class="level-item">1.2.3</span><span class="level-item">Complexity Theory</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Modlling"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">Modlling</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Tools-of-modelling"><span class="level-left"><span class="level-item">1.3.1</span><span class="level-item">Tools of modelling</span></span></a></li><li><a class="level is-mobile" href="#Graph-definition"><span class="level-left"><span class="level-item">1.3.2</span><span class="level-item">Graph definition</span></span></a></li><li><a class="level is-mobile" href="#Graph-Representations"><span class="level-left"><span class="level-item">1.3.3</span><span class="level-item">Graph Representations</span></span></a></li><li><a class="level is-mobile" href="#Examples-of-graph-models"><span class="level-left"><span class="level-item">1.3.4</span><span class="level-item">Examples of graph models</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#Turing-Machines"><span class="level-left"><span class="level-item">2</span><span class="level-item">Turing Machines</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#What-is-a-Turing-Machine"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">What is a Turing Machine</span></span></a></li><li><a class="level is-mobile" href="#Defining-a-Turing-Machine"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">Defining a Turing Machine</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Complexity-of-algorithms"><span class="level-left"><span class="level-item">3</span><span class="level-item">Complexity of algorithms</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#时间复杂度"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">时间复杂度</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#常数阶-O-1"><span class="level-left"><span class="level-item">3.1.1</span><span class="level-item">常数阶 O(1)</span></span></a></li><li><a class="level is-mobile" href="#对数阶-O-logN"><span class="level-left"><span class="level-item">3.1.2</span><span class="level-item">对数阶 O(logN)</span></span></a></li><li><a class="level is-mobile" href="#线性阶-O-N"><span class="level-left"><span class="level-item">3.1.3</span><span class="level-item">线性阶 O(N)</span></span></a></li><li><a class="level is-mobile" href="#线性对数阶-O-NlogN"><span class="level-left"><span class="level-item">3.1.4</span><span class="level-item">线性对数阶 O(NlogN)</span></span></a></li><li><a class="level is-mobile" href="#平方阶-O-N-2"><span class="level-left"><span class="level-item">3.1.5</span><span class="level-item">平方阶 O(N^2)</span></span></a></li><li><a class="level is-mobile" href="#计算"><span class="level-left"><span class="level-item">3.1.6</span><span class="level-item">计算</span></span></a></li></ul></li><li><a class="level is-mobile" href="#空间复杂度"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">空间复杂度</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#O-1"><span class="level-left"><span class="level-item">3.2.1</span><span class="level-item">O(1)</span></span></a></li><li><a class="level is-mobile" href="#O-N"><span class="level-left"><span class="level-item">3.2.2</span><span class="level-item">O(N)</span></span></a></li><li><a class="level is-mobile" href="#计算-1"><span class="level-left"><span class="level-item">3.2.3</span><span class="level-item">计算</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#Sorting-algorithms-and-their-complexity"><span class="level-left"><span class="level-item">4</span><span class="level-item">Sorting algorithms and their complexity</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#O-N-1"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">O(N)</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#计数排序"><span class="level-left"><span class="level-item">4.1.1</span><span class="level-item">计数排序</span></span></a></li><li><a class="level is-mobile" href="#桶排序"><span class="level-left"><span class="level-item">4.1.2</span><span class="level-item">桶排序</span></span></a></li><li><a class="level is-mobile" href="#基数排序"><span class="level-left"><span class="level-item">4.1.3</span><span class="level-item">基数排序</span></span></a></li></ul></li><li><a class="level is-mobile" href="#O-NlogN"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">O(NlogN)</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#希尔排序"><span class="level-left"><span class="level-item">4.2.1</span><span class="level-item">希尔排序</span></span></a></li><li><a class="level is-mobile" href="#归并排序"><span class="level-left"><span class="level-item">4.2.2</span><span class="level-item">归并排序</span></span></a></li><li><a class="level is-mobile" href="#快速排序"><span class="level-left"><span class="level-item">4.2.3</span><span class="level-item">快速排序</span></span></a></li><li><a class="level is-mobile" href="#堆排序"><span class="level-left"><span class="level-item">4.2.4</span><span class="level-item">堆排序</span></span></a></li></ul></li><li><a class="level is-mobile" href="#O-N-2"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">O(N^2)</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#冒泡排序"><span class="level-left"><span class="level-item">4.3.1</span><span class="level-item">冒泡排序</span></span></a></li><li><a class="level is-mobile" href="#选择排序"><span class="level-left"><span class="level-item">4.3.2</span><span class="level-item">选择排序</span></span></a></li><li><a class="level is-mobile" href="#插入排序"><span class="level-left"><span class="level-item">4.3.3</span><span class="level-item">插入排序</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#Basic-graph-algorithms"><span class="level-left"><span class="level-item">5</span><span class="level-item">Basic graph algorithms</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#深度优先搜索"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">深度优先搜索</span></span></a></li><li><a class="level is-mobile" href="#广度优先搜索"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">广度优先搜索</span></span></a></li><li><a class="level is-mobile" href="#遍历"><span class="level-left"><span class="level-item">5.3</span><span class="level-item">遍历</span></span></a></li><li><a class="level is-mobile" href="#Dijsktra"><span class="level-left"><span class="level-item">5.4</span><span class="level-item">Dijsktra</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Graph-diagnostics"><span class="level-left"><span class="level-item">6</span><span class="level-item">Graph diagnostics</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Connectivity"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">Connectivity</span></span></a></li><li><a class="level is-mobile" href="#Absolute-winner"><span class="level-left"><span class="level-item">6.2</span><span class="level-item">Absolute winner</span></span></a></li><li><a class="level is-mobile" href="#Complete-node-logical-formulas"><span class="level-left"><span class="level-item">6.3</span><span class="level-item">Complete node, logical formulas</span></span></a></li><li><a class="level is-mobile" href="#Graph-coloring"><span class="level-left"><span class="level-item">6.4</span><span class="level-item">Graph coloring</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Vertex"><span class="level-left"><span class="level-item">6.4.1</span><span class="level-item">Vertex</span></span></a></li><li><a class="level is-mobile" href="#Edge"><span class="level-left"><span class="level-item">6.4.2</span><span class="level-item">Edge</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#Packing-and-Covering"><span class="level-left"><span class="level-item">7</span><span class="level-item">Packing and Covering</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Generalization"><span class="level-left"><span class="level-item">7.1</span><span class="level-item">Generalization</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Disjoint-Interval-Search"><span class="level-left"><span class="level-item">7.1.1</span><span class="level-item">Disjoint Interval Search</span></span></a></li><li><a class="level is-mobile" href="#Clique"><span class="level-left"><span class="level-item">7.1.2</span><span class="level-item">Clique</span></span></a></li><li><a class="level is-mobile" href="#Maximal-Independent-Set"><span class="level-left"><span class="level-item">7.1.3</span><span class="level-item">Maximal Independent Set</span></span></a></li><li><a class="level is-mobile" href="#Cut"><span class="level-left"><span class="level-item">7.1.4</span><span class="level-item">Cut</span></span></a></li><li><a class="level is-mobile" href="#总结"><span class="level-left"><span class="level-item">7.1.5</span><span class="level-item">总结</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Interval-packing-dominating-sets"><span class="level-left"><span class="level-item">7.2</span><span class="level-item">Interval packing, dominating sets</span></span></a></li><li><a class="level is-mobile" href="#Suboptimal-algorithms"><span class="level-left"><span class="level-item">7.3</span><span class="level-item">Suboptimal algorithms</span></span></a></li><li><a class="level is-mobile" href="#Bin-packing-problem"><span class="level-left"><span class="level-item">7.4</span><span class="level-item">Bin packing problem</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#降序首次适应算法"><span class="level-left"><span class="level-item">7.4.1</span><span class="level-item">降序首次适应算法</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#Algebraic-algorithms"><span class="level-left"><span class="level-item">8</span><span class="level-item">Algebraic algorithms</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Divisibility-Euclidean-algorithm"><span class="level-left"><span class="level-item">8.1</span><span class="level-item">Divisibility, Euclidean algorithm</span></span></a></li><li><a class="level is-mobile" href="#Faster-multiplication-and-division-of-large-numbers"><span class="level-left"><span class="level-item">8.2</span><span class="level-item">Faster multiplication and division of large numbers</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-10-10T13:07:12.000Z">2024-10-10</time></p><p class="title"><a href="/AI/NLP/NLP-Seq2Seq/">NLP-Seq2Seq</a></p><p class="categories"><a href="/categories/AI/">AI</a> / <a href="/categories/AI/NLP/">NLP</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-10-09T13:05:18.000Z">2024-10-09</time></p><p class="title"><a href="/AI/NLP/NLP-RNNs/">NLP-RNNs</a></p><p class="categories"><a href="/categories/AI/">AI</a> / <a href="/categories/AI/NLP/">NLP</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-10-08T13:04:05.000Z">2024-10-08</time></p><p class="title"><a href="/AI/NLP/NLP-StaticNeuralEmbeddings/">NLP-StaticNeuralEmbeddings</a></p><p class="categories"><a href="/categories/AI/">AI</a> / <a href="/categories/AI/NLP/">NLP</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-10-07T10:40:19.000Z">2024-10-07</time></p><p class="title"><a href="/AI/NLP/NLP-LexicalSemantics/">NLP-LexicalSemantics</a></p><p class="categories"><a href="/categories/AI/">AI</a> / <a href="/categories/AI/NLP/">NLP</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-10-06T09:20:27.000Z">2024-10-06</time></p><p class="title"><a href="/AI/NLP/NLP-DependencyParsing/">NLP-DependencyParsing</a></p><p class="categories"><a href="/categories/AI/">AI</a> / <a href="/categories/AI/NLP/">NLP</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/10/"><span class="level-start"><span class="level-item">October 2024</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/09/"><span class="level-start"><span class="level-item">September 2024</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/08/"><span class="level-start"><span class="level-item">August 2024</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/05/"><span class="level-start"><span class="level-item">May 2024</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/03/"><span class="level-start"><span class="level-item">March 2024</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/02/"><span class="level-start"><span class="level-item">February 2024</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/12/"><span class="level-start"><span class="level-item">December 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/10/"><span class="level-start"><span class="level-item">October 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/12/"><span class="level-start"><span class="level-item">December 2022</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/11/"><span class="level-start"><span class="level-item">November 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/06/"><span class="level-start"><span class="level-item">June 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/04/"><span class="level-start"><span class="level-item">April 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/12/"><span class="level-start"><span class="level-item">December 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><p class="is-size-7"><span>&copy; 2024 Aloento</span><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Q-Audio" href="https://Q-Audio.org"><i class="fas fa-compact-disc"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="MusiLand" href="https://Musi.Land/"><i class="fab fa-dashcube"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="GitHub" href="https://github.com/Aloento"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><script src="https://cdnjs.cloudflare.com/ajax/libs/lightgallery/1.10.0/js/lightgallery.min.js" defer></script><script src="https://cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><script type="text/javascript" id="MathJax-script" async>MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      },
      svg: {
        fontCache: 'global'
      },
      chtml: {
        matchFontHeight: false
      }
    };</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.15.1/katex.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.15.1/katex.min.js" defer></script><script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.15.1/contrib/auto-render.min.js" defer></script><script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.15.1/contrib/mhchem.min.js" defer></script><script>window.addEventListener("load", function() {
            document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
                renderMathInElement(element);
            });
        });</script><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>