{"posts":[{"title":"MSSQL 练习题","text":"最近因为学校的原因，不得不学习 MS SQL 相关内容遂记录一些练习题 首先我们 1234DROP DATABASE IF EXISTS Learn;CREATE DATABASE Learn;USE Learn; Check创建一个 Student 表，有 ID, Name, Semester, City 字段。写一个 SQL，只允许插入第三学期的学生。这意味着用户不能插入第一、第二或第四学期的学生。 Create one Student table where is ID, Name, Semester, City colums.Find the solution that we can insert just the 3rd semester students.This mean that the user connot inser Student who are in 1, 2, or 4th semester. 12345678DROP TABLE IF EXISTS Student;CREATE TABLE Student ( ID INT PRIMARY KEY IDENTITY(1, 1), Semester TINYINT CHECK(Semester = 3) NOT NULL, NAME TEXT NOT NULL, City TEXT NOT NULL,); 去重创建一个方法，对同一 record 进行过滤，并只返回一次。例如，如果我们有 3 个价格为 450 的比萨饼，如果我们 Select，那么结果将是只有 1 个比萨，而不是 3 个比萨。 Create one method, what filtering the same record and give back just once.For example, if we have 3 pizza with 450 price, if we take a Select,then results will be just 1 pizza, not 3 pizza. 1234567891011121314151617181920DROP TABLE IF EXISTS Food;CREATE TABLE Food ( ID INT PRIMARY KEY IDENTITY(1, 1), Name VARCHAR(50) NOT NULL,, Price DECIMAL CHECK(Price &gt;= 0) NOT NULL,,);INSERT INTO Food Values ('Pizza', 450), ('Pizza', 450), ('Pizza', 450);-- Type 1SELECT MIN(Id), Min(Name), Min(Price) FROM Food GROUP BY Name;-- Type 2SELECT DISTINCT Name, Price FROM Food; 函数创建一个阻止 18 岁以下用户的 function。 Create one function what block the user who are younger as 18 years old. 1234567DROP TABLE IF EXISTS TUser;CREATE TABLE TUser ( ID INT PRIMARY KEY IDENTITY(1, 1), Name VARCHAR(50) UNIQUE NOT NULL, Age TINYINT CHECK(Age &gt;= 0),); 123456789101112131415CREATE OR ALTER FUNCTION IsAdult(@Name VARCHAR(50))RETURNS BITASBEGIN IF EXISTS( SELECT * FROM TUser WHERE Name = @Name And Age &gt;= 18 ) RETURN 1 RETURN 0END 12345INSERT INTO TUser Values('Some', 18)DECLARE @ret BITEXEC @ret = IsAdult 'Some'SELECT @ret 层次化索引 Create one hierarchy index. 12345678910DROP TABLE IF EXISTS HIndex;CREATE TABLE HIndex ( IdPath HIERARCHYID PRIMARY KEY, Sth TEXT)INSERT INTO HIndex VALUES ('/1/', 'Something'), ('/1/1/', 'Somebody') Trigger创建一个触发器，如果产品数量在 10 个以下，则更新价格（+20%）。 Create one trigger what is update the price(+20%)if the products quantity is under 10 pirces. 123456789101112DROP TABLE IF EXISTS Product;CREATE TABLE Product( Id INT PRIMARY KEY IDENTITY, Name VARCHAR(50), Price MONEY, Quantity INT CHECK(Quantity &gt;= 0));INSERT INTO Product VALUES ('Pizza', 1000, 15), ('Bun', 100, 12); 1234567CREATE OR ALTER TRIGGER IncreasePriceOn Product FOR UPDATE ASBEGIN UPDATE Product SET Price = Price * 1.2 WHERE Quantity &lt; 10END; 12UPDATE ProductSET Quantity = 8; 复合主键不是很能理解他到底在说什么，但是答案是复合主键相关 How can we kill the nested loops operator?How can we kill the double I/O problems? 1234567DROP TABLE IF EXISTS Composite;CREATE TABLE Composite( Id INT NOT NULL, Comp INT NOT NULL, CONSTRAINT PK_Composite_Id_Comp PRIMARY KEY (Id, Comp)); 脏读 Create one select what is dirty read. 1234567891011DROP TABLE IF EXISTS Bank;CREATE TABLE Bank( Id INT PRIMARY KEY IDENTITY(1, 1), AccountNum VARCHAR(50), Name VARCHAR(50), Balance MONEY)INSERT INTO Bank VALUES ('SomeAccountNum', 'SomeName', '80'); 123456789BEGIN TRAN; UPDATE Bank SET Balance = Balance - 45 WHERE AccountNum = 'SomeAccountNum'; WAITFOR DELAY '00:00:10';ROLLBACK TRAN;SELECT * FROM BankWHERE AccountNum = 'SomeAccountNum'; 123456-- Dirty ReadSET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;BEGIN TRAN; SELECT * FROM Bank WHERE AccountNum = 'SomeAccountNum';COMMIT TRAN; 或者 12Select Count(*)FROM Bank WITH (NOLOCK) While两个产品。咖啡是 245，披萨是 475。(硬币：20，10，5）如果我们想买这些产品，请计算需要多少硬币。 You have 2 products. The coffee is 245, the pizza is 475. (Coins: 20, 10, 5)Please count how many coins need it if we would like to buy this products. 12345678910111213141516171819202122232425262728293031CREATE OR ALTER PROCEDURE CountCoins(@Price INT)ASBEGINDECLARE @C20 INT, @C10 INT, @C5 INT;SET @C20 = 0;SET @C10 = 0;SET @C5 = 0; WHILE @Price &gt;= 20 SET @Price = @Price - 20 SET @C20 = @C20 + 1 WHILE @Price &gt;= 10 SET @Price = @Price - 10 SET @C10 = @C10 + 1 WHILE @Price &gt;= 5 SET @Price = @Price - 5 SET @C5 = @C5 + 1 PRINT 'It can be paid with ' + TRIM(CAST(@C20 as VARCHAR(50))) + ' 20Coin, ' + TRIM(CAST(@C10 as VARCHAR(50))) + ' 10Coin, ' + TRIM(CAST(@C10 as VARCHAR(50))) + ' 5Coin.'END 聚集索引 Create two cluster index on your table, on the same table but different columns. 123456789DROP TABLE IF EXISTS TTest;CREATE TABLE TTest( Col1 INT NOT NULL, Col2 INT NOT NULL, Col3 VARCHAR(50));CREATE CLUSTERED INDEX IX_TTest_Col1 ON TTest (Col1); XML导出表到 XML。 Create XML code from your table. 12345678910111213DROP TABLE IF EXISTS TXML;CREATE TABLE TXML( Col1 INT PRIMARY KEY IDENTITY, Col2 VARCHAR(10), Col3 VARCHAR(50));INSERT INTO TXML VALUES ('Some', 'Thing'), ('Body', 'Any');SELECT * FROM TXML FOR XML AUTO; 事务用事务填充表。 Create one table with 900 records. 123456789101112131415161718DROP TABLE IF EXISTS Fill;CREATE TABLE Fill( Id INT PRIMARY KEY IDENTITY, Increse INT);BEGIN TRANDECLARE @index INTSET @index = 0WHILE @index &lt; 900BEGIN INSERT INTO Fill VALUES (@index) SET @index = @index + 1ENDCOMMIT TRAN 用户账户创建新用户并授予其权限。 Create a new account, which log in via system administrator with data reader persmission. 123CREATE LOGIN [DGYY] WITH PASSWORD=N'123', DEFAULT_DATABASE=[master]ALTER SERVER ROLE [sysadmin] ADD MEMBER [DGYY]ALTER ROLE [db_datareader] ADD MEMBER [DGYY] UNION合并多个 SELECT 语句的结果集 How can we use the data of set? 123SELECT NULL FROM SomeTableUNIONSELECT NULL FROM OtherTable; CASE WHEN用 CASE 写一个判断 Create one new table for cars(Id, type, color). After this,select one car from the table and compare this car color onthe next logical statement the car is Black (True, False) Or White. 1234567891011121314151617181920DROP TABLE IF EXISTS Car;CREATE TABLE Car( Id INT PRIMARY KEY IDENTITY, Type VARCHAR(50), Color VARCHAR(50));INSERT INTO Car VALUES ('Audi', 'Black'), ('BMW', 'Red'), ('Suzuki', 'Grey'), ('Aston', 'White');SELECT TOP(1) CASE WHEN Car.Color = 'White' Then 'White' WHEN Car.Color = 'Black' THEN 'True' ELSE 'False' ENDFROM Car OFFSET How can we use the data offset? 123456789101112131415161718192021DROP TABLE IF EXISTS Offset;CREATE TABLE Offset( Id INT PRIMARY KEY IDENTITY, Sth INT);DECLARE @index INTSET @index = 0WHILE @index &lt; 5BEGIN INSERT INTO Offset VALUES(RAND() * 10) SET @index = @index + 1ENDSELECT *FROM OffsetORDER BY IdOFFSET 2 ROWSFETCH NEXT 3 ROWS ONLY; BETWEEN12ALTER TABLE TableNameADD CONSTRAINT CK_Between CHECK (LEN(ColomnName) BETWEEN 1 AND 10) THROW Create one trigger what give for us an error messageif we cannot insert data in the table. 123456789CREATE TRIGGER ErrorTrigger-- 类似 BEFOREON TTest INSTEAD OF INSERT ASBEGIN IF 1 = 1 THROW 60000, 'Error Message!', 1 ;END 表变量12345678910111213DECLARE @TTest TABLE( Col1 INT NOT NULL, Col2 INT NOT NULL, Col3 VARCHAR(50));INSERT INTO @TTest VALUES (1, 2, 'Some'), (3, 4, 'Thing');SELECT * FROM @TTest;DROP TABLE @TTest; 临时表12345678910111213CREATE TABLE #TTest( Col1 INT NOT NULL, Col2 INT NOT NULL, Col3 VARCHAR(50));INSERT INTO #TTest VALUES (5, 6, 'Body'), (7, 8, 'Any');SELECT * FROM #TTest;DROP TABLE #TTest;","link":"/Database/MSSQL/MSSQL-%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"title":"OpenStack 学习日记 | 第一天","text":"由于本人最近需要从事 OpenStack 相关工作，所以急需对 OpenStack 进行学习本系列日记仅作为本人的学习记录学习材料为 《每天 5 分钟玩转 OpenStack》 学习前需要知道的OpenStack 涉及的范围广计算，储存，网络，虚拟化，可用性，安全性，灾备等一些列关于 IT 基础设施的范围 OpenStack 都有涵盖 OpenStack 是一个平台它的各个组件都采用了 Driver 架构，支持各种的具体实现。比如 OpenStack 储存服务 Cinder 只定义抽象 API，而具体实现交给具体的 Driver比如基于 LVM 的 iSCSI， EMC，或者开源的 Ceph，GlusterFS 等等 这里我们可以类比到 Entity Framework，它只定义了上层的 API而具体的数据库操作交给了你指定的 Driver，如 Npgsql OpenStack 是一个分布式系统这也是学习它的比较大的阻碍，因为它原生就是分布式的，各个组件拆的很散不过我们学习的时候都使用 All-in-one 部署模式 我们要学习的内容 预备知识 虚拟化 云计算 核心组件 架构 认证 Keystone 镜像 Glance 计算 Nova 储存 Cinder 网络 Neutron 写在最前面 – 每天 5 分钟玩转 OpenStack（1） 虚拟化虚拟化是云计算的基础虚拟机(Guest)共享物理机(Host)的资源，比如 CPU，内存，硬盘，网络，磁盘等 这主要通过 Hypervisor 来实现，比如 KVM，Xen，VMWare 等等 1 类虚拟化Hypervisor 是一个操作系统，直接安装在物理机上最典型的就是 Windows 上的 Hyper-V其他的还有 Xen 和 ESXi 2 类虚拟化Hypervisor 作为操作系统中的一个程序或者模块运行最典型的有 KVM 和 VMware Workstation 对比理论上讲，1 类虚拟化性能比 2 类的要好而 2 类虚拟化会更灵活，比如支持嵌套虚拟化 KVM对我来说 KVM 已经是一个听过无数次的词了OpenStack 对 KVM 的支持最好，全称叫 Kernel-based Virtual Machine也就是说它基于 Linux 的内核实现，它有一个模块叫 kvm.ko，只用于管理虚拟 CPU 和内存 那我们就要问了，那 IO 虚拟化呢，这个交给 Linux 内核与 QEMU 实现 Libvirt这是 KVM 的管理工具，包含三个模块后台 daemon，api 库，和 命令行工具 virshvirsh 和 virt-manager 是一定要会用的 虚拟化 – 每天 5 分钟玩转 OpenStack（2） 安装我们使用 Ubuntu，安装 KVM 需要的包 1sudo apt install qemu-kvm qemu-system libvirt-bin virt-manager bridge-util qemu-kvm 和 qemu-system 是 KVM 和 QEMU 的核心包，提供 CPU、内存和 IO 虚拟化功能 libvirt-bin 就是 libvirt，用于管理 KVM 等 Hypervisor virt-manager 是 KVM 图形化管理工具 bridge-utils 和 vlan，主要是网络虚拟化需要，KVM 网络虚拟化的实现是基于 linux-bridge 和 VLAN 准备 KVM 实验环境 – 每天 5 分钟玩转 OpenStack（3） 对于我自己来说，使用 KVM 等本来就是轻车熟路了，所以我跳过这一部分 启动第一个 KVM 虚机 – 每天 5 分钟玩转 OpenStack（4） 远程管理 KVM 虚机 – 每天 5 分钟玩转 OpenStack（5） CPU 虚拟化KVM 虚拟机 在宿主机中其实是一个 QEMU-KVM 进程，与其他进程一同被调度虚拟中的每一个 vCPU 就对应 QEMU-KVM 进程中的一个 线程 这就表明 vCPU 的总数可以超过物理机的 CPU 总数，这叫 CPU OverCommit 超配这个特性让虚拟机能充分利用宿主机的 CPU 资源，但是这也导致了 VPS 中令人诟病的超售行为 内存虚拟化这一段算是我看的比较迷糊的一段不过说到底也不需要了解多少，只需要知道它并不是像一个普通程序那样分配内存即可中间存在大量的内存地址转换，各个厂家也为了转换效率做了很多特殊的优化Guest Virtual Address -&gt; Guest Physical Address -&gt;Host Virtual Address -&gt; Host Physical Address 内存也是可以超配的，所以超售机一大堆 CPU 和内存虚拟化原理 – 每天 5 分钟玩转 OpenStack（6） 储存虚拟化目录类型文件目录类型是最常用的KVM 将宿主机目录 /var/lib/libvirt/images/ 作为默认的 Storage Pool 这个目录下面的每一个文件就是一个 Volume说白了就是用文件来当磁盘，我们最常用的方式存储方便、移植性好、可复制、可远程访问KVM 支持 raw, qcow2, qed, vmdk, vdl 格式的磁盘文件 KVM 存储虚拟化 – 每天 5 分钟玩转 OpenStack（7） LVM 类型这个用的不多，也就是把实际的磁盘划出来给虚拟机用，跳过 LVM 类型的 Storage Pool – 每天 5 分钟玩转 OpenStack（8） 网络虚拟化这章是虚拟化中最复杂，最重要的部分 Linux Bridge其实就是网桥，用来做 TCP/IP 二层协议交换的模块对于我来说这玩意接触的也比较多 KVM 网络虚拟化基础 – 每天 5 分钟玩转 OpenStack（9） 这里记录几个重点 修改 /etc/network/interfaces 以配置网桥 使用 ifconfig 查看 IP 配置 brctl show 查看当前 Linux Bridge 的配置 动手实践虚拟网络 – 每天 5 分钟玩转 OpenStack（10） virbr0virbr0 是 KVM 默认创建的一个 Bridge，其作用是为连接其上的虚机网卡提供 NAT 访问外网的功能。virbr0 默认分配了一个 IP 192.168.122.1，并为连接其上的其他虚拟网卡提供 DHCP 服务。这没啥好难的就是一个 NAT 网关而已 理解 Virbr0 – 每天 5 分钟玩转 OpenStack（11） VLAN也就是虚拟局域网，隔离用，二层交换机，不需要想的太复杂在一张网卡下面划分多个空间而已 Linux 如何实现 VLAN – 每天 5 分钟玩转 OpenStack（12） 具体如何配置就等到要用的时候现查不过还是修改 /etc/network/interfaces 动手实践 Linux VLAN – 每天 5 分钟玩转 OpenStack（13） 云计算 IaaS（Infrastructure as a Service）提供的服务是虚拟机典型的有 AWS，OpenStack 等 PaaS（Platform as a Service）提供的服务是应用的运行环境比如 Github Pages SaaS（Software as a Service）提供的是应用服务对象通常是最终用户，就像 Gmail OpenStack is a cloud operating system that controls large pools of compute, storage,and networking resources throughout a datacenter, all managed through a dashboard that gives administrators control while empowering their users to provision resources through a web interface. OpenStack 对数据中心的计算、存储和网络资源进行统一管理 云计算与 OpenStack – 每天 5 分钟玩转 OpenStack（14） OpenStack写日记的时候最新版本是 Yoga，下一个版本是 Zed 首先列出模块列表 名称 用途 中文 cyborg Accelerator Life Cycle Management 用于管理硬件和软件加速资源（如 GPU）的框架 freezer Backup, Restore, and Disaster Recovery service 备份、恢复和灾难恢复服务 ironic Bare Metal service 裸机服务 cinder Block Storage service 存储服务 ceilometer Data collection service 数据收集服务 kuryr Bridge between container framework and OpenStack abstractions 容器框架和 OpenStack 抽象之间的桥梁 keystone Identity Service 管理身份验证、服务规则和服务令牌功能 senlin Clustering service 集群服务 storlets Compute inside Object Storage service 对象存储服务中的计算 nova Compute service 计算服务，管理 VM 的生命周期 neutron network connectivity as a service 网络连接服务，负责创建和管理 L2、L3 网络， 为 VM 提供虚拟网络和物理网络连接 zun Containers service 容器服务 horizon Dashboard 仪表盘 designate DNS service DNS 服务 ec2-api EC2 API compatibility layer EC2 API 兼容层 glance Image service 启动镜像服务 watcher Infrastructure Optimization service 基础设施优化服务 masakari Instances High Availability Service 实例高可用性服务 barbican Key Manager service 密钥管理器服务 octavia Load-balancer service 负载均衡器服务 neutron Networking service 网络服务 tacker NFV Orchestration service NFV 管理器，用于监视、配置 NFV 和管理 NFV 全生命周期 swift Object Storage service 对象存储服务 heat Orchestration service REST 服务，能够基于一个声明式的模板，通过装配引擎装配组合若干个云应用 placement Placement service REST API 堆栈和数据模型，用于跟踪资源提供程序的清单和使用情况，以及不同的资源类别 cloudkitty Rating service 计费服务 vitrage RCA (Root Cause Analysis) service 用于组织、分析和扩展 OpenStack 的告警和事件 blazar Resource reservation service 资源保留服务 manila Shared File Systems service 共享文件系统服务 aodh Telemetry Alarming services 遥测报警服务 ceilometer Telemetry Data Collection service 遥测数据采集服务 https://www.openstack.org/software/project-navigator/这么一大堆模块一时半会肯定是学不完的，我们挑重点学习搞清楚 OpenStack 是图和对计算，网络，储存资源进行管理的 核心组件 Nova 管理计算资源，是核心服务。 Neutron 管理网络资源，是核心服务。 Glance 为 VM 提供 OS 镜像，属于存储范畴，是核心服务。 Cinder 提供块存储，VM 怎么也得需要数据盘吧，是核心服务。 Swift 提供对象存储，不是必须的，是可选服务。 Keystone 认证服务，没它 OpenStack 转不起来，是核心服务。 Ceilometer 监控服务，不是必须的，可选服务。 Horizon 大家都需要一个操作界面吧。 OpenStack 本身是一个分布式系统，不但各个服务可以分布部署，服务中的组件也可以分布部署这也使得 OpenStack 比一般系统复杂，学习难度也更大 OpenStack 架构 – 每天 5 分钟玩转 OpenStack（15） 搭建 Dev 环境我一般使用 MicroStack 一键解决 搭建 OpenStack 实验环境 – 每天 5 分钟玩转 OpenStack（16） 部署 DevStack – 每天 5 分钟玩转 OpenStack（17） Keystone对于天天跟 OAuth 打交道的我这部分其实可以跳过 Authentication 解决的是“你是谁？”的问题 Authorization 解决的是“你能干什么？”的问题 Keystone 负责管理和维护每个 Service 的 Endpoint Service 通过 Endpoint 暴露自己的 API 理解 Keystone 核心概念 – 每天 5 分钟玩转 OpenStack（18） 通过例子学习 Keystone – 每天 5 分钟玩转 OpenStack（19） Glance这玩意还储存快照 Glance 支持多种 backend，包括 A directory on a local file system（这是默认配置） GridFS Ceph RBD Amazon S3 Sheepdog OpenStack Block Storage (Cinder) OpenStack Object Storage (Swift) VMware ESX 没啥好讲的，需要用到时候现查，而且大部分操作都可以通过 GUI 完成 理解 Glance – 每天 5 分钟玩转 OpenStack（20） 创建 Image – 每天 5 分钟玩转 OpenStack（21） 如何使用 OpenStack CLI – 每天 5 分钟玩转 OpenStack（22） NovaCompute Service Nova 是 OpenStack 最核心的服务，负责维护和管理云环境的计算资源。OpenStack 作为 IaaS 的云操作系统，虚拟机生命周期管理也就是通过 Nova 来实现的。 nova-api接收和响应客户的 API 调用， 还支持 Amazon EC2 API nova-scheduler虚机调度服务，负责决定在哪个计算节点上运行虚机 nova-compute管理虚机的核心服务，通过调用 Hypervisor API 实现虚机生命周期管理 nova-conductornova-compute 经常需要更新数据库，比如更新虚机的状态出于安全性和伸缩性的考虑，nova-compute 并不会直接访问数据库 nova-console用户可以通过多种方式访问虚机的控制台：nova-novncproxy，基于 Web 浏览器的 VNC 访问nova-spicehtml5proxy，基于 HTML5 浏览器的 SPICE 访问nova-xvpnvncproxy，基于 Java 客户端的 VNC 访问 nova-consoleauth负责对访问虚机控制台请求提供 Token 认证 nova-cert提供 x509 证书支持 总之我越看越觉得 OpenStack 就是在 Hypervisor 上套了一层又一层而且我个人对 Python 写的大型项目是完全没有好感 理解 Nova 架构 – 每天 5 分钟玩转 OpenStack（23） 部署方案哪里有那么复杂，专门负责装 VPS 的 Hypervisor 就装 nova-compute然后其他服务放别处就行了 OpenStack 默认是用 RabbitMQ 作为 Message Queue，好评 Nova 组件如何协同工作 – 每天 5 分钟玩转 OpenStack（24） 设计思路说那么多到底还是解耦，疯狂解耦然后各种抽象 API，疯狂增加项目体积再加入各种调度，最离谱的是居然默认用 MySQL当然对大型集群这都不算什么 OpenStack 通用设计思路 – 每天 5 分钟玩转 OpenStack（25） 组件 Nova 组件详解 – 每天 5 分钟玩转 OpenStack（26） flavor 就是 plan，选 VPS 配置 Filter scheduler 是 nova-scheduler 默认的调度器 通过过滤器（filter）选择满足条件的计算节点 通过权重计算（weighting）选择在最优（权重值最大）的计算节点上创建 Instance RetryFilter 的作用是刷掉之前已经调度过的节点 为提高容灾性和提供隔离服务，可以将计算节点划分到不同的 Availability Zone 中 RamFilter 将不能满足 flavor 内存需求的计算节点过滤掉 DiskFilter 将不能满足 flavor 磁盘需求的计算节点过滤掉 CoreFilter 将不能满足 flavor vCPU 需求的计算节点过滤掉 ComputeFilter 保证只有 nova-compute 服务正常工作的计算节点才能够被 nova-scheduler 调度 ComputeCapabilitiesFilter 根据计算节点的特性来筛选可以从 Metadata 中筛选架构之类的 ImagePropertiesFilter 根据所选 image 的属性来筛选匹配的计算节点镜像也带 Metadata，可以限定比如只能运行在 kvm 上之类的 ServerGroupAntiAffinityFilter 可以尽量将 Instance 分散部署到不同的节点上 ServerGroupAffinityFilter 会尽量将 instance 部署到同一个计算节点上 nova-scheduler 的默认实现是根据计算节点空闲的内存量计算权重值：空闲内存越多，权重越大，instance 将被部署到当前空闲内存最多的计算节点上 看 Nova-Scheduler 如何选择计算节点 – 每天 5 分钟玩转 OpenStack（27） 每隔一段时间，nova-compute 就会报告当前计算节点的资源使用情况和自己的状态 这不就是微服务么，eureka 既视感 instance 的 launch、shutdown、reboot、suspend、resume、terminate、resize、migration、snapshot Nova-Compute 部署 Instance 详解 – 每天 5 分钟玩转 OpenStack（28） 生命周期OpenStack 的日志格式都是统一的，如下&lt;时间戳&gt;&lt;日志等级&gt;&lt;代码模块&gt;&lt;Request ID&gt;&lt;日志内容&gt;&lt;源代码位置&gt; 教你看懂 OpenStack 日志 – 每天 5 分钟玩转 OpenStack（29）Launch 和 Shut Off 操作详解 – 每天 5 分钟玩转 OpenStack（30）Start Instance 操作详解 – 每天 5 分钟玩转 OpenStack（31）Nova reboot 和 lock 操作 – 每天 5 分钟玩转 OpenStack（32）Terminate Instance 操作详解 – 每天 5 分钟玩转 OpenStack（33）Pause/Resume Instance 操作详解 – 每天 5 分钟玩转 OpenStack（34）Nova Suspend/Rescue 操作详解 – 每天 5 分钟玩转 OpenStack（35）Snapshot Instance 操作详解 – 每天 5 分钟玩转 OpenStack（36）Rebuild Instance 操作详解 – 每天 5 分钟玩转 OpenStack（37）Shelve Instance 操作详解 – 每天 5 分钟玩转 OpenStack（38）Unshelve Instance 操作详解 – 每天 5 分钟玩转 OpenStack（39）Migrate Instance 操作详解 – 每天 5 分钟玩转 OpenStack（40）Resize Instance 操作详解 – 每天 5 分钟玩转 OpenStack（41）Live Migrate 操作 – 每天 5 分钟玩转 OpenStack（42）计算节点宕机了怎么办？Evacuate - 每天 5 分钟玩转 OpenStack（43）1 张图秒懂 Nova 16 种操作 – 每天 5 分钟玩转 OpenStack（44） 上面这一大堆操作都是属于遇到了现查来得更快，而且很多都浅显易懂，盲猜也能用个大概","link":"/Diary/OpenStack-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E7%AC%AC%E4%B8%80%E5%A4%A9/"},{"title":"OpenStack 学习日记 第二天","text":"Cinder操作系统挂载储存空间的方法有： Block Storage 块储存：通过本地协议（SCSI、SAS）等挂载裸磁盘，每个磁盘叫做 Volume 卷 文件系统储存：通过网络协议（NFS、CIFS）等挂载远程文件系统，分布式就是这种 Block Storage Service 提供对 volume 从创建到删除整个生命周期的管理从 instance 的角度看，挂载的每一个 Volume 都是一块硬盘 Cinder： 提供 REST API 使用户能够查询和管理 volume、volume snapshot 以及 volume type 提供 scheduler 调度 volume 创建请求，合理优化存储资源的分配 通过 driver 架构支持多种 back-end（后端）存储方式，包括 LVM，NFS，Ceph 和其他诸如 EMC、IBM 等商业存储产品和方案 组件 cinder-api接收 API 请求，调用 cinder-volume 执行操作 cinder-volume管理 volume 的服务，与 volume provider 协调工作，管理 volume 的生命周期运行 cinder-volume 服务的节点被称作为存储节点，LVM 是默认的 provider cinder-schedulerscheduler 通过调度算法选择最合适的存储节点创建 volume volume provider数据的存储设备，为 volume 提供物理存储空间支持多种 volume provider，每种 provider 通过自己的 driver 与 cinder-volume 协调工作 Message QueueCinder 各个子服务通过消息队列实现进程间通信和相互协作因为有了消息队列，子服务之间实现了解耦，这种松散的结构也是分布式系统的重要特征 Database数据库是安装在控制节点上的 其他 理解 Cinder 架构 – 每天 5 分钟玩转 OpenStack（45） 主要还是在讲传统分布式设计 掌握 Cinder 的设计思想 – 每天 5 分钟玩转 OpenStack（46） cinder-api 是整个 Cinder 组件的门户，所有 cinder 的请求都首先由 nova-api 处理 cinder-volume 在存储节点上运行，OpenStack 对 Volume 的操作，最后都是交给 cinder-volume 来完成的cinder-volume 自身并不管理真正的存储设备，存储设备是由 volume provider 管理的。cinder-volume 与 volume provider 一起实现 volume 生命周期的管理 Cinder 组件详解 – 每天 5 分钟玩转 OpenStack（47） 调度器Filter scheduler 是 cinder-scheduler 默认的调度器 AvailabilityZoneFilter为提高容灾性和提供隔离服务，可以将存储节点和计算节点划分到不同的 Availability Zone 中 CapacityFilter将存储空间不能满足 Volume 创建需求的存储节点过滤掉 CapabilitiesFilter不同的 Volume Provider 有自己的特性（Capabilities），比如是否支持 thin provision 等Cinder 允许用户创建 Volume 时通过 Volume Type 指定需要的 Capabilities Weighter通过 scheduler_default_weighers 指定计算权重的 weigher，默认为 CapacityWeigherCapacityWeigher 基于存储节点的空闲容量计算权重值，空闲容量最大的胜出 掌握 cinder-scheduler 调度逻辑 – 每天 5 分钟玩转 OpenStack（48） 操作 准备 LVM Volume Provider – 每天 5 分钟玩转 OpenStack（49） Create Volume 操作（Part I） – 每天 5 分钟玩转 OpenStack（50） Create Volume 操作（Part II） – 每天 5 分钟玩转 OpenStack（51） Create Volume 操作（Part III） – 每天 5 分钟玩转 OpenStack（52） Attach Volume 操作（Part I） – 每天 5 分钟玩转 OpenStack（53） Attach Volume 操作（Part II） – 每天 5 分钟玩转 OpenStack（54） Detach Volume 操作 – 每天 5 分钟玩转 OpenStack（55） Extend Volume 操作 – 每天 5 分钟玩转 OpenStack（56） Delete Volume 操作 – 每天 5 分钟玩转 OpenStack（57） Snapshot Volume 操作 – 每天 5 分钟玩转 OpenStack（58） Backup Volume 操作 – 每天 5 分钟玩转 OpenStack（59） Restore Volume 操作 – 每天 5 分钟玩转 OpenStack（60） Boot From Volume – 每天 5 分钟玩转 OpenStack（61） NFS NFS Volume Provider（Part I） – 每天 5 分钟玩转 OpenStack（62） NFS Volume Provider（Part II） – 每天 5 分钟玩转 OpenStack（63） NFS Volume Provider（Part III） – 每天 5 分钟玩转 OpenStack（64） Neutron“软件定义网络（software-defined networking, SDN）”所具有的灵活性和自动化优势 Neutron 的设计目标是实现“网络即服务（Networking as a Service）”在设计上遵循了基于 SDN 实现网络虚拟化的原则，在实现上充分利用了 Linux 系统上的各种网络相关的技术 Neutron 为整个 OpenStack 环境提供网络支持，包括二层交换，三层路由，负载均衡，防火墙和 VPN 等 二层交换 SwitchingNova 的 Instance 是通过虚拟交换机连接到虚拟二层网络的Neutron 支持多种虚拟交换机，包括 Linux 原生的 Linux Bridge 和 Open vSwitchNeutron 除了可以创建传统的 VLAN 网络，还可以创建基于隧道技术的 Overlay 网络，比如 VxLAN 和 GRE 三层路由 RoutingNeutron 支持多种路由，包括 Linux 原生的 Linux Bridge 和 Open vSwitchInstance 可以配置不同网段的 IP，Neutron 的 router（虚拟路由器）实现 instance 跨网段通信router 通过 IP forwarding，iptables 等技术来实现路由和 NAT 负载均衡 Load BalancingLoad-Balancing-as-a-Service（LBaaS）支持多种负载均衡产品和方案，不同的实现以 Plugin 的形式集成到 Neutron，目前默认的 Plugin 是 HAProxy。 防火墙 FirewallingSecurity Group：通过 iptables 限制进出 instance 的网络包FWaaS：限制进出虚拟路由器的网络包，也是通过 iptables 实现 Neutron 功能概述 – 每天 5 分钟玩转 OpenStack（65） 概念Neutron 支持多种类型的 network，包括 local, flat, VLAN, VxLAN 和 GRE。 locallocal 网络与其他网络和节点隔离。local 网络中的 instance 只能与位于同一节点上同一网络的 instance 通信，local 网络主要用于单机测试 flatflat 网络是无 vlan tagging 的网络。flat 网络中的 instance 能与位于同一网络的 instance 通信，并且可以跨多个节点。 vlanvlan 网络是具有 802.1q tagging 的网络。vlan 是一个二层的广播域，同一 vlan 中的 instance 可以通信，不同 vlan 只能通过 router 通信。vlan 网络可以跨节点，是应用最广泛的网络类型 vxlanvxlan 是基于隧道技术的 overlay 网络。vxlan 网络通过唯一的 segmentation ID（也叫 VNI）与其他 vxlan 网络区分vxlan 中数据包会通过 VNI 封装成 UDP 包进行传输因为二层的包通过封装在三层传输，能够克服 vlan 和物理网络基础设施的限制 gregre 是与 vxlan 类似的一种 overlay 网络。主要区别在于使用 IP 包而非 UDP 进行封装 Neutron 网络基本概念 – 每天 5 分钟玩转 OpenStack（66） 组件 Neutron Server对外提供 OpenStack 网络 API，接收请求，并调用 Plugin 处理请求。 Plugin处理 Neutron Server 发来的请求，维护 OpenStack 逻辑网络的状态， 并调用 Agent 处理请求。 Agent处理 Plugin 的请求，负责在 network provider 上真正实现各种网络功能。 network provider提供网络服务的虚拟或物理网络设备，例如 Linux Bridge，Open vSwitch 或者其他支持 Neutron 的物理交换机。 QueueNeutron Server，Plugin 和 Agent 之间通过 Messaging Queue 通信和调用。 Database存放 OpenStack 的网络状态信息，包括 Network, Subnet, Port, Router 等。 Neutron 架构 – 每天 5 分钟玩转 OpenStack（67） 部署 方案 1：控制节点 + 计算节点控制节点：部署的服务包括：neutron server, core plugin 的 agent 和 service plugin 的 agent计算节点：部署 core plugin 的 agent，负责提供二层网络功能。 方案 2：控制节点 + 网络节点 + 计算节点控制节点：部署 neutron server 服务网络节点：部署的服务包括：core plugin 的 agent 和 service plugin 的 agent计算节点：部署 core plugin 的 agent，负责提供二层网络功能。 Neutron 物理部署方案 – 每天 5 分钟玩转 OpenStack（68） 结构 Core API对外提供管理 network, subnet 和 port 的 RESTful API。 Extension API对外提供管理 router, load balance, firewall 等资源 的 RESTful API。 Commnon Service认证和校验 API 请求。 Neutron CoreNeutron server 的核心处理程序，通过调用相应的 Plugin 处理请求。 Core Plugin API定义了 Core Plgin 的抽象功能集合，Neutron Core 通过该 API 调用相应的 Core Plgin。 Extension Plugin API定义了 Service Plgin 的抽象功能集合，Neutron Core 通过该 API 调用相应的 Service Plgin。 Core Plugin实现了 Core Plugin API，在数据库中维护 network, subnet 和 port 的状态，并负责调用相应的 agent 在 network provider 上执行相关操作，比如创建 network。 Service Plugin实现了 Extension Plugin API，在数据库中维护 router, load balance, security group 等资源的状态，并负责调用相应的 agent 在 network provider 上执行相关操作，比如创建 router。 理解 Neutron Server 分层模型 – 每天 5 分钟玩转 OpenStack（69） Neutron 如何支持多种 network provider – 每天 5 分钟玩转 OpenStack（70） ML2Moduler Layer 2（ML2）是 Neutron 在 Havana 版本实现的一个新的 core plugin，用于替代原有的 linux bridge plugin 和 open vswitch plugin 传统 core plugin 存在两个突出的问题: 无法同时使用多种 network provider 开发新的 core plugin 工作量大 详解 ML2 Core Plugin（I） – 每天 5 分钟玩转 OpenStack（71） ML2 对二层网络进行抽象和建模，引入了 type driver 和 mechanism driver这两类 driver 解耦了 Neutron 所支持的网络类型（type）与访问这些网络类型的机制（mechanism）其结果就是使得 ML2 具有非常好的弹性，易于扩展，能够灵活支持多种 type 和 mechanism。 Type DriverNeutron 支持的每一种网络类型都有一个对应的 ML2 type driver。type driver 负责维护网络类型的状态，执行验证，创建网络等。ML2 支持的网络类型包括 local, flat, vlan, vxlan 和 gre Mechanism DriverNeutron 支持的每一种网络机制都有一个对应的 ML2 mechanism driver mechanism driver 负责获取由 type driver 维护的网络状态，并确保在相应的网络设备（物理或虚拟）上正确实现这些状态 mechanism driver 有三种类型 Agent-based包括 linux bridge, open vswitch 等 Controller-based包括 OpenDaylight, VMWare NSX 等 基于物理交换机包括 Cisco Nexus, Arista, Mellanox 等 详解 ML2 Core Plugin（II） – 每天 5 分钟玩转 OpenStack（72） Service PluginCore Plugin/Agent 负责管理核心实体：net, subnet 和 port而对于更高级的网络服务，则由 Service Plugin/Agent 管理Service Plugin 及其 Agent 提供更丰富的扩展功能，包括路由，load balance，firewall 等 DHCPdhcp agent 通过 dnsmasq 为 instance 提供 dhcp 服务 Routingl3 agent 可以为 project（租户）创建 router，提供 Neutron subnet 之间的路由服务路由功能默认通过 IPtables 实现 Firewalll3 agent 可以在 router 上配置防火墙策略，提供网络安全防护另一个与安全相关的功能是 Security Group，也是通过 IPtables 实现Firewall 安全策略位于 router，保护的是某个 project 的所有 networkSecurity Group 安全策略位于 instance，保护的是单个 instance Load BalanceNeutron 默认通过 HAProxy 为 project 中的多个 instance 提供 load balance 服务 Service Plugin / Agent – 每天 5 分钟玩转 OpenStack（73） 两张图总结 Neutron 架构 – 每天 5 分钟玩转 OpenStack（74） 为 Neutron 准备物理基础设施（I） – 每天 5 分钟玩转 OpenStack（75） 为 Neutron 准备物理基础设施（II） – 每天 5 分钟玩转 OpenStack（76）","link":"/Diary/OpenStack-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E5%A4%A9/"},{"title":"数据库概念入门","text":"所以说我们老师考这些的意义是什么呢 第一周Data -&gt; Database -&gt; Data Warehouse都什么年代了还在用数据仓库 Physical Data 是储存在实体介质上的数据Logical Data 是指数据的逻辑结构有 Add / Modify / Delete / Merging / Breaking 这什么玩意写的乱七八糟的 数据独立性物理独立性 程序与磁盘数据相互独立 程序不需要了解如何储存数据 数据如何储存由 DBMS 管理 物理储存改变，程序无需改变 逻辑独立性 程序与数据库的逻辑结构相互独立 数据逻辑结构改变，程序无需改变 数据独立性的重要性 数据质量 维护成本 安全性 结构化 Implementation (Layers of data) 减少重复 备份 物理层面容易修改，提高性能 合着真就不说人话 三级模式结构Physical Schema内模式（储存模式 / Internal），对应 物理级描述了数据在磁盘上的存储方式和物理结构 Conceptual Schema概念模式（逻辑模式），对应 概念级是对数据库中全部数据的逻辑结构和特征的总体描述是全局视图，由 Data Description Language 描述 External Schema外模式（子模式 / 用户模式），对应 用户级是用户所看到的数据库的数据视图是概念模式的一个子集，包换特定用户使用的那部分数据由 Data Manipulation Language 操作 关系模型突然发现老师的 PPT 内容都是网上抄的 概念 Attribute: Column Table: Relation Tuple: Row Degree: Count(Column) Cardinality: Count(Row) Relation key: 比如主键 Domain: 数据类型，约束等 Relation Schema: 表名 和 其中的列 Relation Instance: 表中的数据 完整性约束Domain Constraints123... ColName INT CHECK(ColName = 3) NOT NULL ...-- AndCREATE TRIGGER SomeName ... Key Constraints主键约束 Referential Integrity Constraints外键约束 优势 简单 结构独立 易用 能够查询 数据独立 可扩展 第二周","link":"/Database/%E6%A6%82%E5%BF%B5/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E5%BF%B5%E5%85%A5%E9%97%A8/"},{"title":"论使用WebCodecs对视频进行处理","text":"原文 更新于 2022-02-10，由 Aloento 翻译，具体以原文为准 现代的 Web 技术为视频提供了丰富的处理能力，例如 Media Stream API、Media Recording API、Media Source API, 和 WebRTC API 等，它们提供了丰富的工具以便 录制、传输、回放视频流。这些 API 虽然封装了很多高级功能以便方便的完成既定任务，但它们并不能让你处理视频流的内部细节，如 按帧处理 和 处理未 Muxed 的视频或音频块等。为了实现以上目的，你不得不使用一些类似 WebAssembly 的方式来把浏览器本就自带的编解码器（通常它们都有硬件加速）又一次的引入，这属实是对资源的浪费。 而 WebCodecs API 为程序员提供了使用浏览器自带编解码器的能力，来提高你的工作流效率，具体而言： 音视频的编解码 视频原始帧 图像解码 WebCodecs API 对于需要完全控制媒体内容处理方式的场景是非常有用的，例如视频编辑、视频会议、视频流等。 视频处理工作流帧 是视频处理的基本单位，因此，在 WebCodecs 中，大多数类要么使用帧，要么产生帧。编码器将帧转为编码的 chunks（块），而解码器则做相反的事情。VideoFrame 有一个可以接受 CanvasImageSource 的构造函数来于其他的 Web API 很好的配合。所以它可以被用于 drawImage() 和 texImage2D() 等函数中. 此外，它还可以从 canvases, bitmaps, video elements 和 其他 video frames 中创建。 WebCodecs API 可以用 Insertable Streams API，让 WebCodecs 和 media stream tracks 一起工作。 MediaStreamTrackProcessor 将媒体流分解为单个帧。 MediaStreamTrackGenerator 从帧序列中创建媒体流。 WebCodecs 和 Web Workers按照设计，WebCodecs API 以异步方式在主线程之外完成所有繁重的工作。但是由于帧和 Chunk 的回调经常在一秒之类被调用多次，这可能导致主线程的混乱，导致网页 UI 的缓慢和卡顿，所以我们最好将处理工作放到 Worker 线程中。 而 ReadableStream 有一个简便的方法可以将来自媒体流的帧全部自动转移到 Worker 线程中，例如，从摄像头的来的流通过 MediaStreamTrackProcessor 获取到 ReadableStream 后，就可以在 Worker 线程中被 VideoEncoder 处理。 我们甚至可以通过 HTMLCanvasElement.transferControlToOffscreen 在主线程之外进行渲染。但如果所有的高级接口都不满足你的需求，VideoFrame 本身也是可以在不同的 Worker 中转移的。 WebCodecs 的编解码Encoding / 编码 我们从 VideoFrame 开始，有三种方法来构建视频帧。 从图片源，如 canvas, image bitmap, 或 video element. 1234const canvas = document.createElement(&quot;canvas&quot;);// Draw something on the canvas...const frameFromCanvas = new VideoFrame(canvas, { timestamp: 0 }); 使用 MediaStreamTrackProcessor 从 MediaStreamTrack 中提取帧 1234567891011const stream = await navigator.mediaDevices.getUserMedia({…});const track = stream.getTracks()[0];const trackProcessor = new MediaStreamTrackProcessor(track);const reader = trackProcessor.readable.getReader();while (true) { const result = await reader.read(); if (result.done) break; const frameFromCamera = result.value;} 从 BufferSource 中的原始二进制像素中创建帧 123456789101112131415161718const pixelSize = 4;const init = { timestamp: 0, codedWidth: 320, codedHeight: 200, format: &quot;RGBA&quot;,};const data = new Uint8Array(init.codedWidth * init.codedHeight * pixelSize);for (let x = 0; x &lt; init.codedWidth; x++) { for (let y = 0; y &lt; init.codedHeight; y++) { const offset = (y * init.codedWidth + x) * pixelSize; data[offset] = 0x7f; // Red data[offset + 1] = 0xff; // Green data[offset + 2] = 0xd4; // Blue data[offset + 3] = 0x0ff; // Alpha }}const frame = new VideoFrame(data, init); 无论它们来自哪里，帧都可以用 VideoEncoder 编码为 EncodedVideoChunk。而 VideoEncoder 需要两个参数： 两个函数，用来处理已编码数据块和产生的错误，传入后不可变。 编码器配置，用来配置输出的视频流参数，可以使用 configure() 进行修改。 如果你指定的配置不被浏览器支持，configure() 方法将抛出 NotSupportedError。所以我们建议你调用异步静态方法 VideoEncoder.isConfigSupported() 来预先检查你的配置是否被用户的浏览器支持。 12345678910111213141516171819202122const init = { output: handleChunk, error: (e) =&gt; { console.log(e.message); },};const config = { codec: &quot;vp8&quot;, width: 640, height: 480, bitrate: 2_000_000, // 2 Mbps framerate: 30,};const { supported } = await VideoEncoder.isConfigSupported(config);if (supported) { const encoder = new VideoEncoder(init); encoder.configure(config);} else { // Try another config.} 编码器设置好以后，你就可以通过 encode() 方法来传入帧了。configure() 和 encode() 都不需要等待实际工作结束，它们会立刻返回。编码器允许多个帧同时排队等待编码，encodeQueueSize 表示队列中有多少帧还未处理。 如果你传入的参数或调用方法的顺序不正确，则方法可以立刻抛出错误，也可以通过你设置的 error() 回调函数报告错误。如果编码成功，就会调用你设置的 output() 回调函数。这里需要强调一点，如果你的帧不再使用，你应该调用 close() 来释放资源。 12345678910111213141516171819202122let frameCounter = 0;const track = stream.getVideoTracks()[0];const trackProcessor = new MediaStreamTrackProcessor(track);const reader = trackProcessor.readable.getReader();while (true) { const result = await reader.read(); if (result.done) break; const frame = result.value; if (encoder.encodeQueueSize &gt; 2) { // Too many frames in flight, encoder is overwhelmed // let's drop this frame. frame.close(); } else { frameCounter++; const keyframe = frameCounter % 150 == 0; encoder.encode(frame, { keyFrame }); frame.close(); }} 最后，我们编写一个处理从编码器中得到的 Chunks 的函数，来完成最终的编码。一般来说，这个函数会把 Chunk 发往服务器，或者将 Chunk Muxing 到一个容器中来生成一个视频文件。 1234567891011121314151617181920212223function handleChunk(chunk, metadata) { if (metadata.decoderConfig) { // Decoder needs to be configured (or reconfigured) with new parameters // when metadata has a new decoderConfig. // Usually it happens in the beginning or when the encoder has a new // codec specific binary configuration. (VideoDecoderConfig.description). fetch(&quot;/upload_extra_data&quot;, { method: &quot;POST&quot;, headers: { &quot;Content-Type&quot;: &quot;application/octet-stream&quot; }, body: metadata.decoderConfig.description, }); } // actual bytes of encoded data const chunkData = new Uint8Array(chunk.byteLength); chunk.copyTo(chunkData); fetch(`/upload_chunk?timestamp=${chunk.timestamp}&amp;type=${chunk.type}`, { method: &quot;POST&quot;, headers: { &quot;Content-Type&quot;: &quot;application/octet-stream&quot; }, body: chunkData, });} 如果你需要确保所有的编码请求都已经完成，你可以调用异步函数 flush()。 1await encoder.flush(); Decoding / 解码 设置 VideoDecoder 的方法与设置 VideoEncoder 的类似：在创建解码器的是否传入两个参数，并调用 configure() 修改解码器参数。解码器的参数会因编码器的不同而不同，比如一个 H.264 解码器可能需要一个 AVCC 格式的二进制 blob，除非流是以 Annex B 编码的。(encoderConfig.avc = { format: &quot;annexb&quot; }) 1234567891011121314151617181920const init = { output: handleFrame, error: (e) =&gt; { console.log(e.message); },};const config = { codec: &quot;vp8&quot;, codedWidth: 640, codedHeight: 480,};const { supported } = await VideoDecoder.isConfigSupported(config);if (supported) { const decoder = new VideoDecoder(init); decoder.configure(config);} else { // Try another config.} 在准备好解码器后，你需要给它一个 EncodedVideoChunk。要创建 Chunk，你需要： 一个编码视频数据的 BufferSource Chunk 的开始时间戳，单位是微秒（Chunk 中第一个编码帧的媒体时间） Chunk 的类型： key，如果 Chunk 可以独立于之前的数据块进行解码，则为关键帧类型 delta Chunk 必须在其他块被解码以后才能被解码 编码器产生的所有 Chunk 都是可以用解码器解码的。之前提到的错误报告和方法的异步等事项，对解码器也是如此。 12345678910const responses = await downloadVideoChunksFromServer(timestamp);for (let i = 0; i &lt; responses.length; i++) { const chunk = new EncodedVideoChunk({ timestamp: responses[i].timestamp, type: responses[i].key ? &quot;key&quot; : &quot;delta&quot;, data: new Uint8Array(responses[i].body), }); decoder.decode(chunk);}await decoder.flush(); 现在，我们把解码好的帧展现在页面上。最好确保解码器的输出回调函数(handleFrame())迅速返回。在下面的例子中，它只是将一个帧添加到准备渲染的帧队列中。渲染是独立进行的，由两个步骤组成： 等待合适的时机来展示帧 在 Canvas 上绘制帧 一旦帧不再被使用，就调用 close() 来在 GC 之前释放底层内存，这将减少平均内存使用量。 1234567891011121314151617181920212223242526272829303132333435const canvas = document.getElementById(&quot;canvas&quot;);const ctx = canvas.getContext(&quot;2d&quot;);let pendingFrames = [];let underflow = true;let baseTime = 0;function handleFrame(frame) { pendingFrames.push(frame); if (underflow) setTimeout(renderFrame, 0);}function calculateTimeUntilNextFrame(timestamp) { if (baseTime == 0) baseTime = performance.now(); let mediaTime = performance.now() - baseTime; return Math.max(0, timestamp / 1000 - mediaTime);}async function renderFrame() { underflow = pendingFrames.length == 0; if (underflow) return; const frame = pendingFrames.shift(); // Based on the frame's timestamp calculate how much of real time waiting // is needed before showing the next frame. const timeUntilNextFrame = calculateTimeUntilNextFrame(frame.timestamp); await new Promise((r) =&gt; { setTimeout(r, timeUntilNextFrame); }); ctx.drawImage(frame, 0, 0); frame.close(); // Immediately schedule rendering of the next frame setTimeout(renderFrame, 0);} Dev Tips在 Chrome DevTools 中使用 Media Panel，查看媒体日志和调试 WebCodecs。 Demo下面这个例子展示了 Canvas 上的动画是如何被： 通过 MediaStreamTrackProcessor 以 25fps 的帧率采集到 ReadableStream 中 转发到 Worker 线程 编码成 H.264 的视频 再次解码为帧序列 使用 transferControlToOffscreen() 在另一个 Canvas 上渲染 new-webcodecs-blogpost-demo Other demosAlso check out our other demos: Decoding gifs with ImageDecoder Capture camera input to a file MP4 playback Other samples 使用 WebCodecs API兼容性检查检查对 WebCodecs 的支持: 123if (&quot;VideoEncoder&quot; in window) { // WebCodecs API is supported.} 请注意，WebCodecs API 只在 secure contexts 下运行，所以如果 self.isSecureContext 是 false，则检测会失败。 FeedbackThe Chrome team wants to hear about your experiences with the WebCodecs API. Tell us about the API designIs there something about the API that doesn’t work like you expected? Or arethere missing methods or properties that you need to implement your idea? Have aquestion or comment on the security model? File a spec issue on thecorresponding GitHub repo, or addyour thoughts to an existing issue. Report a problem with the implementationDid you find a bug with Chrome’s implementation? Or is the implementationdifferent from the spec? File a bug at new.crbug.com.Be sure to include as much detail as you can, simple instructions forreproducing, and enter Blink&gt;Media&gt;WebCodecs in the Components box.Glitch works great for sharing quick and easy repros. Show support for the APIAre you planning to use the WebCodecs API? Your public support helps theChrome team to prioritize features and shows other browser vendors how criticalit is to support them. Send emails to media-dev@chromium.org or send a tweetto @ChromiumDev using the hashtag#WebCodecsand let us know where and how you’re using it. Hero image byDenise Janson Unsplash.","link":"/Program/FrontEnd/WebCodecs/%E8%AE%BA%E4%BD%BF%E7%94%A8WebCodecs%E5%AF%B9%E8%A7%86%E9%A2%91%E8%BF%9B%E8%A1%8C%E5%A4%84%E7%90%86/"},{"title":"论如何在C++&#x2F;CLI中使用LINQ：记一次奇妙的C++大作业","text":"123456“救我，你一定要救我啊！” 我的同学对我如是说“¿”“C++要考试了！我整不来啊，我感觉挺简单的题”“......”“请你吃顿饭”“彳亍” 然后我就收到了这么两道题目： 准备 生成 20 个可被 2 或 5 整除，介于 1 至 100 之间的无重复随机数 Write a program (in C++) that generates and calculates 20 different random numbers that can be divided by 2 or 5. Random numbers must be generated from 1 to 200,the same number cannot be included in the array! The random number generation should be written in a function, i.e. the return value of the function should be an array! 随机产生 50 个人的工资表，并列出平均、最高低工资 Given a list in which the wages of 50 people are stored (in EUR). Write a program (in C++) that determines what the average wage is, who has the highest wage, who has the lowest wage, and who has the wages below average. 乍一看感觉这题确实就是初学者的题目，不过如果我使用普通的方法完成这题就不能称之为 “奇妙” 的大作业了，所以在犹豫一阵后我决定，使用 C++/CLI 来完成顺带再期待一下老师如果看到一堆 CLI 代码会作何反应（ 什么是 C++/CLIC++/CLI 是 C++ 的扩展，让我们可以同时享受 C# 和 C++ 的特性，是微软的就我个人而言，如果能用 C++/CLI 的话那我绝对不会用传统的 C++而且这玩意据我了解在中国没多少人用，或者说老外也不怎么用因为这玩意不上不下的，说实话 C# 的 unsafe 已经足够了 而且就目前为止，它仍然不能跨平台，Core 以后也无法生成独立程序了 寄 There isn’t currently a template for C++/CLI console or Windows applications that can be used with .NET Core.Instead you must put application entry point outside of the C++/CLI code. 所以作业是用 .NET Framework，不过本文使用 .NET Core所以查个资料，学习起来着实有点费力，以后有空可以专门讲讲 在撰写这篇文章时我目前心目中的优先级：C# &gt; Go &gt; Rust &gt; C++/CLI &gt; TS &gt; Java &gt; Python &gt; JS &gt; C++ &gt; C一天到晚只想用托管类语言的我已经是个废物了 话费不多的请直接跳到文章最后看结果接下来我会一点点讲述我的心路历程 做题 准备项目 用 VS 2022 创建一个新的 C# .NET Core 解决方案 在解决方案中添加一个 C++/CLI .NET Core 类库项目 这里如果使用空白项目的话需要自己配置很多东西而且微软对 C++/CLI 的支持是越来越不好了注意：CLI 项目更改以后需要生成一下才能在 C# 中看到变化 Func: GetRandoms首先我们来实现生成随机数的函数既然两个题目都要求了随机数的产生那么我们就专门做一个函数出来复用 尽可能多的复用我认为是一件非常好的习惯无论是在写代码，还是在生活中 函数定义12345678910using namespace System;using namespace Collections::Generic;namespace Aloento::CLILinq { public ref class CLILinq { public: static List&lt;int&gt;^ GetRandoms(int min, int max, int num) { return nullptr; }}; 这就是我的格式习惯，一股子 Java 味让我们来分析一下这个代码 这是在一个 .h 头文件里面的代码 声明函数的写法就是传统的 C++ namespace 和 using 都和 C# 一样，只不过把 . 变成 :: public 是为了让 C# 可以访问 ref 表明这是一个托管类 static 在我这里是 Helper 的统一写法 List&lt;int&gt;^ 返回一个 托管的 ^ List&lt;int&gt; 类型 托管类型都是从 C# 来的用 C++/CLI 托管的代码可以无缝在 C# 中使用，反之亦然 基本功能1234567891011121314static List&lt;int&gt;^ GetRandoms(int min, int max, int num) { auto random = Random::Shared; auto res = gcnew List&lt;int&gt;(num); for (auto i = 0; i &lt; num;) { auto r = random-&gt;Next(min, max); if (!res-&gt;Contains(r) &amp;&amp; (r % 2 == 0 || r % 5 == 0)) { i++; res-&gt;Add(r); } } return res;} Random::Shared 说明了我们现在在使用 .NET Core gcnew 表明了我们要生成一个 托管的 对象 if 语句用来排除重复的随机数，并且确保是 2 和 5 的倍数 i++ 表明我们已经得到了目标，所以我们要让 i 加一，不可以让 for 语句来完成 至此，有一些编程基础的都应该轻松看懂除了一些 CLI 的独特语法以外，其余的和传统 C++ / C# 并无太大区别 数据验证我们写代码的时候还是不要过于相信用户会按照你的想法来使用它毕竟 一个测试工程师走进一家酒吧，啥也没干酒吧就炸了 所以我们简单的加一句： 12if (max / 2 + max / 5 - (min / 2 + min / 5) &lt; num) throw gcnew ArgumentOutOfRangeException(); 这里我没有写具体的说明，不过正式写代码的时候，报错一定要写清楚原因 完全体123456789101112131415161718192021222324252627#pragma onceusing namespace System;using namespace Collections::Generic;namespace Aloento::CLILinq { public ref class CLILinq sealed { public: static List&lt;int&gt;^ GetRandoms(const int min, const int max, const int num) { if (max / 2 + max / 5 - (min / 2 + min / 5) &lt; num) { throw gcnew ArgumentOutOfRangeException(); } auto random = Random::Shared; auto res = gcnew List&lt;int&gt;(num); for (auto i = 0; i &lt; num;) { auto r = random-&gt;Next(min, max); if (!res-&gt;Contains(r) &amp;&amp; (r % 2 == 0 || r % 5 == 0)) { i++; res-&gt;Add(r); } } return res; } };} Func: GetWagesList我是把两道题一起做的，所以在这个 CLILinq 类里应该还有第二题的方法这个方法用来产生一些随机的 Name:Wages 键值对由于时间关系，我们这里生成的名字就直接按 ASCII 取了 123456789101112static Dictionary&lt;Char, double&gt;^ GetWagesList() { auto random = Random::Shared; auto dictionary = gcnew Dictionary&lt;Char, double&gt;(); Char c = 65; for (auto i = 0; i &lt; 50; i++) { auto wage = random-&gt;NextDouble() * 1000; dictionary-&gt;Add(c++, wage); } return dictionary;} 因为比较简单，所以直接上代码这里不用 char 而是 Char，这样可以直接被 C# 转字符串，方便输出 调用：第一题第一题的调用比较无脑，直接用就行了 123456static void Invoke() { auto randomList = GetRandoms(1, 200, 20); for each (auto num in randomList) { Console::WriteLine(num); }} LINQ：第二题第二题的实际逻辑就在这里也是 LINQ 出场的地方 （原谅我前面瞎扯了那么多） 我们先看实现代码 123456789101112131415161718static void Invoke() { auto wageDic = GetWagesList(); auto v = wageDic-&gt;Values; double sum = 0; for each (auto num in v) { sum += num; } auto avg = sum / 50; auto c = System::Globalization::CultureInfo::CultureInfo::CreateSpecificCulture(&quot;eu-ES&quot;); Console::WriteLine(&quot;Average: &quot; + avg.ToString(&quot;C&quot;, c) + &quot;\\n&quot;); auto ordered = Enumerable::OrderBy(wageDic, gcnew Func&lt;KeyValuePair&lt;Char, double&gt;, double&gt;(Select)); for each (auto one in ordered) { Console::WriteLine(one.Key + &quot;: &quot; + one.Value.ToString(&quot;C&quot;, c)); }} for each (auto num in v) 这部分其实就是 Enumerable.Aggregate 的简单实现毕竟要交作业，不能写的那么高级 （其实是嫌麻烦） CultureInfo 就是设置个格式化区域，这里转成欧洲的货币格式avg.ToString(&quot;C&quot;, c) 就是把 avg 转成 Currency LINQ接下来就是 Enumerable.OrderBy 的实现为了搞懂如何传入这个方法需要的参数，我搞了一个多小时到处找资料和 debug… 由于 C++ 11 之前就没有 lambda 表达式，后面有了也非常奇怪所以 LINQ 压根就没有提供类似的调用方式所以我们必须使用 gcnew Func() 的方式传递一个委托 首先，我们必须清楚 Func 的泛型类型到底是什么C++/CLI 在这里 IDE 是完全没有代码提示的，所以我们需要自行分析最好的方式就是在 C# 里面写同样的代码，然后看它们的类型 在这里，Dictionary&lt;Char, double&gt; 的单个元素的类型是 KeyValuePair&lt;Char, double&gt;所以很显然我们需要 Func&lt;KeyValuePair&lt;Char, double&gt;, double&gt;现在我们就有了它的类型，然后我们需要实现这个委托 这个委托是一个选择器，它的作用是从类型中选择出一个对象来作为排序的依据在我们这里，就是要从 KeyValuePair 中把 Value 选出来 随后就有了以下代码 123static double Select(KeyValuePair&lt;Char, double&gt; a) { return a.Value;} 非常简单，在特定情况下，你也可以尝试直接内联它之后的事情就非常简单了，该调用调用，该输出输出 实际上先贴一堆代码，可以粗略看看 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697namespace Aloento.SCLILinq;using System.Globalization;public sealed class SCLILinq { public static List&lt;int&gt; GetRandoms(int min, int max, int num) { Random random = null; List&lt;int&gt; list = null; if (max / 2 + max / 5 - (min / 2 + min / 5) &lt; num) { throw new ArgumentOutOfRangeException(); } random = Random.Shared; list = new List&lt;int&gt;(num); int num2 = 0; while (num2 &lt; num) { int num3 = random.Next(min, max); if (!list.Contains(num3) &amp;&amp; (num3 % 2 == 0 || num3 % 5 == 0)) { num2++; list.Add(num3); } } return list; } public static Dictionary&lt;char, double&gt; GetWagesList() { Random random = null; Dictionary&lt;char, double&gt; dictionary = null; random = Random.Shared; dictionary = new Dictionary&lt;char, double&gt;(); char c = 'A'; for (int i = 0; i &lt; 50; i++) { double value = random.NextDouble() * 1000.0; char key = c; c = (char)(c + 1); dictionary.Add(key, value); } return dictionary; } public static double Select(KeyValuePair&lt;char, double&gt; a) { return a.Value; } public static void Invoke() { List&lt;int&gt; list = null; Dictionary&lt;char, double&gt; dictionary = null; Dictionary&lt;char, double&gt;.ValueCollection valueCollection = null; CultureInfo cultureInfo = null; IOrderedEnumerable&lt;KeyValuePair&lt;char, double&gt;&gt; orderedEnumerable = null; IEnumerator&lt;KeyValuePair&lt;char, double&gt;&gt; enumerator = null; list = GetRandoms(1, 200, 20); List&lt;int&gt;.Enumerator enumerator2 = list.GetEnumerator(); while (enumerator2.MoveNext()) { int current = enumerator2.Current; Console.WriteLine(current); } Console.WriteLine(&quot;\\n-------------------------------\\n&quot;); dictionary = GetWagesList(); valueCollection = dictionary.Values; double num = 0.0; Dictionary&lt;char, double&gt;.ValueCollection.Enumerator enumerator3 = valueCollection.GetEnumerator(); while (enumerator3.MoveNext()) { double current2 = enumerator3.Current; num += current2; } double num2 = num / 50.0; cultureInfo = CultureInfo.CreateSpecificCulture(&quot;eu-ES&quot;); string str = &quot;\\n&quot;; double num3 = num2; string str2 = num3.ToString(&quot;C&quot;, cultureInfo); Console.WriteLine(string.Concat(&quot;Average: &quot; + str2, str)); orderedEnumerable = Enumerable.OrderBy(dictionary, new Func&lt;KeyValuePair&lt;char, double&gt;, double&gt;(Select)); enumerator = orderedEnumerable.GetEnumerator(); try { while (enumerator.MoveNext()) { KeyValuePair&lt;char, double&gt; current3 = enumerator.Current; double value = current3.Value; string format = &quot;C&quot;; string str3 = value.ToString(format, cultureInfo); string arg = &quot;: &quot;; Console.WriteLine(string.Concat(current3.Key + arg, str3)); } } finally { IEnumerator&lt;KeyValuePair&lt;char, double&gt;&gt; enumerator4 = enumerator; if (enumerator4 != null) { enumerator4.Dispose(); long num4 = 0L; } else { long num4 = 0L; } } }} 这是直接对 C++/CLI 生成的库反编译的结果我们可以发现，这就相当于是写了一堆 C# 而已如果带指针之类的，就是 unsafe所以：没必要，别用 C++/CLI 适用范围 如果你想 Wrapper 一个 C / C++ 的库给 C# 用 如果你想让 .NET 与其他语言一起工作 让 C++ 享受 .NET 的生态 如果你闲得慌想找点事情干 在大部分情况下，C++/CLI 的存在都是为了高效的让 C# 与 C / C++ 交互而使用使用它可以让你的 .NET 项目享受到 C++ 全套的生态，反之亦然毕竟 P/Invoke 并不优雅 在托管类语言中，C++/CLI 在一定程度上让 C# 成了最容易与 C / C++ 交互的语言进而让它也更容易与能够和 C / C++ 交互的语言交互 使用它，你需要同时掌握 C# 和 C++而且在很多时候，IDE 不会给你有效的提示所以学习它需要很多时间来尝试 结论12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970using namespace System;using namespace Linq;using namespace Collections::Generic;namespace Aloento::CLILinq { public ref class CLILinq sealed { public: static List&lt;int&gt;^ GetRandoms(const int min, const int max, const int num) { if (max / 2 + max / 5 - (min / 2 + min / 5) &lt; num) { throw gcnew ArgumentOutOfRangeException(); } auto random = Random::Shared; auto res = gcnew List&lt;int&gt;(num); for (auto i = 0; i &lt; num;) { auto r = random-&gt;Next(min, max); if (!res-&gt;Contains(r) &amp;&amp; (r % 2 == 0 || r % 5 == 0)) { i++; res-&gt;Add(r); } } return res; } static Dictionary&lt;Char, double&gt;^ GetWagesList() { auto random = Random::Shared; auto dictionary = gcnew Dictionary&lt;Char, double&gt;(); Char c = 65; for (auto i = 0; i &lt; 50; i++) { auto wage = random-&gt;NextDouble() * 1000; dictionary-&gt;Add(c++, wage); } return dictionary; } static double Select(KeyValuePair&lt;Char, double&gt; a) { return a.Value; } static void Invoke() { auto randomList = GetRandoms(1, 200, 20); for each (auto num in randomList) { Console::WriteLine(num); } Console::WriteLine(&quot;\\n-------------------------------\\n&quot;); auto wageDic = GetWagesList(); auto v = wageDic-&gt;Values; double sum = 0; for each (auto num in v) { sum += num; } auto avg = sum / 50; auto c = System::Globalization::CultureInfo::CultureInfo::CreateSpecificCulture(&quot;eu-ES&quot;); Console::WriteLine(&quot;Average: &quot; + avg.ToString(&quot;C&quot;, c) + &quot;\\n&quot;); auto ordered = Enumerable::OrderBy(wageDic, gcnew Func&lt;KeyValuePair&lt;Char, double&gt;, double&gt;(Select)); for each (auto one in ordered) { Console::WriteLine(one.Key + &quot;: &quot; + one.Value.ToString(&quot;C&quot;, c)); } } };}","link":"/Program/C/CLI/%E8%AE%BA%E5%A6%82%E4%BD%95%E5%9C%A8CPPCLI%E4%B8%AD%E4%BD%BF%E7%94%A8LINQ%E4%B9%8B%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%A5%87%E5%A6%99%E7%9A%84CPP%E5%A4%A7%E4%BD%9C%E4%B8%9A/"}],"tags":[{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"习题","slug":"习题","link":"/tags/%E4%B9%A0%E9%A2%98/"},{"name":"SQLServer","slug":"SQLServer","link":"/tags/SQLServer/"},{"name":"云","slug":"云","link":"/tags/%E4%BA%91/"},{"name":"OpenStack","slug":"OpenStack","link":"/tags/OpenStack/"},{"name":"笔记","slug":"笔记","link":"/tags/%E7%AC%94%E8%AE%B0/"},{"name":"编程","slug":"编程","link":"/tags/%E7%BC%96%E7%A8%8B/"},{"name":"前端","slug":"前端","link":"/tags/%E5%89%8D%E7%AB%AF/"},{"name":"翻译","slug":"翻译","link":"/tags/%E7%BF%BB%E8%AF%91/"},{"name":"音视频","slug":"音视频","link":"/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"},{"name":"WebCodecs","slug":"WebCodecs","link":"/tags/WebCodecs/"},{"name":"JS","slug":"JS","link":"/tags/JS/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"CLI","slug":"CLI","link":"/tags/CLI/"},{"name":"LINQ","slug":"LINQ","link":"/tags/LINQ/"},{"name":"C#","slug":"C","link":"/tags/C/"},{"name":".NET","slug":"NET","link":"/tags/NET/"},{"name":"OrderBy","slug":"OrderBy","link":"/tags/OrderBy/"},{"name":"日记","slug":"日记","link":"/tags/%E6%97%A5%E8%AE%B0/"}],"categories":[{"name":"Database","slug":"Database","link":"/categories/Database/"},{"name":"Cloud","slug":"Cloud","link":"/categories/Cloud/"},{"name":"概念","slug":"Database/概念","link":"/categories/Database/%E6%A6%82%E5%BF%B5/"},{"name":"MSSQL","slug":"Database/MSSQL","link":"/categories/Database/MSSQL/"},{"name":"Program","slug":"Program","link":"/categories/Program/"},{"name":"OpenStack","slug":"Cloud/OpenStack","link":"/categories/Cloud/OpenStack/"},{"name":"FrontEnd","slug":"Program/FrontEnd","link":"/categories/Program/FrontEnd/"},{"name":"C++","slug":"Program/C","link":"/categories/Program/C/"},{"name":"Diary","slug":"Diary","link":"/categories/Diary/"},{"name":"WebCodecs","slug":"Program/FrontEnd/WebCodecs","link":"/categories/Program/FrontEnd/WebCodecs/"},{"name":"CLI","slug":"Program/C/CLI","link":"/categories/Program/C/CLI/"}],"pages":[]}