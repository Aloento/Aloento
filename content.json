{"posts":[{"title":"Basics of Computer Science","text":"我是真没搞明白这老师在干什么所以我按着她的板书，自己搓了一遍她写的那个字，就跟狗爬的一样 Algorithmic problems, modellingtheory of computation, modelling tools, examples What is it good for Create efficient algorithms Programming language research Efficient compiler design and construction 我们为什么要研究算法？ 构建高效算法 编程语言研究 高效编译器设计和构建 Branches of ToCAutomata theory is the study of abstract computational devices formal framework for designing and analyzing computing devices we will discuss Turing Machines. 自动机理论 是对抽象计算机的研究 用于设计和分析计算机的形式框架 我们将讨论图灵机 Computability Theory defines whether a problem is “solvable” by any abstract machines some problems are computable, some are not (e.g. travelling salesman problem) 可计算性理论 定义了一个问题是否可以被任何抽象机器解决 有些问题是可计算的，有些不是（例如旅行推销员问题） Complexity Theory studying the cost of solving problems cost = resources (e.g. time, memory) running time of algorithms varies with inputs and usually grows with the site of inputs we will discuss how to measure complexity 复杂度理论 研究解决问题的成本 成本 = 资源（例如时间，内存） 算法的运行时间随着输入而变化，通常随着输入的增大而增长 我们将讨论如何衡量复杂度 ModllingProblem -&gt; (Model) -&gt; Mathematica Frame -&gt; (Algorithm) -&gt; Solution 问题 -&gt; (模型) -&gt; 数学框架 -&gt; (算法) -&gt; 解决方案 Tools of modelling sets function number systems, coding graphs 集合 函数 数制，编码 图 Graph definitionG=(V,E) where V is finite and not empty set, V = edges, E = vertices G=(V,E) 其中 V 是有限且非空的集合，V = 边，E = 顶点 Graph Representations drawing edge and vertex list adjacency matrix 图形表示法 绘图 边和顶点的列表 邻接矩阵 Examples of graph modelsComplicated intersection traffic lights Translates to graph coloring problem and maximal independent set problem too King Arthur and the knights of the Round TableNoblemen and Noble MaidensTuring Machinesdefinition, construction, properties, transition functions What is a Turing Machine TMS are abstract models for real computers having an infinite memory(in the form of a tape) and a reading head has finite number of internal states has distinguished starting and final states (termination: accept / reject) has transition functions (Tt) (graphs) 图灵机是对真实计算机的抽象模型，它具有无限内存（以磁带的形式）和读写头 具有有限数量的内部状态 具有特殊的起始和终止状态（终止：接受/拒绝） 具有转换函数（Tt）（图） TM accepts the initial content of the tape if it terminates in an acceptingstate. Otherwise TM rejects it. TM terminates, if there is no rule with watching conditionsfor certain state and input symbols. TM is ND (non-deterministic), if such a state and set of input symbolsexist, for which there are multiple rules defined.(= from the same set of starting state and input symbols the TM has multiple outcomes) 如果图灵机终止于接受状态，则它接受磁带的初始内容。否则拒绝。 如果没有匹配的规则，则图灵机终止。 如果存在某个状态和输入符号集，对于该状态和输入符号集，有多个规则，则图灵机是非确定性的（ND）。（=从同一组起始状态和输入符号集，图灵机具有多个结果） NDTM accepts the initial content of the tape if there isa sequence of transition functions that accepts it. Thesis: For All NDTM Exsist equivalent DTM 对于所有的非确定性图灵机，都存在等价的确定性图灵机 Defining a Turing Machine defining the number of tapes &amp; head defining the tape alphabets defining the net of state, initial and terminating states,accepting and rejection terminal states From an already existing machine it is possible to head the followings: number of heads set of states constructed from the states mentioned in the TFS Universal TM: TM, which can simulate All other TM Church - Turing thesis:A function (problem) can be effectively solved &lt;=&gt; it is computable with a TM The same problems can be solved by a TM and modern computers Complexity of algorithmsmeasuring complexity, complexity classes 算法会消耗时间和内存，复杂度就是衡量消耗的指标 时间复杂度时间复杂度主要是循环导致的，我们不必把它想得太复杂下面列出的时间复杂度越来越大，执行的效率越来越低 常数阶 O(1)12let i = 1;i = i + 1; 说白了就是没有循环，即便它有几百万行 对数阶 O(logN)1234let i = 1;while (i &lt; n) { i = i * 2;} 我们可以看到，每次循环都会把 i 乘 2设循环 x 次后，i 大于 n则 2^x &gt; n，即 x &gt; log2(n) 线性阶 O(N)123for (let i = 0; i &lt; n; i++) { console.log(i);} 这个就更好理解了，循环 n 次它的前进速度明显就没有之前乘 2 的那个快了 线性对数阶 O(NlogN)12345for (let i = 1; i &lt; n; i = i * 2) { for (let j = 0; j &lt; n; j++) { console.log(j); }} 名字看的很奇怪，但实际上把 O(logN) 的代码，再循环 N 次那它的时间复杂度就是 n * logn 了 当然你也可以把 O(N) 的代码，再循环 logN 次就像上面的例子一样 平方阶 O(N^2)12345for (let i = 0; i &lt; m; i++) { for (let j = 0; j &lt; n; j++) { console.log(j); }} n * n 不就是 n^2 吗把 O(N) 的代码，再循环 N 次比之前那个还好理解 当然也可以是 m * n那时间复杂度就是 O(MN) 了 其他的还有 K 次方阶 O(N^k) 指数阶 O(2^N)一般是递归算法 O(3^N) etc. 计算T(n) 算法的执行次数T(n) = O(f(n)) 嵌套循环由内向外分析，并相乘 1234567// O(n)for (let i = 0; i &lt; n; i++) { // O(n) for (let j = 0; j &lt; n; j++) { console.log(j); // O(1) }} 时间复杂度为 O(n * n * 1) = O(n^2) 顺序执行你可以把它们的时间复杂度相加在不要求精度的情况下可以直接等于其中最大的时间复杂度 1234567891011// O(n)for (let i = 0; i &lt; n; i++) { console.log(i);}// O(n^2)for (let i = 0; i &lt; n; i++) { for (let j = 0; j &lt; n; j++) { console.log(j); }} 时间复杂度为 O(n + n^2) 或者不要求精度 O(n^2) 条件分支时间复杂度等于所有分支中最大的时间复杂度说人话就是：最麻烦的那个情况 123456789if (n &gt; 10) { // O(n) for (let i = 0; i &lt; n; i++) { console.log(i); }} else { // O(1) console.log(n);} 时间复杂度为 O(n) 空间复杂度很显然，时间复杂度并没有真正计算算法实际的执行时间那么空间复杂度一样也不是真正的占用空间 O(1)12let i = 1;i = i + 1; 代码中的变量所分配的空间，都不随数据量的变化而变化所以空间复杂度为 O(1) O(N)1234let arr = [];for (let i = 0; i &lt; n; i++) { arr.push(i);} 看到数组就表明，空间是随着 n 增大而增大的所以空间复杂度为 O(N) 计算所以说的简单一点 如果 n 增大，程序占用的空间不变，则空间复杂度为 O(1) 如果 n 增大，程序占用的空间成线性增长，那么空间复杂度就是 O(N) 如果 n 增大，程序占用的空间成平方增长，那么空间复杂度就是 O(N^2) 以此类推当然也有 O(N + M), O(logN)等 Sorting algorithms and their complexityselection sort, bubble sort, insertion sort and optimization, their analysis, theorem about maximum complexity case runtime steps 我们按时间复杂度区分，并介绍十大常用的排序算法由于这门课并不教怎么写代码，所以我们只需要了解它是怎么工作的就行了 学计算机不学写代码，行吧，当数学课上 O(N)它们都是非比较算法，不适合大量或大范围数据 计数排序Counting Sort每个桶只存储单一键值O(N + K) 对于给定的输入，统计每个元素出现的次数，然后依次把元素输出 桶排序Bucket Sort 每个桶存储一定范围的数值它需要调用其他的排序算法来完成排序所以它的实际时间复杂度受到其使用的排序算法的影响O(N * K) 基本思路是，把数据分到有限数量的桶里，然后对每个桶内部的数据进行排序最后将各个桶内的数据依次取出，得到结果 让我们看一个例子假设我们有 20 个数据，要分成 5 个桶 12345678910111213141516171819202122232425262728293031323334353637383940function bucketSort(arr: number[], bucketSize: number) { // 创建大小为 bucketSize 的桶数组 const bucket: number[][] = []; // 初始化桶数组 for (let i = 0; i &lt; bucketSize; i++) { bucket[i] = []; } // 获取数组中的最大值和最小值 const max = Math.max(...arr); // 194 const min = Math.min(...arr); // 13 // 计算桶的范围 // (194 - 13 + 1) / 5 = 36.4 const range = (max - min + 1) / bucketSize; // 将数据放入对应的桶中 for (let i = 0; i &lt; arr.length; i++) { // 计算数据应该放入的桶的索引 // 比如 63：floor(63 - 13) / 36.4) = 1 const index = Math.floor((arr[i] - min) / range); bucket[index].push(arr[i]); } // 使用其他算法，对桶内的数据进行排序 for (let i = 0; i &lt; bucketSize; i++) { bucket[i].sort((a, b) =&gt; a - b); } // 将桶内排好序的数据依次取出，得到有序序列 const result: number[] = []; for (let i = 0; i &lt; bucketSize; i++) { for (let j = 0; j &lt; bucketSize; j++) { result.push(bucket[i][j]); } } return result;} 基数排序Radix Sort根据键值的每位数字来分配桶O(d(n+r))，其中 d 是基数，n 是要排序的数据个数，r 是每个关键字的基数 将所有待比较数值统一为同样的数位长度，数位较短的数前面补零然后，从最低位开始，依次进行一次排序这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列 O(NlogN)希尔排序Shell Sort，也称递减增量排序是插入排序的一种更高效的改进版本，它会优先比较距离较远的元素 先将整个序列，分割成若干个子序列，分别进行插入排序待整个序列基本有序时，再对整体进行插入排序 我们有 [7, 6, 9, 3, 1, 5, 2, 4] 需要排序首先我们确定增量为 4，每次缩小一半 所以我们有 4 个子序列 1234[7, 1];[6, 5];[9, 2];[3, 4]; 分别排序它们 1234[1, 7];[5, 6];[2, 9];[3, 4]; 得到 1[1, 5, 2, 3, 7, 6, 9, 4]; 然后缩小增量为 2，再次分割 12[1, 2, 7, 9];[5, 3, 6, 4]; 排序得到 1[1, 2, 3, 4, 5, 6, 7, 9]; 归并排序Merge Sort，是一种分治算法将两个或两个以上的有序表合并成一个新的有序表 把长度为 n 的序列分成两个长度为 n/2 的子序列 对这两个子序列分别采用归并排序（递归） 将两个排序好的子序列合并成一个最终的排序序列 快速排序Quick Sort应该算是在冒泡排序基础上的递归分治法 随便选择一个元素 将比这个元素小的放在左边，比这个元素大的放在右边 对左右两边的元素重复第二步，直到各区间只有一个元素 堆排序Heap Sort 构建一个大顶堆，此时，整个序列的最大值就是堆顶的根节点 将其与末尾元素进行交换，此时末尾就为最大值 然后将剩余的 n-1 个元素重新构建成一个堆，这样会得到 n 个元素的次小值 如此反复执行，便能得到一个有序序列了 O(N^2)冒泡排序Bubble Sort比较相邻的元素，如果第一个比第二个大，就交换他们两个，一直向上冒泡 选择排序Selection Sort也就是每次找到最小的元素，放到前面，重复 优化可以在找到最小元素时记录下它的位置，并在最后交换元素的时候使用该位置。这样可以避免每次都将最小元素与已排序序列的最后一个元素交换，减少了不必要的操作 例如，对于序列[5, 3, 8, 1, 9]，优化的过程如下： 第一次遍历，找到最小元素 1，然后将 1 与 5 交换[1, 3, 8, 5, 9] 第三次遍历，在剩下的序列 [5, 8, 9] 中找到最小的元素 5，然后将 5 与 8 交换[1, 3, 5, 8, 9] 插入排序Insertion Sort像打扑克时整理手牌一样，将每张牌插入到合适的位置 Basic graph algorithmsgraph searches (BFS, DFS, Dijsktra), tree traversals, longest path problems 深度优先搜索 广度优先搜索 遍历前序遍历：根结点 —&gt; 左子树 —&gt; 右子树是从最上层往下走 中序遍历：左子树 —&gt; 根结点 —&gt; 右子树是从最左边往右走 后序遍历：左子树 —&gt; 右子树 —&gt; 根结点是从最下层往上走 层次遍历：只需按层遍历即可 Dijsktra123456789 5A ----- B| || |4 6| || |C ----- D 5 首先，我们将 A 设为原点，并初始化每个顶点到原点的距离为无穷大 1234567891011121314/** * 每个顶点到原点的距离 */let dist: Record&lt;string, number&gt; = { A: 0, B: Infinity, C: Infinity, D: Infinity,};/** * 获取两个顶点之间的权重 */declare function weight(node1: string, node2: string): number; 接下来，我们要不断迭代更新每个顶点到原点的最短距离，直到所有顶点的最短距离，都被更新为最终值。 在每次迭代中，我们首先找到所有未被更新的顶点中，距离原点最近的顶点，然后更新它到原点的最短距离，并根据新的距离，更新其他顶点，到原点的距离。 从 A 向外扩散 1234dist.B = Math.min(dist.B, dist.A + weight(&quot;A&quot;, &quot;B&quot;)) = Math.min(Infinity, 0 + 5) = 5; 1234dist.C = Math.min(dist.C, dist.A + weight(&quot;A&quot;, &quot;C&quot;)) = Math.min(Infinity, 0 + 4) = 4; 从 B 向外扩散 1234dist.D = Math.min(dist.D, dist.B + weight(&quot;B&quot;, &quot;D&quot;)) = Math.min(Infinity, 5 + 6) = 11; 从 C 向外扩散 1dist.D = Math.min(dist.D, dist.C + weight(&quot;C&quot;, &quot;D&quot;)) = Math.min(11, 4 + 5) = 9; 得到结果 123456dist = { A: 0, B: 5, C: 4, D: 9,}; 所以，从 A 到 D 的最短距离为 9 Graph diagnosticsGraph diagnostic problems are graph problems that can be answered with Y/N. Connectivity A graph G is connected, if for any two nodes there exists a walk between them. 连通性是指图中任意两个顶点之间是否存在一条路径，使得两个顶点可以互相到达。如果一个图中的任意两个顶点都可以互相到达，那么这个图就被称为连通图。 要判断一个图是否连通，可以使用搜索算法，如广度优先搜索或深度优先搜索。搜索时，从图中的任意一个顶点开始，并尝试访问该顶点的所有邻接点。如果能够访问到图中所有的顶点，那么这个图就是连通图。 Absolute winner绝对赢家指的是一个结点，它在一个博弈论游戏中总是能够获胜。这意味着，不论对手采取什么策略，该结点都有某种优势，使它能够获胜。例如，如果一个结点具有更多的邻居，那么它就可能是一个绝对赢家，因为它可以通过与其他结点交换信息来获得更多的有利条件。 绝对赢家与相对赢家有所不同。相对赢家指的是在某些情况下，某个结点比其他结点更有优势，从而使它有可能获胜。但是，如果对手采取了特定的策略，那么这个结点可能就不再是赢家了。而绝对赢家则不存在这种情况，它总是能够获能，不管对手采取什么策略。 Complete node, logical formulas完全节点是指，这个节点与其他任何节点都至少存在一条边 至于 logical formulas，指的是 FDNF disjunctive normal form它与 DNF 不同点似乎是每个出现的变量都会出现在每个子句中 Graph coloringVertex顶点着色的规则是，任意两个相邻的顶点不能有相同的颜色。并且我们使用尽可能少的颜色来着色。 我们从图中的一个顶点开始，为它分配一种颜色。然后，我们按照顶点的顺序遍历图中的其他顶点，为每个顶点分配一种与相邻顶点不同的颜色 Brooks theorem描述了图的着色数与图中最大度数的关系，提供了图着色数的一个上界 如果一个无向图 G 满足以下条件，那么它可以用 Δ(G) 或更少的颜色染色： G 是一个连通图（即它不包含任何脱离的部分） G 不包含任何奇环（即它不包含任何长度为奇数的环） Δ(G) 指的是图 G 中最大的度数。 Degree度数指的是一个顶点与其相邻顶点之间的边的数量度数可以用来衡量一个顶点与其他顶点的连通性。通常情况下，一个顶点的度数越大，它与其他顶点的连通性就越强 Four color theorem如果一个平面图 G 不包含任何环，那么它可以用不超过 4 种颜色染色，使得相邻的两个区域拥有不同的颜色。 Subgraph在原图中选择一些节点和边，并从原图中删除其他的节点和边。这样得到的图就是原图的一个子图。如果一个节点的度数为 2，那么我们可以删除该节点，并将它与其他两个节点之间的两条边”合并”成一条边。 Edge给图中的边分配颜色，使得图中相邻的边拥有不同的颜色 Chromatic index 是图的最小着色度，指需要多少种不同的颜色 Vising theorem 指 对于任意一个无向图，它的染色度（chromatic number）不会超过其度数（degree）的上限 Bipartite graphs 是一种二分图，它由两个部分组成，每个部分内部的点互不相邻，而两个部分之间的点才会相互相邻。 Planar graphs 则是一种平面图，它是指图中任意两条边都不会相交，也就是说，图中的边可以在平面上放置而不会交叉。 Scheduling problems 例如，在一个工厂生产线上，有许多不同的机器和工人，他们需要按照特定的顺序来完成各种任务。为了让生产流程顺利进行，我们可以使用 edge coloring 算法来给每个任务分配一种颜色，并确保相邻的任务颜色不同。这样，工人和机器就可以按照颜色顺序来执行任务，从而保证生产流程的顺利进行。 Packing and CoveringGeneralizationGeneral, “everyday” problems, which have suboptimal solutions: Put in objects into one container!Some pairs are incompatible, those cannot be put into the container together.Question: how to put the maximal number of objects into the container? n people at a meeting.Find the largest subgroup of them, in which everybody knows everybody! Trucker delivering goods with no going backQuestion: how can they deliver the maximum number of goods? Big piece of leather, cutting out small shapes.Question: how to cut out the largest amount of smaller shapes? Common property of these problems: representable with a graph similarly.Is there any connection between their solutions? Let’s look at the problems solutions, starting with the “easiest”: 一般来说，“日常” 问题，它们有着次优解： 把物品放入一个容器中有些物品是不兼容的，它们不能放在同一个容器中问题：如何把最多的物品放入容器中？ n 个人在会议中找到其中最大的一个子集，其中每个人都认识 卡车司机送货，不允许回头 大块皮革，切割成小块。问题：如何切割出最多的小块？ 这些问题的共同特点：它们可以用图来表示 Disjoint Interval Search Trucker delivering goods with no going backQuestion: how can they deliver the maximum number of goods? Disjoint Interval Search (DIS)This problem is also called interval packing. 绎演丁真，鉴定为史 如果一个卡车司机要把货物送到多个不同的地方，而且一旦离开一个地方就不能再回去，那么他应该怎样才能把尽可能多的货物送到目的地呢？ 我寻思着这问题应该用 TSP 来解才对总之先看看什么是 DIS DIS 是一种用于处理区间数据的算法。区间数据是指一组由起始和结束点表示的区间，例如：[1, 5]、[10, 15] 等。它能够快速检索出与给定的区间不相交的区间。 将区间数据存储在能够快速查找和插入的数据结构中，例如红黑树、平衡树或 B 树 查找与给定区间不相交的区间检查区间数据中的每一个区间，并判断它们是否与给定区间不相交如果一个区间与给定区间不相交，则将其加入结果集。 返回结果集 Cliquen people at a meeting.Find the largest subgroup of them, in which everybody knows everybody! Can we find three people like that?Can we find four people like that?Can we find five people like that? Why not?Clique search 衣掩丁真，鉴定为衣驼使 这是一个分团问题Clique search 是一种用于寻找图中的完全子图（即“clique”）的算法完全子图是指一个子图中所有节点都相互连通算法需要枚举所有可能的完全子图，并确定哪些子图满足给定的条件 Maximal Independent SetPut in objects into one container!Some pairs are incompatible, those cannot be put into the container together.Question: how to put the maximal number of objects into the container? Edges code incompatibility.We are searching for independent node subsets.Maximal Independent Set (MIS) We found a maximal empty subgraph. Connection with the previous problem?If we create the complimenting graph from this (where we had an edge, now we don’t have one, and vice versa), and consider the same chosen nodes, then that is a clique. So we can convert this problem into the previous one: MIS → Clique search These problems are basically the same, only their representation is different. In this sense, even problem no.3 is the same as no.1 and no.2. Converting problem no. 3 to the present form: Intervals are going to turn into vertices of a graph.If two intervals are incompatible, we draw an edge between the corresponding nodes. We converted DIS into MIS. Maximal Independent Set 是指一个图中没有一个节点与其他节点相邻，并且该集合不能再增加任何节点而保持这种性质的节点集合 一个独立集（也称为稳定集）是一个图中一些两两不相邻的顶点所形成的集合，如果两个点没有公共边，那么这两个点可以被放到一个独立集中 对于三个点组成的完全图而言，每个点自身是一个独立集（且是最大独立集）对四个点构成的四边形图而言，对角的两个点组成一个独立集（且是最大独立集） 如果往图 G 的独立集 S 中添加任一个顶点都会使独立性丧失（亦即造成某两点间有边），那么称 S 是极大独立集。 如果 S 是图中所有独立集之中基数最大的，那么称 S 是最大独立集，且将该基数称为 G 的独立数，记为 α(G)。一般来讲，图 G 中可能存在多个极大独立集和最大独立集。 根据定义，最大独立集一定是极大独立集，但反之未必。 CutBig piece of leather, cutting out small shapes.Question: how to cut out the largest amount of smaller shapes? 大块的皮革，切出小的形状。问：如何切出最多的小形状？ We can rotate the sample, but we still have to fit into the big piece of leather. 我们可以旋转样本，但我们仍然要贴合大块皮革。 This is the most difficult problem out of the four, because the main “philosophical” difference between them is that the first three were obvious finite problems (finite number of people, objects, intervals), whereas this problem cannot produce obvious finite number of nodes. 这是四个问题中最困难的一个，因为它们之间的主要“哲学”区别在于前三个是显然的有限问题（人数、物品数、区间数都是有限的），而这个问题不能产生显然的有限节点数。 So we make a grid on the big leather, place a node on the shape, and say that the shape can only be cut out of that node fits on one of the grid points. 因此，我们在大皮革上做一个网格，在形状上放一个节点，并说形状只能在该节点适合网格点之一时被切出来。 The grid points create a finite set. But since we can still rotate the shape around the grid point, our choices are infinite again. Solution: we only consider a few angles. So now we can only cut out the shape if the node is ou a grid point, and the line on the sample can only parallel to one of our predefined angle lines. 网格点创建了一个有限集。但是，由于我们仍然可以围绕网格点旋转形状，所以我们的选择又是无限的。解决方案：我们只考虑几个角度。因此，现在我们只能在节点在网格点上并且样本上的线只能与我们预定义的角度线平行时切出形状。 So to make an infinite problem finite we need to add restrictions. 因此，要使无限问题变为有限，我们需要增加限制。 We can code the placement with the number of the grid point and the number of the angle.Eg: (5; 6) and (14; 6). 我们可以用网格点的编号和角度的编号来编码放置位置。例如：（5；6）和（14；6）。 However, these two overlap, so they cannot be cut out together. This incompatibility can be represented in a graph by adding an edge between these two number pains. 然而，这两个重叠了，因此它们不能一起切出来。这种不兼容可以通过在这两个数字之间添加一条边来表示在图中。 This way we can create a graph, and the maximum number of cutouts on the leather is reduced to finding the maximal number of independent nodes in the corresponding graph. 这样我们就可以创建一个图，皮革上的最大切割次数就被减少到在相应图中找到最大的独立节点数。 What is the problem with this method?The restrictions can cause a result with less cutouts, than if we could freely place the shape. 这种方法有什么问题？限制可能导致切割次数比我们可以自由放置形状时少的结果。 Solution: let’s use a denser grid and consider none rotational angles! 解决方案：让我们使用更密集的网格并考虑非旋转角度！ Problem with the solution: as we have more gridpoints and angles, the graph becomes larger, so finding the MI5 is more complicated. 解决方案的问题：随着我们有更多的网格点和角度，图变得更大，因此找到 MI5 变得更复杂。 So this method is a digitalization, which has a resolution. The bigger the resolution is, the closer to the optimal solution we are. 因此，这种方法是一种数字化，它具有分辨率。分辨率越大，我们越接近最优解。 总结Ater examining these four problems, we have a general framework: 在经过对这四个问题的检查后，我们得出了一个总体框架： Given is a graph. Find the maximal number of nodes such that those are never connected to each other. &lt;=&gt; We want to find the maximal independent set of nodes. → MIS problem. 给定一张图。找到一个节点的最大数量，这些节点从不相互连接。&lt;=&gt;我们想找到节点的最大独立集合。→MIS 问题。 This can be solved in exponential time. 这可以在指数时间内解决。 The trivial algorithm for finding MIS: 找到 MIS 的简单算法： We want to find MIS of { 1, 2, 3, 4, 5, 6 }. We try to find an independent subset of size 2. Start with 41,2}. Is this independent? No! So try { 1, 3 }. This is good! But then can we find an independent subset of nite 3? We need to check all site 3 subsets. 我们想找到 {1,2,3,4,5,6} 的 MIS。我们试图找到大小为 2 的独立子集。从 {1,2} 开始。这是独立的吗？不是！所以尝试 {1,3}。这很好！但是然后我们能找到大小为 3 的独立子集吗？我们需要检查所有大小为 3 的子集。 In the worst case we need to investigate all subsets of { 1, 2, 3, 4, 5, 6 } 在最坏的情况下，我们需要调查 {1,2,3,4,5,6} 的所有子集 Theorem: If |x| = n, then |p(x)| = 2^n. (p(x) = { y | y &lt;= x } -&gt; power set = set of all subsets) In our example n = 6, so we have 2^6 = 64 subsets. How to code subsets? { 1, 2, 3, 4, 5, 6 } 1 0 1 0 0 0 1 1 0 0 0 1 -&gt; this will code { 1; 3 }-&gt; this will code { 1; 2; 6 } Since it is a one-to-one correspondence between subsets and outshines,then |p(x)| = |{ binary string of length 8 }| 因为子集和出现之间是一一对应的，所以 |p(x)| = |{长度为 8 的二进制字符串}| because a choice codes 1 On 0 = yes or no 因为选择编码 1 On 0 = yes or no In terms of our MIS - finding problem: if we count checking a binary string for independence, then this trivial algorithm has an exponential runtime, exactly 2^n. 就我们的 MIS 查找问题而言：如果我们算出检查一个二进制字符串是否独立的次数，那么这个简单算法的运行时间是指数级别的，精确地说是 2^n。 A more refined algorithm for the same problem:Find a method, where we only check already independent sets. 同一问题的一种更优秀的算法：找到一种方法，只检查已经独立的集合。 Example: The independent set is called S.We always ask the nodes whether they are an element of S. → “yes” branches and “no” branches. Next question is based on already existing elements. 独立集合称为 S。我们总是问节点是否是 S 的元素。→“是”和“否”分支。下一个问题是基于已存在的元素。 This is a labelled and rooted binary thee.Can be done faster, if we are only considering paths that have a chance to have enough nodes on them.“if it’s not there, don’t even look” 这是一棵带标签和根的二叉树。如果我们只考虑可能有足够节点的路径，可以更快地完成。“如果它不在那里，甚至都不用看”。 Interval packing, dominating setsA little help for the next algorithm: the Pidgeon-hole principle. 下一算法的一点帮助：鸽巢原理。 Question: when the pigeons go to their pigeon-holes, what can we state for sure?Whichever houses they choose, there is going to be at least one hole with two pigeons in it. 问题：当鸽子去它们的鸽巢时，我们能肯定什么？无论它们选择哪所房子，至少会有一个洞有两只鸽子。 So the pigeon-hole principle says that if there are more pigeons than houses, then there will be at least one hole with at least two pigeons in it. 因此，鸽巢原理说，如果有比房子更多的鸽子，那么至少会有一个洞至少有两只鸽子。 If this weren’t true, and all houses tould contain one pigeon at worst, then there would be only as many pigeons as houses. Whereas we had more pigeons. 如果这不是真的，并且所有的房子里最多只有一只鸽子，那么只会有和房子一样多的鸽子。但我们有更多的鸽子。 If we use our previous example 3, we can apply the pigeon-hole principle to the problem: 如果我们用之前的例子 3，我们可以将鸽巢原理应用于问题： The algorithm: choose closest destination, if starting point is still ahead=&gt; maximal number of =&gt; independent intervals =&gt; Interval packing algorithm 算法：如果起点仍然在前面，则选择最近的目的地=&gt;最大数量的=&gt;独立区间=&gt;区间打包算法 If we only consider the destinations as pink dots, then we can choose any interval, there will always be a pink dot on it - at least one dot.=&gt; the set of pink dots is a dominating set. 如果我们只考虑目的地作为粉红色点，那么我们可以选择任何区间，它上面总会有一个粉点——至少有一个点。=&gt;粉点集是一个支配集。 A set X is a dominating set, if for every you find at least one element of the set on that interval. 一个集合 X 是支配集，如果对于每个区间都能找到集合中的至少一个元素。 Femina: X is a dominating set, 4 is an independent set of intervals.Then |x| &gt;= |y|. X 是支配集，4 是区间的独立集。 The chosen intervals corresponding to the transportation is an independent set with three intervals. There are also three pink dots as the dominant set. So based on the lemma, there can be no more independent intervals. 选择的区间对应于运输是具有三个区间的独立集。还有三个粉红色的点作为支配集。因此，根据引理，不能有更多的独立区间。 Proof: Indirectly. New statement: |x|birds &lt; |y|houses. Let’s have one more independent interval. But according to the pigeon-hole principle, there is at least one pint dominating dot on every interval. In order to dominate the all intervals, we would need at 1 different pink dots. 让我们再来一个独立区间。但根据鸽巢原理，每个区间都至少有一个主要点。为了控制所有区间，我们需要至少 1 个不同的粉点。 =&gt; There must be at least two intervals with the same pink dot,but then they’re not independent. =&gt; 必须有至少两个区间有相同的粉点，但这样它们就不是独立的了。 Even though there is no general quick (polynomial) solution forfinding MIS, the Interval pairing algorithm is fast. How fast? 尽管没有求解 MIS 的通用快速（多项式）解决方案，但 Interval pairing 算法是快速的。它有多快？ We shone all starting and destination point somehow - e.g. by numbers.So we only have to order them, and find the “smallest” endpoint first. 我们用某种方式给所有起点和终点标号——例如，用数字。所以我们只需要按顺序排序，找到“最小”的终点。 ~n steps needed to find the closest destinationwe need to repeat it at worst a times =&gt; polynomial algorithm 找到最近目的地需要 ~n 步最坏情况下，我们需要重复 a 次，所以这是一个多项式算法 How can it be that MI5 can’t be solved quickly, but this algorithm has quadratic runtime?! 为什么 MI5 无法快速解决，但这个算法的运行时间是二次的呢？ The intervals are represented as nodes and overlaps as edges in the graph.So did we just solve MI5 in quadratic time?! 区间在图中表示为节点，重叠部分表示为边。所以我们刚刚在二次时间内解决了 MI5 吗？ No! Because not all graphs can be processed by this method. (Not all graphs with a nodes occur this way.) so we only solved MI5 for a subset of graphs having a nodes. 不是的！因为并不是所有图都可以用这种方法处理。（不是所有带有 n 个节点的图都是这样出现的。）所以我们只为一个带有 n 个节点的图子集解决了 MI5。 So for a subset of cases we have a solution, but not for the general case.(e.g. 5th degree polynomials) 所以对于一个子集的情况，我们有一个解决方案，但不是通用情况。（例如，五次多项式） 区间打包，用于找到最多可以放在一个容器内的不相交区间的最大数量。是指把一系列区间尽可能多地放到一个集合中，使得它们都不重叠。 支配集指在一张图中，存在一组节点，每个节点都与它相邻的节点相连，或者至少有一个节点在该组中。其中的元素可以覆盖整个集合，即每个元素都与至少一个其他元素有交集。 Suboptimal algorithms次优算法 what is the basic problem?→ polynomial algorithms are “quick”→ exponential algorithms are “very slow” 基本问题是什么？→ 多项式算法“快”→ 指数算法“非常慢” There is a set of problems for which there is no quick algorithm. 有一类问题没有快速算法。 Their runtime is proportionate to f(a) =2^n. To put this in perspective, there are no more than 2^350 atoms in the whole universe. 它们的运行时间与 f(a) = 2^n 成比例。为了更好地理解这一点，整个宇宙中没有超过 2^350 种原子。 Therefore we can just use this disadvantage to our advantage by using these kind of problems for coding protocols, as decoding them would tale over a million years. 因此，我们可以利用这个缺点，通过使用这类问题来编写编码协议，因为解码它们需要超过一百万年。 Good example for this is finding a Hamiltonian cycle in a graph. Creating is easy, but then we can obfuscate it. 寻找图中的汉密尔顿回路是一个很好的例子。创建容易，但是我们可以混淆它。 Problem is, that there are a lot of real-life situations that can only be converted into these kinds of problems, where the solution is exponential, or even worse. 问题是，有很多现实生活中的情况只能转换为这类问题，其解是指数级的，甚至更糟。 Good example is the traveling agent problem. This is understood on weighed graphs, and the point is to touch all the nodes with a minimal sum of edge weights. (Hamiltonian path problem). 一个很好的例子是旅行代理问题。这在加权图上是可以理解的，其目的是以最小的边权和触摸所有节点。（汉密尔顿路径问题） In this case we can imagine a package delivery service, in which case we need the shortest possible combination / permutation of the packages in order to make the least amount of kilometers. Though, this is a hard problem, meaning, there exists not a quick algorithm for this. 在这种情况下，我们可以想象一个包裹配送服务，在这种情况下，我们需要包裹的最短可能组合/排列，以便减少尽可能多的公里数。尽管这是一个难题，即不存在一个快速的算法来解决这个问题。 =&gt; suboptimal algorithms-&gt; We don’t want to (= can’t) find the best solution, but something that is pretty close this best solution. =&gt; 次优算法-&gt; 我们不想（也不能）找到最优解，而是找到一个非常接近最优解的解决方案。 So in case of the traveling agent, we don’t want to find the optimal route, but we want a route such that it is sure that it uses at more Klia as many kilometers as the optimal one. It would be a 2-optimal algorithm. 所以在旅行代理的情况下，我们不想找到最优路线，而是想找到一条路线，使得它确保它使用的公里数至少与最优路线相同。这将是一个 2-optimal 算法。 So the suboptimality of algorithms has nothing to do with running time. 因此，算法的次优性与运行时间无关。 In the traveling agent situation a 3-optimal algorithm would find a solution that is at most three times worse than the optimal one, meaning, it would find a permutation of the target adnesses such that if the driver follows that order, than at most three times as many kilometers are used as in case of the optimal solution. 在旅行代理的情况下，3-optimal 算法将找到一个至多比最优解差三倍的解决方案，这意味着它会找到目标地址的一个排列，如果司机遵循这种顺序，那么至多会使用三倍于最优解情况下的公里数。 An algorithm is called k-optimal (k ≥ 1) if its output is at most b-times worse than the best output would be. 如果其输出最多比最佳输出差 b 倍，则称该算法为 k-optimal（k ≥ 1）。 Bin packing problem Objects with volumes:V1, V2, V3 … Vn. Vi &lt;= (i = 1, …, n) Problem: use the least amount of containers to store all objects. 问题：使用最少的容器来存储所有物品。 (The sum of the volumes of objects in one container can’t exceed volume of the container.) （一个容器中物品的总体积不能超过容器的体积。） This is a hard problem. But there exists a 2-optimal algorithm for that. 这是一个难题。但是存在一个 2-optimal 算法。 First Fit Algorithm: Choose the first container in which the object fits. (This is greedy.) 首次适应算法：选择第一个容器，其中的物品适合。（这是贪婪的。） 降序首次适应算法First Fit Decreasing 将物品按照价值从大到小排序 找到一个能放下物品的背包，放入物品 重复 2，直到所有物品都放入 简而言之，FFD 按照大小降序排列项目，然后放入第一合适的背包 Algebraic algorithmsDivisibility, Euclidean algorithmFaster multiplication and division of large numbers","link":"/Algorithm/Basics-of-Computer-Science/"},{"title":"Design and Analysis of Algorithms","text":"研究生学习开始啦 这节课介绍了一些著名的问题解决方案及其典型算法，并且还有它们的实践内容 Stable Marriage ProblemProblem Description 有 n 个男人和 n 个女人 每个人都有一个 preference list，即对另一性别的人的偏好排序 问题：如何匹配男女，使得每个人都能得到满意的匹配？(稳定) 稳定：不存在一对男女，他们之间相互更喜欢。换言之，不存在一对男人和女人，他们都更喜欢对方而不是他们当前的配偶。 Gale-Shapley Algorithm也叫 Deferred Acceptance 算法 Steps 每个男人都向他的首选求婚 每个女人都暂时选择她当前最喜欢的求婚者，拒绝其他人 每个被拒绝的男人向他的下一个选择求婚 重复步骤 2 和 3，直到每个女人都接受了一个求婚者 Analysis女人在每一轮接受的求婚都是临时的，这就是为什么此算法又叫 Deferred Acceptance 延迟接受 的原因。","link":"/Algorithm/Design-and-Analysis-of-Algorithms/"},{"title":"MSSQL 练习题","text":"最近因为学校的原因，不得不学习 MS SQL 相关内容遂记录一些练习题 首先我们 1234DROP DATABASE IF EXISTS Learn;CREATE DATABASE Learn;USE Learn; Check创建一个 Student 表，有 ID, Name, Semester, City 字段。写一个 SQL，只允许插入第三学期的学生。这意味着用户不能插入第一、第二或第四学期的学生。 Create one Student table where is ID, Name, Semester, City colums.Find the solution that we can insert just the 3rd semester students.This mean that the user connot inser Student who are in 1, 2, or 4th semester. 12345678DROP TABLE IF EXISTS Student;CREATE TABLE Student ( ID INT PRIMARY KEY IDENTITY(1, 1), Semester TINYINT CHECK(Semester = 3) NOT NULL, NAME TEXT NOT NULL, City TEXT NOT NULL,); 去重创建一个方法，对同一 record 进行过滤，并只返回一次。例如，如果我们有 3 个价格为 450 的比萨饼，如果我们 Select，那么结果将是只有 1 个比萨，而不是 3 个比萨。 Create one method, what filtering the same record and give back just once.For example, if we have 3 pizza with 450 price, if we take a Select,then results will be just 1 pizza, not 3 pizza. 1234567891011121314151617181920DROP TABLE IF EXISTS Food;CREATE TABLE Food ( ID INT PRIMARY KEY IDENTITY(1, 1), Name VARCHAR(50) NOT NULL, Price DECIMAL CHECK(Price &gt;= 0) NOT NULL,);INSERT INTO Food Values ('Pizza', 450), ('Pizza', 450), ('Pizza', 450);-- Type 1SELECT MIN(Id), Min(Name), Min(Price) FROM Food GROUP BY Name;-- Type 2SELECT DISTINCT Name, Price FROM Food; 函数创建一个阻止 18 岁以下用户的 function。 Create one function what block the user who are younger as 18 years old. 1234567DROP TABLE IF EXISTS TUser;CREATE TABLE TUser ( ID INT PRIMARY KEY IDENTITY(1, 1), Name VARCHAR(50) UNIQUE NOT NULL, Age TINYINT CHECK(Age &gt;= 0),); 123456789101112131415CREATE OR ALTER FUNCTION IsAdult(@Name VARCHAR(50))RETURNS BITASBEGIN IF EXISTS( SELECT * FROM TUser WHERE Name = @Name And Age &gt;= 18 ) RETURN 1 RETURN 0END 12345INSERT INTO TUser Values('Some', 18)DECLARE @ret BITEXEC @ret = IsAdult 'Some'SELECT @ret 层次化索引 Create one hierarchy index. 12345678910DROP TABLE IF EXISTS HIndex;CREATE TABLE HIndex ( IdPath HIERARCHYID PRIMARY KEY, Sth TEXT)INSERT INTO HIndex VALUES ('/1/', 'Something'), ('/1/1/', 'Somebody') Trigger创建一个触发器，如果产品数量在 10 个以下，则更新价格（+20%）。 Create one trigger what is update the price(+20%)if the products quantity is under 10 pirces. 123456789101112DROP TABLE IF EXISTS Product;CREATE TABLE Product( Id INT PRIMARY KEY IDENTITY, Name VARCHAR(50), Price MONEY, Quantity INT CHECK(Quantity &gt;= 0));INSERT INTO Product VALUES ('Pizza', 1000, 15), ('Bun', 100, 12); 1234567CREATE OR ALTER TRIGGER IncreasePriceOn Product FOR UPDATE ASBEGIN UPDATE Product SET Price = Price * 1.2 WHERE Quantity &lt; 10END; 12UPDATE ProductSET Quantity = 8; 复合主键不是很能理解他到底在说什么，但是答案是复合主键相关 How can we kill the nested loops operator?How can we kill the double I/O problems? 1234567DROP TABLE IF EXISTS Composite;CREATE TABLE Composite( Id INT NOT NULL, Comp INT NOT NULL, CONSTRAINT PK_Composite_Id_Comp PRIMARY KEY (Id, Comp)); 脏读 Create one select what is dirty read. 1234567891011DROP TABLE IF EXISTS Bank;CREATE TABLE Bank( Id INT PRIMARY KEY IDENTITY(1, 1), AccountNum VARCHAR(50), Name VARCHAR(50), Balance MONEY)INSERT INTO Bank VALUES ('SomeAccountNum', 'SomeName', '80'); 123456789BEGIN TRAN; UPDATE Bank SET Balance = Balance - 45 WHERE AccountNum = 'SomeAccountNum'; WAITFOR DELAY '00:00:10';ROLLBACK TRAN;SELECT * FROM BankWHERE AccountNum = 'SomeAccountNum'; 123456-- Dirty ReadSET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;BEGIN TRAN; SELECT * FROM Bank WHERE AccountNum = 'SomeAccountNum';COMMIT TRAN; 或者 12Select Count(*)FROM Bank WITH (NOLOCK) While两个产品。咖啡是 245，披萨是 475。(硬币：20，10，5）如果我们想买这些产品，请计算需要多少硬币。 You have 2 products. The coffee is 245, the pizza is 475. (Coins: 20, 10, 5)Please count how many coins need it if we would like to buy this products. 12345678910111213141516171819202122232425262728293031CREATE OR ALTER PROCEDURE CountCoins(@Price INT)ASBEGINDECLARE @C20 INT, @C10 INT, @C5 INT;SET @C20 = 0;SET @C10 = 0;SET @C5 = 0; WHILE @Price &gt;= 20 SET @Price = @Price - 20 SET @C20 = @C20 + 1 WHILE @Price &gt;= 10 SET @Price = @Price - 10 SET @C10 = @C10 + 1 WHILE @Price &gt;= 5 SET @Price = @Price - 5 SET @C5 = @C5 + 1 PRINT 'It can be paid with ' + TRIM(CAST(@C20 as VARCHAR(50))) + ' 20Coin, ' + TRIM(CAST(@C10 as VARCHAR(50))) + ' 10Coin, ' + TRIM(CAST(@C10 as VARCHAR(50))) + ' 5Coin.'END 聚集索引 Create two cluster index on your table, on the same table but different columns. 123456789DROP TABLE IF EXISTS TTest;CREATE TABLE TTest( Col1 INT NOT NULL, Col2 INT NOT NULL, Col3 VARCHAR(50));CREATE CLUSTERED INDEX IX_TTest_Col1 ON TTest (Col1, Col2); XML导出表到 XML。 Create XML code from your table. 12345678910111213DROP TABLE IF EXISTS TXML;CREATE TABLE TXML( Col1 INT PRIMARY KEY IDENTITY, Col2 VARCHAR(10), Col3 VARCHAR(50));INSERT INTO TXML VALUES ('Some', 'Thing'), ('Body', 'Any');SELECT * FROM TXML FOR XML AUTO; 事务用事务填充表。 Create one table with 900 records. 123456789101112131415161718DROP TABLE IF EXISTS Fill;CREATE TABLE Fill( Id INT PRIMARY KEY IDENTITY, Increse INT);BEGIN TRANDECLARE @index INTSET @index = 0WHILE @index &lt; 900BEGIN INSERT INTO Fill VALUES (@index) SET @index = @index + 1ENDCOMMIT TRAN 用户账户创建新用户并授予其权限。 Create a new account, which log in via system administrator with data reader persmission. 123CREATE LOGIN [DGYY] WITH PASSWORD=N'123', DEFAULT_DATABASE=[master]ALTER SERVER ROLE [sysadmin] ADD MEMBER [DGYY]ALTER ROLE [db_datareader] ADD MEMBER [DGYY] UNION合并多个 SELECT 语句的结果集 How can we use the data of set? 123SELECT NULL FROM SomeTableUNIONSELECT NULL FROM OtherTable; CASE WHEN用 CASE 写一个判断 Create one new table for cars(Id, type, color). After this,select one car from the table and compare this car color onthe next logical statement the car is Black (True, False) Or White. 1234567891011121314151617181920DROP TABLE IF EXISTS Car;CREATE TABLE Car( Id INT PRIMARY KEY IDENTITY, Type VARCHAR(50), Color VARCHAR(50));INSERT INTO Car VALUES ('Audi', 'Black'), ('BMW', 'Red'), ('Suzuki', 'Grey'), ('Aston', 'White');SELECT TOP(1) CASE WHEN Car.Color = 'White' Then 'White' WHEN Car.Color = 'Black' THEN 'True' ELSE 'False' ENDFROM Car OFFSET How can we use the data offset? 123456789101112131415161718192021DROP TABLE IF EXISTS Offset;CREATE TABLE Offset( Id INT PRIMARY KEY IDENTITY, Sth INT);DECLARE @index INTSET @index = 0WHILE @index &lt; 5BEGIN INSERT INTO Offset VALUES(RAND() * 10) SET @index = @index + 1ENDSELECT *FROM OffsetORDER BY IdOFFSET 2 ROWSFETCH NEXT 3 ROWS ONLY; BETWEEN12ALTER TABLE TableNameADD CONSTRAINT CK_Between CHECK (LEN(ColomnName) BETWEEN 1 AND 10) THROW Create one trigger what give for us an error messageif we cannot insert data in the table. 123456789CREATE TRIGGER ErrorTrigger-- 类似 BEFOREON TTest INSTEAD OF INSERT ASBEGIN IF 1 = 1 THROW 60000, 'Error Message!', 1 ;END 表变量12345678910111213DECLARE @TTest TABLE( Col1 INT NOT NULL, Col2 INT NOT NULL, Col3 VARCHAR(50));INSERT INTO @TTest VALUES (1, 2, 'Some'), (3, 4, 'Thing');SELECT * FROM @TTest;DROP TABLE @TTest; 临时表12345678910111213CREATE TABLE #TTest( Col1 INT NOT NULL, Col2 INT NOT NULL, Col3 VARCHAR(50));INSERT INTO #TTest VALUES (5, 6, 'Body'), (7, 8, 'Any');SELECT * FROM #TTest;DROP TABLE #TTest;","link":"/Database/MSSQL/MSSQL-%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"title":"Numerical Methods II - Part 2","text":"时隔一年，老师添加了一点新题，所以又来更新一下。 Numerical Integral, Matrices of Geometrical Transforms近似计算定积分Write an M-file for using quadrature formulas.The name of the function be: numint Input arguments: integrand (as a string),the endpoints of the interval (a, b),number of divisors (n),type of the quadrature (rectangle, trapezoid, simpson) Output argument: the result of the integral. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117% 7.1 近似计算定积分% 积分（字符串）% 区间 (a, b) 的端点% 除数 (n)% 正交类型（矩形、梯形、辛普森形）function integralResult = numint(integrand, b, a, n, method)arguments % 检查integrand是否为字符串 integrand (1,1) string % 检查a和b是否为数值，且a小于b b (1,1) double {mustBeNumeric} a (1,1) double {mustBeNumeric, mustBeLessThan(a, b)} % 检查n是否为正整数 n (1,1) double {mustBeInteger, mustBePositive} % 检查method是否为有效的字符串选项 method (1,1) string {mustBeMember(method, [&quot;rectangle&quot;, &quot;trapezoid&quot;, &quot;simpson&quot;])}end % 将字符串形式的被积函数转换为函数句柄 f = str2func(integrand); % 根据所选的方法计算积分 switch method case 'rectangle' integralResult = rectangleMethod(f, a, b, n); case 'trapezoid' integralResult = trapezoidMethod(f, a, b, n); case 'simpson' integralResult = simpsonMethod(f, a, b, n); otherwise error('Unknown method. Please choose rectangle, trapezoid, or simpson.'); endend% 首先计算每个小区间的宽度 h，然后遍历每个小区间% 计算每个区间中点的函数值，并将所有这些值累加起来% 最后，将累加的和乘以小区间的宽度，得到积分的近似值% 这个方法在处理高度振荡或非常不规则的函数时可能不够精确% 在这种情况下，可能需要更多的区间（即更大的 n）function result = rectangleMethod(f, a, b, n) % 计算每个小区间的宽度 h = (b - a) / n; % 初始化积分结果 integralSum = 0; % 对每个小区间进行迭代 for i = 1:n % 计算当前小区间的中点 x_mid = a + (i - 0.5) * h; % 计算函数在中点的值并累加 integralSum = integralSum + f(x_mid); end % 计算最终的积分近似值 result = h * integralSum;end% 首先计算每个小区间的宽度 h% 然后，我们初始化积分和为区间两端点处函数值的平均值% （这是因为在梯形法中，区间两端的点只被计算一次）% 接着，我们遍历每个小区间的内部点，将这些点处的函数值累加到积分和中% 最后，将累加的和乘以小区间的宽度，得到积分的近似值% 这种方法比矩形法更精确，尤其是在函数比较平滑的情况下% 然而，对于高度振荡或非常不规则的函数，它仍然可能不够精确function result = trapezoidMethod(f, a, b, n) % 计算每个小区间的宽度 h = (b - a) / n; % 初始化积分结果 integralSum = 0.5 * (f(a) + f(b)); % 对每个小区间的内部点进行迭代 for i = 1:(n-1) x = a + i * h; integralSum = integralSum + f(x); end % 计算最终的积分近似值 result = h * integralSum;end% 我们首先确保 n 是一个正的偶数。然后，我们计算每个小区间的宽度 h% 接着，我们初始化积分和为区间两端点处函数值的和% 在遍历每个小区间的内部点时，我们根据这些点是奇数位置还是偶数位置% 分别乘以 4 或 2（这是辛普森法的特点）% 最后，将累加的和乘以 h/3，得到积分的近似值function result = simpsonMethod(f, a, b, n) % 确保n为偶数 if mod(n, 2) ~= 0 error('n must be a positive even integer.'); end % 计算每个小区间的宽度 h = (b - a) / n; % 初始化积分结果 integralSum = f(a) + f(b); % 对每个小区间的内部点进行迭代 for i = 1:n-1 x = a + i * h; if mod(i, 2) == 0 integralSum = integralSum + 2 * f(x); else integralSum = integralSum + 4 * f(x); end end % 计算最终的积分近似值 result = (h / 3) * integralSum;end 原点 affine 变换Write an M-file, what gives the matrix of any affin transform with fixed point in OriginThe name of the file: affin1 Input arguments: The images of points (0, 1) and (1, 0). Output argument: The matrix of the transform. If someone calls the function without input arguments give them an opportunity for the graphical input. 12345678910111213141516171819202122232425262728% 7.2 计算具有原点固定点的 affine 变换矩阵% 输入参数:% imageOf01 - 点 (0, 1) 变换后的图像% imageOf10 - 点 (1, 0) 变换后的图像% 输出参数:% A - 变换的矩阵function A = affin1(imageOf01, imageOf10) if nargin == 0 % 如果没有输入参数，通过图形界面获取输入 disp('请图形化输入点 (0, 1) 和 (1, 0) 变换后的图像'); [x1, y1] = ginput(1); % 获取点 (0, 1) 变换后的图像 [x2, y2] = ginput(1); % 获取点 (1, 0) 变换后的图像 imageOf01 = [x1; y1]; imageOf10 = [x2; y2]; end % 验证输入参数 if ~isequal(size(imageOf01), [2, 1]) || ~isequal(size(imageOf10), [2, 1]) error('输入参数的大小必须是 2x1'); end % 计算 affine 变换矩阵 A = [imageOf10, imageOf01]; % 输出变换矩阵 disp('Affine 变换矩阵为:'); disp(A);end 12% 输入示例A = affin1([2; 3], [4; 1]) 三角变换Write an M-file, what gives the matrix of any affin transform.The name of the m-file: affin2 Input arguments: a triangle (with the coordinates of the edges) and the image of the triangle (also with the edges) Output argument: The matrix of the transform. Give an opportunity for graphical input (as in the previous exercise) Draw a figure in both cases. 123456789101112131415161718192021222324252627282930313233343536% 7.3 计算基于一个三角形及其映射后的三角形的仿射变换矩阵%% 使用方法:% A = affin2(triangle, image_triangle)% 其中 triangle 和 image_triangle 是包含三角形顶点坐标的 3x2 矩阵% 如果没有给出参数，则使用图形输入function A = affin2(triangle, image_triangle) if nargin == 0 % 没有输入参数，使用图形输入 disp('点击以定义原始三角形的顶点：'); triangle = ginput(3); disp('点击以定义映射后三角形的顶点：'); image_triangle = ginput(3); end if size(triangle, 1) ~= 3 || size(image_triangle, 1) ~= 3 error('两个三角形都必须有 3 个顶点。'); end % 构造变换矩阵 % 添加一行 1 以处理仿射变换 T = [triangle, ones(3, 1)]; T_image = [image_triangle, ones(3, 1)]; % 求解变换矩阵 A = T_image' / T'; % 绘制原始三角形和变换后的三角形 figure; plot([triangle(:,1); triangle(1,1)], [triangle(:,2); triangle(1,2)], 'b-o'); hold on; plot([image_triangle(:,1); image_triangle(1,1)], [image_triangle(:,2); image_triangle(1,2)], 'r-o'); legend('原始三角形', '变换后的三角形'); title('三角形的仿射变换'); hold off;end 1234% 输入示例triangle = [0, 0; 1, 0; 0, 1];image_triangle = [2, 3; 4, 1; 5, 5];A = affin2(triangle, image_triangle) 等边三角形Give 3 points in the plane. Two of them, P (2; 3) and Q (4; 2), lie on different sides of an equilateral triangle.The third point, S (3; 3), is the centroid of the triangle.Use MATLAB to find the vertices of a triangle (by adding the coordinates of the vertices) and make an illustration for the exercise. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162% 定义点 P, Q 和 SP = [2, 3];Q = [4, 2];S = [3, 3];% 计算三角形的边长side_length = sqrt((Q(1) - P(1))^2 + (Q(2) - P(2))^2);% 计算外接圆的半径R = side_length / sqrt(3);% 计算三角形的顶点% 我们已经有两个顶点（P 和 Q），我们需要找到第三个顶点（R）% 计算 PQ 的中点mid_PQ = (P + Q) / 2;% 计算中点到质心的向量vec_mid_to_centroid = S - mid_PQ;% 计算 PQ 的垂直向量perpendicular = [vec_mid_to_centroid(2), -vec_mid_to_centroid(1)];% 归一化垂直向量perpendicular = perpendicular / norm(perpendicular);% 计算第三个顶点R_vertex = S + R * perpendicular;% 检查 R_vertex 是否与 S 在 PQ 的同一侧% 如果不是，反转方向if dot(R_vertex - mid_PQ, vec_mid_to_centroid) &lt; 0 R_vertex = S - R * perpendicular;end% 绘制三角形figure;hold on;grid on;axis equal;% 绘制点plot(P(1), P(2), 'ro');plot(Q(1), Q(2), 'ro');plot(S(1), S(2), 'bo');plot(R_vertex(1), R_vertex(2), 'go');% 绘制三角形的边plot([P(1), Q(1)], [P(2), Q(2)], 'r');plot([P(1), R_vertex(1)], [P(2), R_vertex(2)], 'r');plot([Q(1), R_vertex(1)], [Q(2), R_vertex(2)], 'r');% 添加注释text(P(1), P(2), ' P');text(Q(1), Q(2), ' Q');text(S(1), S(2), ' S (质心)');text(R_vertex(1), R_vertex(2), ' R');title('具有顶点 P, Q 和 R 的等边三角形');xlabel('X 轴');ylabel('Y 轴');hold off;","link":"/Math/Matlab/Numerical-Methods-II-1/"},{"title":"Numerical Methods II","text":"很多很好玩的数值方法是 Matlab 苦手，所以很多高血压代码 Machine Numbers机器数转十进制Our first M-file computes the value of a machine number. Let us choose fl1 as name of function and of course as name of the file also.We give a vector as input parameter. The last coordinate of vector gives thecharacteristic of machine number (in tenary numeral system). We store the signedmantissa in the other coordinates. The output argument be the real number what is represented by our machine number. The first bit of mantissa we can use for storing the sign of the number.(Originally this bit is surely 1.) When the number is positive, then the signbit be 0,in case of negative numbers we use 1 as first bit. We don’t have to know the parameters of machine number set for convertingthe number. The length of mantissa can be read from input data. And weassume that the bounds of characteristic are such that our carachteristic be allowed. Before starting computation let us check whether the given data can be amachine number or not. (All but last coordinates are from set {0,1} and last is an integer.) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546% 1. 机器数转十进制% 第一位是正负号% 中间是二进制% 最后一位是指数位function dec = fl1(vector)arguments % 限定输入必须是一维数组 vector (1,:)end isaninteger = @(x) isfinite(x) &amp; x == floor(x); % 判断 最后一位是整数 if ~isaninteger(vector(end)) % 如果不是，将返回值标记为无效 dec = nan; return end % 对数组内容进行验证，起始 到 倒数第二位 for n = vector(1:end-1) % 只能是二进制 if ~(n == 0 || n == 1) dec = nan; return end end % 初始化赋值 dec = 0; % 从 第二位 到 倒数第二位 for n = 2:length(vector)-1 if vector(n) == 1 % 二进制转十进制算法 dec = dec + 1/(2^(n-1)); end end % 位移，应用指数位 dec = dec * 2^vector(end); % 检查正负号 if vector(1) dec = -dec; return endend 在数轴上展示机器数Let us write anothe M-file, called fl2. It displays the elements of a given machinenumber set on the real axis. Compute the number of elements and the followingparameters: M∞, ε0, ε1. (They will be the output arguments of the function) The function waits 3 (integer) number as input.They are the parameters of the set: t, k1, k2. Let us check whether the input parameters are appropriate.(t ∈ N+ and k1, k2 ∈ Z, and of course k1 &lt; k2) For the computation we can call our first function (fl1) The set is symmetric. We can use this property for the faster computation. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859% 1. 在数轴上展示机器数，输出最大最小值，和与1的偏差function [max, min, diff] = fl2(digits, bottomExp, topExp, draw)% M∞, ε0, ε1arguments % 限定它们只能是一位数字 digits (1,1) bottomExp (1,1) topExp (1,1) % 布尔值，可选参数，默认为真 draw (1,1) = 1end isaninteger = @(x) isfinite(x) &amp; x == floor(x); % 最大位数必须大于零 且 是整数 % 低指数 小于或者等于 高指数，同时是整数 if ~(digits &gt; 0 &amp;&amp; isaninteger(digits)) ... || bottomExp &gt; topExp ... || ~isaninteger(bottomExp) ... || ~isaninteger(topExp) max = nan; return end mn = []; % 遍历出全部位数的机器数可能性 % n 从 1 开始枚举 到 最大位数 for n = 1:digits % 括号里面是十进制数组，长度为 2^n % 如 [0, 1, 2, 3]，-1 的原因是从 0 开始 % de2bi 会把数组里面的每一个数都转换成二进制 % 矩阵 m 有 2^n 行 n 列 % 这样写的好处是写起来简单，问题是会产生大量重复内容 m = de2bi(0:(2^n)-1); % 按行遍历矩阵，取出每一个二进制结果 for k = 1:size(m, 1) % 遍历所有的指数大小可能性，同样会产生大量重复内容 for e = bottomExp:topExp % 把二进制结果转换为机器数，并储存 % 这种持续变换矩阵大小的行为效率低下，但是写起来简单 mn = [mn, fl1([0, m(k, :), e])]; end end end % 将所有重复项排除，此方法会自动从小到大排序 mn = unique(mn); max = mn(end); min = mn(1); % 找出 1 的位置，并且取出它的下一位，算出误差 diff = mn(find(mn == 1) + 1) - 1; % 对称 mn = [-mn, mn]; if draw plot(mn, repelem(0, length(mn)), &quot;o&quot;) endend 十进制转机器数The third function finds the machine number what representates the given real number. The name be fl3. The function waits the real number and parameters of set ofmachine numbers (t, k1, k2.) as input. And gives back a vector with t+1 coordinates.The last coordinate be the characteristic and the firs t stores the signedmantissa. (As in case of input argument of function fl1). The first bit of mantissa is the sign-bit as in exercise 1.The value of sign is 0 when number is positive and 1 when it is negative. Check the input arguments whether they are appropriate.And the real number whether can representate in machine number set. (ε0 ≤ |r| ≤ M∞) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667% 1. 十进制转机器数function vector = fl3(digits, bottomExp, topExp, dec) % fl2 自带检查了所以这里就不再重复检查 [max] = fl2(digits, bottomExp, topExp, 0); % min &lt;= dec &lt;= max 防止溢出 if isnan(max) || ~((-max &lt;= dec) &amp;&amp; (dec &lt;= max)) vector = nan; return end sgn = 0; % 记录十进制正负 if sign(dec) == -1 sgn = 1; end % 取十进制绝对值 dec = abs(dec); % 抹掉小数，把整数位转换成二进制 int = fix(dec); bin = []; % 只有整数不为零的情况才需要转换 if int bin = de2bi(int); end % 整数二进制的长度就是未标准化的机器数的指数 % 我们可能得到这样两种情况：111.2222... 和 0.1111... % 只有第一种情况我们需要把整数位全部位移到小数位上 % 这时候就产生了指数位（指数位是可以为零的） power = length(bin); % 0.小数部分 * 2^(1:位数) 再取它 除以二 的余，并且抹掉小数 % 乘2取整，顺序排列，不断的在小数位上乘2 bin = [bin, fix(rem(rem(dec,1) * pow2(1:digits), 2))]; if power % 强行截断超出部分，只留超出的第一位，进行舍零入一 bin = bin(1:digits + 1); end % 是否需要进位 over = 0; % 只有当整数向后位移的情况才可能超出 if power over = bin(end); end % 逆向遍历数组 for n = digits:-1:1 if over % 是 1 则变成 0，继续进位 if bin(n) bin(n) = 0; else % 如果是 0 则 停止进位 bin(n) = 1; over = 0; end else break end end % 我们不需要考虑溢出的情况，因为最开始就已经检查过范围了 vector = [sgn, bin(1:digits), power];end 机器数相加Let us write a function for addition between machine numbers. Let us call the file to fl4. It waits for two vectors as input. (They are representatethe machine numbers as before). The output be a vector with the machine number of the sum. Use machine-addition. The double conversion is not acceptable. (To computethe real numbers belongs to inputs, summing them and reconverting tomachin number is not allowed.) Check the inputs. (They have to have same length and have to be machine numbers) If one of the numbers is negative (the first bit is 1) then in real the operationis a substraction. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596% 1. 机器数相加function vector = fl4(a, b)arguments a (1,:) b (1,:)end % 检查合法性，但是并没有检查完整 if ~isvector(a) || ~isvector(b) || length(a) ~= length(b) vector = nan; return end % 取出两个的指数位 ac = a(end); bc = b(end); % 目标指数 char = ac; % 取出两个的二进制数据 abin = a(2:end - 1); bbin = b(2:end - 1); % 二进制长度 len = length(abin); % 如果两个指数不相等 if ac ~= bc diff = ac - bc; if ac &gt; bc % align % A 大所以扩大 B for n = 1:diff bbin = [0, bbin]; end bbin = bbin(1:len); else for n = 1:-diff abin = [0, abin]; end % 目标指数转为大的那个 char = bc; abin = abin(1:len); end end % fliplr 将数组从左向右翻转 % 当使用 bi2de 或者 de2bi 时 % 第一位是 least significant bit 最低有效位 % 最后一位是 most significant bit 最高有效位 % 所以是小端序的，我们必须反转它 ad = bi2de(fliplr(abin)); bd = bi2de(fliplr(bbin)); % 处理符号 if a(end - 1) ad = -ad; end if b(end - 1) bd = -bd; end % 相加并转回二进制 dres = ad + bd; bin = fliplr(de2bi(abs(dres))); % 新结果与原始数据长度差 dlen = length(bin) - len; % 增加指数位 char = char + dlen; if length(bin) &gt; len % 如果太长了就截断，我们不改变机器数的长度 bin = bin(1:len); elseif length(bin) &lt; len % 如果不足，就在后面补 0 for n = 1:-dlen bin = [bin, 0]; end end % 处理符号 sgn = 0; if sign(dres) == -1 sgn = 1; end % 基本上只是简单实现了两个机器数的加减 % 没有判断两个输入的合法性 % 也没有判断是否溢出 % 而且实际还用的是十进制加减 % 总的来说不是很合格 vector = [bin, sgn, char];end Gaussian Elimination计算高斯消去Write an M-file to compute Gaussian Elimination.The name of the file be gaussel1 Input parameters: the coefficient matrix (A) and the right-side vector (b) of LES. Output argument: the solution vector x Use the Matlab row-operations for organisation of algorithm. If GE can’t be solved without row or coloumn swap write an error messageand terminate the program. In case of underdetermined LES give a base solution and warn the user of this. In case the user asked it, display the matrices A(i) during computation. To checking our function we can use the exercises from numerical I. +1 We can prepare our function to accept LES with multiple right sides. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384% 2. 计算高斯消去function x = gaussel1(A, b, display)arguments A % 右向量，只能有一列 b (:,1) display (1,1) = 0end [ARow, ACol] = size(A); BRow = size(b, 1); if ~ismatrix(A) || ARow ~= BRow error(&quot;ValidationException&quot;); end % 方程个数小于未知量个数的方程组 % 此时有无穷多组解，展示一个基本解 if(ARow &lt; ACol) warning('A is underdetermined, the basic solution with at most m nonzero components is') disp(A\\b) % 超定是方程个数大于未知量个数的方程组，且列满秩 % 一般是不存在解的矛盾方程，只能求一个最接近的解 elseif(ARow &gt; ACol &amp;&amp; rank(A) == ACol) % 显示一个使用最小二乘法，且 norm(A*x-b) &amp; norm(x) 最小 % 线性方程的最小范数最小二乘解，指示它是离原点最近的解，但仍然进行GJ warning('A is overdetermined, the minimum norm least-squares solution is') disp(lsqminnorm(A, b)) end M = [A, b]; [rows, cols] = size(M); % 主元容差，主要是为了控制精度问题，如 magic(4) % https://ww2.mathworks.cn/help/matlab/ref/rref.html#mw_5f53d9c8-72e8-42cc-bda8-ef84cf56ba93 tolerance = eps * max(rows, cols) * norm(M, inf); % Gauss-Jordan r = 1; for c = 1:cols % 找出当前列中，绝对值最大的数字，及其所在的行 % 使用部分主元消去法可减少（但会不消除）计算中的舍入误差 % 主元位置：行中最左边的非零元素 [num, target] = max(abs(M(r:end, c))); % 加上 r 的原因是因为上面 max 判断的是被截断的矩阵 target = r + target - 1; if (num &lt;= tolerance) % 跳过当前列，将近似零的项直接变成零 % 这可以防止使用小于容差的非零主元元素进行运算 M(r:end, c) = zeros(rows - r + 1, 1); if display disp(M) end else % 交换最大行与当前行 M([target, r], c:end) = M([r, target], c:end); if display disp(M) end % 标准化最大行（把主元变成1） M(r, c:end) = M(r, c:end) / M(r, c); if display disp(M) end % 消除当前的列（消元），但是要除开当前行 erow = [1:r - 1, r + 1:rows]; M(erow, c:end) = M(erow, c:end) - M(erow, c) * M(r, c:cols); if display disp(M) end % 检查是否完成行遍历 if (r == rows) break; end r = r + 1; end end x = M(:, end);end Whole PivotingExtend the previous m-file (but save as a new name for example gaussel2) withsteps of partial and whole pivoting method. Using partial or whole pivoting could be choosen by user(for example according to a boolean input parameter), but if the partial pivoting is stuckedthen automatically switch to whole pivoting method. If we used whole pivoting despite user has choosen partial pivoting, then inform user about the switch Give an opportunity for displaying matrices A(i) during computation. Don’tforget that pivoting method can be changed the matrix so we have to displayit after row and coloumn swap. Don’t forget that the pivoting method can be changed the solution. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869% 2. 完全交换，注释看前面一个function x = gaussel2(A, b, display)arguments A b (:,1) display (1,1) = 0end M = [A, b]; [rows, cols] = size(M); xOrd=(1:length(b))'; tolerance = eps * max(rows, cols) * norm(M, inf); % Whole Pivoting r = 1; for c = 1:cols - 1 % 找出行列最大值 [maxc, rowI] = max(abs(M(r:end, c:end - 1))); [num, colI] = max(maxc); row = rowI(colI) + c - 1; col = colI + c - 1; if (num &lt;= tolerance) M(r:end, c) = zeros(rows - r + 1, 1); if display disp(M) end else % 交换列 M(r:end, [col, c]) = M(r:end, [c, col]); if display disp(M) end % 交换行 M([row, r], c:end) = M([r, row], c:end); if display disp(M) end % 交换X oldOrd = xOrd(c); xOrd(c) = xOrd(col); xOrd(col) = oldOrd; % 标准化 M(r, c:end) = M(r, c:end) / M(r, c); if display disp(M) end % 消元 erow = [1:r - 1, r + 1:rows]; M(erow, c:end) = M(erow, c:end) - M(erow, c) * M(r, c:cols); if display disp(M) end if (r == rows) break; end r = r + 1; end end % 调换回正常顺序 x = M(xOrd, end);end 求逆矩阵Apply Gaussian elimantion for computing inverse of an square matrix.The name of function: gaussel3 Check input argument(s) before computing Compute the determinant of matrix.If you have written the function gaussel1 such that it accepts multipleright-sides, then you can call it during computation. 12345678910111213141516171819202122232425262728293031323334353637383940414243% 2. 求逆矩阵function x = gaussel3(A) [row, col] = size(A); if row ~= col error(&quot;A is not a square matrix&quot;) end % 判断是否是奇异矩阵，如果是则不可逆 if det(A) == 0 warning(&quot;A is singular matrix&quot;) end A = [A, eye(row)]; for c = 1:row % 在消元操作之前选择一个最大的元素作为主元 % 这样可以避免主元为零的情况，从而提高精度 [~, maxI] = max(abs(A(c:row, c))); % 得到原来矩阵A中的行索引 maxI = maxI + c - 1; % 将矩阵A的第maxI行作为主元行，并将主元行转化为单位矩阵 % （主元行中的第c个元素是1，其余元素都是0） % 这样一来，矩阵A的第maxI行就成为了消元的基准行 % 在后续的消元操作中，其他行都需要根据这一行进行消元 A(maxI, :) = A(maxI, :) / A(maxI, c); temp = A(c, :); % 将矩阵A的主元行移动到第c行，使得在后续的消元操作中 % 只需要对矩阵A的第c行以下的部分进行消元 A(c, :) = A(maxI, :); A(maxI, :) = temp; for j = 1:row if(j ~= c) % 消元操作，使得矩阵A的第j行的第c个元素变为0 A(j, :) = A(j, :) - A(j, c) * A(c, :); end end end x = A(:, row + 1:size(A, 2));end QR-decompositionGram-SchmidtWrite an M-file for QR-decomposition using Gram-Schmidt orthogonalization. Letus call the function to: gramschmidt Input parameter: a square matrix (A) Output arguments: an orthogonal matrix (Q) and an upper triangular matrix (R),such that satisfy A = Q·R To check existence of decomposition (the columns of A have to be linearindependent) we can use any included function of Matlab. The included functions can be used for computing norms,but we can compute via definition also. 123456789101112131415161718192021222324252627282930313233343536373839404142434445% 3. Gram-Schmidt正交法% 选择一组线性无关的向量。然后通过计算每个向量与之前所有向量的投影% 并将这些投影从原始向量中减去，来逐步构造出一组正交向量% 1. 对于矩阵A的每一列，计算该列向量在之前处理的所有基向量上的投影分量% 2. 减去投影分量，得到一个正交化的基向量% 3. 更新正交矩阵Q和上三角矩阵Rfunction [Q, R] = gramschmidt(A) [m, n] = size(A); if (m ~= n) error(&quot;A should be a square matix&quot;) end if (rank(A) ~= size(A, 2)) % 加了这个 magic 就过不了了 warning(&quot;the columns of A have to be linear independent&quot;) end Q = zeros(m); R = zeros(m); % 从最左侧的列向量向右 for col = 1:n a = A(:, col); q = a; % 减去 A 中当前列向量在之前已找到的基向量上的投影分量 for b = 1:col-1 % 计算给定列向量a在已处理的基向量Q的第b列上的投影分量 r = Q(:, b)' * a; % 减去当前列向量在之前处理的基向量上的投影分量 q = q - r * Q(:, b); % 记录对应 R 矩阵中的元素值 R(b, col) = r; end % 对当前基向量进行正交化 q = q / norm(q); % 更新结果 Q(:, col) = q; R(col, col) = a' * q; endend HouseholderWrite an M-file to give the matrix of a Householder transformation, from a knownpoint and its image. The name of function let be: householder Input parameters: the coordinatas of the point and its image (P, P’) PointP (and ofcourse P’ also) can be from Rn where n is not predetermined. Output argument: the matrix of Householder-transformation Take care of choosing sign during transformation (the parameter σ effectsthe stability of the method) 123456789101112131415161718% 3. Householder 变换主要就是那个公式，没有什么别的function H = householder(P, Prem)arguments P (:,1) Prem (:,1) % P'end % 解题参考 NumSampleTest1SolutionsP1 213 if (size(P) ~= size(Prem)) error(&quot;Size P not equal to Size ImgP&quot;) end u = P - Prem; v = u / norm(u); % H(v) = I - 2 * v * v' H = eye(size(P, 1)) - 2 * (v * v');end 点映射The third function will asking data via graphical input. (It works for 2D points)Display points and the hyperspace of reflection. Ask for another point (also viagraphical input) and apply the transformation to the new point. The functionhouseholder can be called during the algorithm.the name of function: hhgraph 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172% 3. 交互点映射function hhgraph() clf; hold on; ax = gca; ax.XAxisLocation = &quot;origin&quot;; ax.YAxisLocation = &quot;origin&quot;; button = questdlg(&quot;Click a point&quot;, &quot;First Step&quot;, &quot;OK&quot;, &quot;Cancel&quot;, &quot;OK&quot;); if strcmpi(button, &quot;Cancel&quot;) return; end [PointX, PointY] = ginput(1); plot(PointX, PointY, &quot;rd&quot;) R = distance(PointX, PointY, 0, 0); viscircles([0, 0], R); button = questdlg(&quot;Click another point&quot;, &quot;Second Step&quot;, &quot;OK&quot;, &quot;Cancel&quot;, &quot;OK&quot;); if strcmpi(button, &quot;Cancel&quot;) return; end [PointX2, PointY2] = ginput(1); plot(PointX2, PointY2, &quot;rd&quot;) syms x y u; % 圆的标准方程 c = x ^ 2 + y ^ 2 - R ^ 2; % 计算点 (x,y) 到第二个点（PointX2,PointY2）之间的欧几里得距离 d = (x - PointX2) ^ 2 + (y - PointY2) ^ 2; % 求出第二个点（PointX2,PointY2）在反射变换后的位置，以确定反射变换矩阵 H h = d + u * c; % 前两个参数表示 h 关于 x 和 y 的一阶导数，它们用来求解 h 关于 x 和 y 的根 % 这些根是 h 关于 x 和 y 的极值点，它们决定了反射变换后第二个点的位置 % 第三个参数表示 h 关于 u 的一阶导数，它用来求解 h 关于 u 的根 % 这个根是 h 关于 u 的极值点，它决定了反射变换矩阵 H 的值 res = solve(diff(h, x) == 0, diff(h, y) == 0, diff(h, u) == 0); x = res.x; y = res.y; % 它们的值分别是第二个点反射变换后的两个可能位置与原点之间的欧几里得距离 d1 = (x(1) - PointX2) ^ 2 + (y(1) - PointY2) ^ 2; d2 = (x(2) - PointX2) ^ 2 + (y(2) - PointY2) ^ 2; % 选择更小的那一个作为反射变换后第二个点的位置 % 反射变换后第二个点的最终位置应该是离原点最近的那一个 if (d1 &lt;= d2) PointX2 = x(1); PointY2 = y(1); else PointX2 = x(2); PointY2 = y(2); end plot(PointX2, PointY2, &quot;rd&quot;) H = householder([PointX, PointY]', [PointX2, PointY2]'); button = questdlg(&quot;Click new point&quot;, &quot;Third Step&quot;, &quot;OK&quot;, &quot;Cancel&quot;, &quot;OK&quot;); if strcmpi(button, &quot;Cancel&quot;) return; end [PointX3, PointY3] = ginput(1); plot(PointX3, PointY3, &quot;rd&quot;) res = (H * [PointX3, PointY3]')'; plot(res(1), res(2), &quot;rd&quot;)end Householder QR 分解Write an M-filet to realize QR-decomposition with Householder algorithm. Letus call our function to: hhalg Input parameter: a square matrix (A) Output arguments: an orthogonal matrix (Q) and an upper triangular matrix (R),such that satisfy A = Q·R The previous functions can be called. 1234567891011121314151617181920212223242526272829303132333435363738394041424344% Householder QR 分解function [Q, R] = hhalg(A) [m, n] = size(A); if (m ~= n) error(&quot;A should be a square matix&quot;) end % 预分配，减少动态内存分配，提高性能 % 反射变换矩阵、正交矩阵和上三角矩阵 H = eye(m); Q = eye(m); R = A; for col = 1:n % x = aₖ x = R(col:m, col); % 跳过已满足条件不需要反射的部分 % 非零矩阵元素的数目 % 这是因为反射变换的作用是将向量 x 的第一个元素变为正数 if ~nnz(x(2:end)) continue end % v = aₖ - βeₖ，其中 eₖ 为单位正交基 v = x; % β=‖x‖取值保持与x(1)一致，β 是向量 x 的模长 v(1) = v(1) + sign(x(1)) * norm(x); v = v / v(1); % 反射变换：I - 2*u*conj(u) 可整理得下式 % 随着逐列推进，Householder 反射变换部分占右下部分越来越小 % (v * v') / (v' * v) 表示反射变换矩阵 H 的右下角部分 h = eye(m - col + 1) - 2 * (v * v') / (v' * v); H(col:m, col:m) = h; % 使用反射变换矩阵 H 更新正交矩阵 Q 和上三角矩阵 R R = H * R; Q = Q * H'; % 将预分配的内存重置 H(col:m, col:m) = eye(m - col + 1); endend Iterative solutions of LESJacobi 迭代Write an M-file for Jacobi iteration. The file name be: jacobi Input parameters: The matrix of LES A and a vector for the right-side: b Output argument: the approximation of the solution vector: x We can use the vectorial form of the iteration 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778% 4. Jacobi迭代function [x, k, index] = jacobi(A, b, ep, itMax)arguments A b (:,1) ep (1,1) = 1e-5 itMax (1,1) = 100end % 求线性方程组的雅可比迭代法，其中， % A为方程组的系数矩阵； % b为方程组的右端项; % ep为精度要求，缺省值为1e-5; % itMax 为最大迭代次数，缺省值为100; % x为方程组的解; % k为迭代次数; [row, col] = size(A); bRow = length(b); %当方程组行与列的维数不相等时，停止计算，并输出出错信息。 if row ~= col error('The rows and columns of matrix A must be equal'); end % 当方程组与右端项的维数不匹配时，停止计算，并输出出错信息。 if col ~= bRow error('The columns of A must be equal the length of b'); end % 迭代次数 k = 0; % 上一次迭代的结果 x = zeros(row, 1); % 当前迭代的结果 y = zeros(row, 1); % index为指标变量，index=0表示迭代失败，index=1表示收敛到指定要求 index = 1; % A = U + L + D % Ax = b % (U + L + D)x = b % Dx = -(U + L)x + b % Dx = -(A - D)x + b % x = -D^-1 * (U + L) * x + D^-1 * b % x(k+1) = Bj x(k) + cj % Bj = -D^-1 (L + U) % cj = D^-1 * b while 1 for r = 1:row y(r) = b(r); for j = 1:row if j ~= r % 用当前的 x 来更新 y y(r) = y(r) - A(r, j) * x(j); end end % A 中第 r 行第 r 列的元素过小，导致无法更新 y，无法进行下一次迭代 if abs(A(r, r)) &lt; 1e-10 &amp;&amp; k == itMax index = 0; return; end % 更新迭代解 y(r) = y(r) / A(r, r); end k = k + 1; if norm(y - x, inf) &lt; ep break; end x = y; endend Gauss SeidelWrite an M-file for Gauss-Seidel iteration. The file name be: gaussseid As in previously at Jacobi iteration. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455% 4. 用 Gauss Seidel 迭代法解线性方程组 Ax=b% A为方程组的系数矩阵% b为方程组的右端项%epsilon：近似解的误差%Max：迭代的最大次数function x = gaussseid(A, b, epsilon, Max)arguments A b (:,1) epsilon (1,1) = 1e-5 Max (1,1) = 1000end [row, col] = size(A); bRow = length(b); %当方程组行与列的维数不相等 if row ~= col error('The rows and columns of matrix A must be equal'); end % 当方程组与右端项的维数不匹配 if col ~= bRow error('The columns of A must be equal the length of b'); end %迭代初始值 x = zeros(bRow, 1); %diag(A)是取出对角元的向量，对该向量再作用diag()函数表示以该对角元向量生成对角矩阵 D = diag(diag(A)); %将矩阵分裂为A=D-L-U %下三角 L = -tril(A, -1); %上三角 U = -triu(A, 1); %G-S迭代法的迭代公式 Xk+1 = (D-L)^(-1) * U * Xk + (D - L)^(-1) * b B = (D-L) \\ U; g = (D-L) \\ b; %开始迭代Xk+1 = B * x + g %最大迭代次数 for k=1:Max %计算Xk+1用y存放 y=B*x + g; %相邻两次迭代之间相差小于阈值 if norm(x-y) &lt; epsilon break; end %存放单步结果用于判断收敛 x = y; endend Iterative solution of non-linear equations, Interpolation二分法Write an m-file for bisection method and call the file: bisect Input arguments: the function f (we want to find one of the zeros). Give itas a string (the variable can be denoted by x or we can give the notationas another parameter. We will need the ends of the starting interval (a, b),the number of steps (n). Output arguments: the appropriate approximation of root: x^∗and the error estimation ε. Before start we have to check the interval (is there a root inside?) To evaluate function we can use function eval 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162% 5. 二分法% x 根% tolerance 迭代误差function [x, tolerance] = bisect(f, a, b, k_max)arguments % 一元标量函数 如 f = @(x) x^2-1 f (1,1) function_handle % 起始区间 a (1,1) % 结束区间 b (1,1) % 最大迭代数 k_max (1,1) = 200end % 第一次迭代的 root 估计 % 接下来会持续更新 c 也就是每一次迭代的值 c = (a + b) / 2; % 如果是f(x)的根，直接返回根的估计值 if f(c) == 0 x = c; return end % 第一次迭代时，函数在左区间和中点的值 % 同样，这两个值在接下来会持续更新 fa = f(a); fc = f(c); % bisection iteration for k = 1:k_max % 为 0 就是已经找到根了 if fc == 0 break; % 两个y相乘为正就说明还在x轴上方 elseif (fa * fc &gt; 0) % 向右收敛 a = c; % 无需重复计算 fa = fc; else % 如果小于零就说明有一个y在x轴下方了 % 这时向左收敛 b = c; end % 更新区间中点（估计的根） c = (a + b) / 2; % 更新 y 轴结果 fc = f(c); end % 结果 x = c; % 误差 tolerance = b - a;end Least Squares Method, Generalised inverse最小二乘法Write an m-file for approximation with least squares method.The name of file: lsmapprox Input arguments: order of polynomial (n), nodes of approximation (in avector), vector of function values in nodes Output argument(s): the coefficients of the polynomial Let us draw a picture to illustrate the approximation. (We can use theincluded function polyval) 12345678910111213141516171819202122232425262728293031323334353637383940414243% 6. 最小二乘法计算拟合多项式系数% Polynomial curve fitting% 返回 p 向量保存多项式系数，由最高次向最低次排列function p = lsmapprox(x, y, n)arguments % x，y为拟合数据向量 x y % 拟合多项式次数 % 如 1 为 一次函数 n (1,1)end if ~isequal(size(x), size(y)) error(&quot;x, y require the same dimensionality&quot;) end % 但实际上我们需要的是列向量 x = x(:); y = y(:); % 使用一维向量 x 构造具有 n + 1 列 和 m = length(x) 行 的 % 范德蒙（Vandermonde）矩阵 V = [x^n ... x^2 x ones(size(x))] % p(x) = p1·x^n + p2·x^(n-1) + ... pn·x + pn + 1 V(:, n + 1) = ones(length(x), 1, class(x)); for j = n:-1:1 % TIMES (.*) 执行按元素相乘 V(:, j) = x .* V(:, j + 1); end % 然后我们把 V 进行 QR 分解，然后再使用 \\ 除法进行求解，随后得到多项式系数p [Q, R] = qr(V, 0); % p = V\\y p = R \\ (Q' * y); % 返回行向量 p = p'; % 绘图 y1 = polyval(p, x); plot(x, y, 'o', x, y1, '-')end 广义逆矩阵Write an m-file to find the generalised inverse of a given matrix.The name of file: geninv Input argument: the matrix (A). Output argument: The generalised inverse (A+) Use the rank factorisation if the matrix is not fullranked. For the matrixoperations we can use the included functions of Matlab (eg.: rank, inv,instead of solving LES we can use the command G=F\\A, etc.) 123456789101112131415161718192021% 6. 求矩阵的广义逆矩阵% 当 A 不是 fullranked （列满秩）的时候，逆不唯一% A ∈ C^(m * n) 若存在 C 满足 AXA = A XAX = X 则 X 是 A 的广义逆矩阵function APlus = geninv(A) r = rank(A); % 如果 A 不是 fullranked，则使用 秩分解 % rank factorization 来计算GINV if r == size(A, 1) % Moore-Penrose 伪逆 APlus = pinv(A); else % A = U * S * V' % 奇异值分解得到的矩阵 U、奇异值矩阵 S 和 V 的转置矩阵 [U,S,V] = svd(A); SPlus = zeros(size(A)); % 将 S 的逆矩阵插入到秩分解中 SPlus(1:r, 1:r) = inv(S(1:r, 1:r)); APlus = V * SPlus * U'; endend","link":"/Math/Matlab/Numerical-Methods-II/"},{"title":"OpenStack 学习日记 | 第一天","text":"由于本人最近需要从事 OpenStack 相关工作，所以急需对 OpenStack 进行学习本系列日记仅作为本人的学习记录学习材料为 《每天 5 分钟玩转 OpenStack》 学习前需要知道的OpenStack 涉及的范围广计算，储存，网络，虚拟化，可用性，安全性，灾备等一些列关于 IT 基础设施的范围 OpenStack 都有涵盖 OpenStack 是一个平台它的各个组件都采用了 Driver 架构，支持各种的具体实现。比如 OpenStack 储存服务 Cinder 只定义抽象 API，而具体实现交给具体的 Driver比如基于 LVM 的 iSCSI， EMC，或者开源的 Ceph，GlusterFS 等等 这里我们可以类比到 Entity Framework，它只定义了上层的 API而具体的数据库操作交给了你指定的 Driver，如 Npgsql OpenStack 是一个分布式系统这也是学习它的比较大的阻碍，因为它原生就是分布式的，各个组件拆的很散不过我们学习的时候都使用 All-in-one 部署模式 我们要学习的内容 预备知识 虚拟化 云计算 核心组件 架构 认证 Keystone 镜像 Glance 计算 Nova 储存 Cinder 网络 Neutron 写在最前面 – 每天 5 分钟玩转 OpenStack（1） 虚拟化虚拟化是云计算的基础虚拟机(Guest)共享物理机(Host)的资源，比如 CPU，内存，硬盘，网络，磁盘等 这主要通过 Hypervisor 来实现，比如 KVM，Xen，VMWare 等等 1 类虚拟化Hypervisor 是一个操作系统，直接安装在物理机上最典型的就是 Windows 上的 Hyper-V其他的还有 Xen 和 ESXi 2 类虚拟化Hypervisor 作为操作系统中的一个程序或者模块运行最典型的有 KVM 和 VMware Workstation 对比理论上讲，1 类虚拟化性能比 2 类的要好而 2 类虚拟化会更灵活，比如支持嵌套虚拟化 KVM对我来说 KVM 已经是一个听过无数次的词了OpenStack 对 KVM 的支持最好，全称叫 Kernel-based Virtual Machine也就是说它基于 Linux 的内核实现，它有一个模块叫 kvm.ko，只用于管理虚拟 CPU 和内存 那我们就要问了，那 IO 虚拟化呢，这个交给 Linux 内核与 QEMU 实现 Libvirt这是 KVM 的管理工具，包含三个模块后台 daemon，api 库，和 命令行工具 virshvirsh 和 virt-manager 是一定要会用的 虚拟化 – 每天 5 分钟玩转 OpenStack（2） 安装我们使用 Ubuntu，安装 KVM 需要的包 1sudo apt install qemu-kvm qemu-system libvirt-bin virt-manager bridge-util qemu-kvm 和 qemu-system 是 KVM 和 QEMU 的核心包，提供 CPU、内存和 IO 虚拟化功能 libvirt-bin 就是 libvirt，用于管理 KVM 等 Hypervisor virt-manager 是 KVM 图形化管理工具 bridge-utils 和 vlan，主要是网络虚拟化需要，KVM 网络虚拟化的实现是基于 linux-bridge 和 VLAN 准备 KVM 实验环境 – 每天 5 分钟玩转 OpenStack（3） 对于我自己来说，使用 KVM 等本来就是轻车熟路了，所以我跳过这一部分 启动第一个 KVM 虚机 – 每天 5 分钟玩转 OpenStack（4） 远程管理 KVM 虚机 – 每天 5 分钟玩转 OpenStack（5） CPU 虚拟化KVM 虚拟机 在宿主机中其实是一个 QEMU-KVM 进程，与其他进程一同被调度虚拟中的每一个 vCPU 就对应 QEMU-KVM 进程中的一个 线程 这就表明 vCPU 的总数可以超过物理机的 CPU 总数，这叫 CPU OverCommit 超配这个特性让虚拟机能充分利用宿主机的 CPU 资源，但是这也导致了 VPS 中令人诟病的超售行为 内存虚拟化这一段算是我看的比较迷糊的一段不过说到底也不需要了解多少，只需要知道它并不是像一个普通程序那样分配内存即可中间存在大量的内存地址转换，各个厂家也为了转换效率做了很多特殊的优化Guest Virtual Address -&gt; Guest Physical Address -&gt;Host Virtual Address -&gt; Host Physical Address 内存也是可以超配的，所以超售机一大堆 CPU 和内存虚拟化原理 – 每天 5 分钟玩转 OpenStack（6） 储存虚拟化目录类型文件目录类型是最常用的KVM 将宿主机目录 /var/lib/libvirt/images/ 作为默认的 Storage Pool 这个目录下面的每一个文件就是一个 Volume说白了就是用文件来当磁盘，我们最常用的方式存储方便、移植性好、可复制、可远程访问KVM 支持 raw, qcow2, qed, vmdk, vdl 格式的磁盘文件 KVM 存储虚拟化 – 每天 5 分钟玩转 OpenStack（7） LVM 类型这个用的不多，也就是把实际的磁盘划出来给虚拟机用，跳过 LVM 类型的 Storage Pool – 每天 5 分钟玩转 OpenStack（8） 网络虚拟化这章是虚拟化中最复杂，最重要的部分 Linux Bridge其实就是网桥，用来做 TCP/IP 二层协议交换的模块对于我来说这玩意接触的也比较多 KVM 网络虚拟化基础 – 每天 5 分钟玩转 OpenStack（9） 这里记录几个重点 修改 /etc/network/interfaces 以配置网桥 使用 ifconfig 查看 IP 配置 brctl show 查看当前 Linux Bridge 的配置 动手实践虚拟网络 – 每天 5 分钟玩转 OpenStack（10） virbr0virbr0 是 KVM 默认创建的一个 Bridge，其作用是为连接其上的虚机网卡提供 NAT 访问外网的功能。virbr0 默认分配了一个 IP 192.168.122.1，并为连接其上的其他虚拟网卡提供 DHCP 服务。这没啥好难的就是一个 NAT 网关而已 理解 Virbr0 – 每天 5 分钟玩转 OpenStack（11） VLAN也就是虚拟局域网，隔离用，二层交换机，不需要想的太复杂在一张网卡下面划分多个空间而已 Linux 如何实现 VLAN – 每天 5 分钟玩转 OpenStack（12） 具体如何配置就等到要用的时候现查不过还是修改 /etc/network/interfaces 动手实践 Linux VLAN – 每天 5 分钟玩转 OpenStack（13） 云计算 IaaS（Infrastructure as a Service）提供的服务是虚拟机典型的有 AWS，OpenStack 等 PaaS（Platform as a Service）提供的服务是应用的运行环境比如 Github Pages SaaS（Software as a Service）提供的是应用服务对象通常是最终用户，就像 Gmail OpenStack is a cloud operating system that controls large pools of compute, storage,and networking resources throughout a datacenter, all managed through a dashboard that gives administrators control while empowering their users to provision resources through a web interface. OpenStack 对数据中心的计算、存储和网络资源进行统一管理 云计算与 OpenStack – 每天 5 分钟玩转 OpenStack（14） OpenStack写日记的时候最新版本是 Yoga，下一个版本是 Zed 首先列出模块列表 名称 用途 中文 cyborg Accelerator Life Cycle Management 用于管理硬件和软件加速资源（如 GPU）的框架 freezer Backup, Restore, and Disaster Recovery service 备份、恢复和灾难恢复服务 ironic Bare Metal service 裸机服务 cinder Block Storage service 存储服务 ceilometer Data collection service 数据收集服务 kuryr Bridge between container framework and OpenStack abstractions 容器框架和 OpenStack 抽象之间的桥梁 keystone Identity Service 管理身份验证、服务规则和服务令牌功能 senlin Clustering service 集群服务 storlets Compute inside Object Storage service 对象存储服务中的计算 nova Compute service 计算服务，管理 VM 的生命周期 neutron network connectivity as a service 网络连接服务，负责创建和管理 L2、L3 网络， 为 VM 提供虚拟网络和物理网络连接 zun Containers service 容器服务 horizon Dashboard 仪表盘 designate DNS service DNS 服务 ec2-api EC2 API compatibility layer EC2 API 兼容层 glance Image service 启动镜像服务 watcher Infrastructure Optimization service 基础设施优化服务 masakari Instances High Availability Service 实例高可用性服务 barbican Key Manager service 密钥管理器服务 octavia Load-balancer service 负载均衡器服务 neutron Networking service 网络服务 tacker NFV Orchestration service NFV 管理器，用于监视、配置 NFV 和管理 NFV 全生命周期 swift Object Storage service 对象存储服务 heat Orchestration service REST 服务，能够基于一个声明式的模板，通过装配引擎装配组合若干个云应用 placement Placement service REST API 堆栈和数据模型，用于跟踪资源提供程序的清单和使用情况，以及不同的资源类别 cloudkitty Rating service 计费服务 vitrage RCA (Root Cause Analysis) service 用于组织、分析和扩展 OpenStack 的告警和事件 blazar Resource reservation service 资源保留服务 manila Shared File Systems service 共享文件系统服务 aodh Telemetry Alarming services 遥测报警服务 ceilometer Telemetry Data Collection service 遥测数据采集服务 https://www.openstack.org/software/project-navigator/这么一大堆模块一时半会肯定是学不完的，我们挑重点学习搞清楚 OpenStack 是图和对计算，网络，储存资源进行管理的 核心组件 Nova 管理计算资源，是核心服务。 Neutron 管理网络资源，是核心服务。 Glance 为 VM 提供 OS 镜像，属于存储范畴，是核心服务。 Cinder 提供块存储，VM 怎么也得需要数据盘吧，是核心服务。 Swift 提供对象存储，不是必须的，是可选服务。 Keystone 认证服务，没它 OpenStack 转不起来，是核心服务。 Ceilometer 监控服务，不是必须的，可选服务。 Horizon 大家都需要一个操作界面吧。 OpenStack 本身是一个分布式系统，不但各个服务可以分布部署，服务中的组件也可以分布部署这也使得 OpenStack 比一般系统复杂，学习难度也更大 OpenStack 架构 – 每天 5 分钟玩转 OpenStack（15） 搭建 Dev 环境我一般使用 MicroStack 一键解决 搭建 OpenStack 实验环境 – 每天 5 分钟玩转 OpenStack（16） 部署 DevStack – 每天 5 分钟玩转 OpenStack（17） Keystone对于天天跟 OAuth 打交道的我这部分其实可以跳过 Authentication 解决的是“你是谁？”的问题 Authorization 解决的是“你能干什么？”的问题 Keystone 负责管理和维护每个 Service 的 Endpoint Service 通过 Endpoint 暴露自己的 API 理解 Keystone 核心概念 – 每天 5 分钟玩转 OpenStack（18） 通过例子学习 Keystone – 每天 5 分钟玩转 OpenStack（19） Glance这玩意还储存快照 Glance 支持多种 backend，包括 A directory on a local file system（这是默认配置） GridFS Ceph RBD Amazon S3 Sheepdog OpenStack Block Storage (Cinder) OpenStack Object Storage (Swift) VMware ESX 没啥好讲的，需要用到时候现查，而且大部分操作都可以通过 GUI 完成 理解 Glance – 每天 5 分钟玩转 OpenStack（20） 创建 Image – 每天 5 分钟玩转 OpenStack（21） 如何使用 OpenStack CLI – 每天 5 分钟玩转 OpenStack（22） NovaCompute Service Nova 是 OpenStack 最核心的服务，负责维护和管理云环境的计算资源。OpenStack 作为 IaaS 的云操作系统，虚拟机生命周期管理也就是通过 Nova 来实现的。 nova-api接收和响应客户的 API 调用， 还支持 Amazon EC2 API nova-scheduler虚机调度服务，负责决定在哪个计算节点上运行虚机 nova-compute管理虚机的核心服务，通过调用 Hypervisor API 实现虚机生命周期管理 nova-conductornova-compute 经常需要更新数据库，比如更新虚机的状态出于安全性和伸缩性的考虑，nova-compute 并不会直接访问数据库 nova-console用户可以通过多种方式访问虚机的控制台：nova-novncproxy，基于 Web 浏览器的 VNC 访问nova-spicehtml5proxy，基于 HTML5 浏览器的 SPICE 访问nova-xvpnvncproxy，基于 Java 客户端的 VNC 访问 nova-consoleauth负责对访问虚机控制台请求提供 Token 认证 nova-cert提供 x509 证书支持 总之我越看越觉得 OpenStack 就是在 Hypervisor 上套了一层又一层而且我个人对 Python 写的大型项目是完全没有好感 理解 Nova 架构 – 每天 5 分钟玩转 OpenStack（23） 部署方案哪里有那么复杂，专门负责装 VPS 的 Hypervisor 就装 nova-compute然后其他服务放别处就行了 OpenStack 默认是用 RabbitMQ 作为 Message Queue，好评 Nova 组件如何协同工作 – 每天 5 分钟玩转 OpenStack（24） 设计思路说那么多到底还是解耦，疯狂解耦然后各种抽象 API，疯狂增加项目体积再加入各种调度，最离谱的是居然默认用 MySQL当然对大型集群这都不算什么 OpenStack 通用设计思路 – 每天 5 分钟玩转 OpenStack（25） 组件 Nova 组件详解 – 每天 5 分钟玩转 OpenStack（26） flavor 就是 plan，选 VPS 配置 Filter scheduler 是 nova-scheduler 默认的调度器 通过过滤器（filter）选择满足条件的计算节点 通过权重计算（weighting）选择在最优（权重值最大）的计算节点上创建 Instance RetryFilter 的作用是刷掉之前已经调度过的节点 为提高容灾性和提供隔离服务，可以将计算节点划分到不同的 Availability Zone 中 RamFilter 将不能满足 flavor 内存需求的计算节点过滤掉 DiskFilter 将不能满足 flavor 磁盘需求的计算节点过滤掉 CoreFilter 将不能满足 flavor vCPU 需求的计算节点过滤掉 ComputeFilter 保证只有 nova-compute 服务正常工作的计算节点才能够被 nova-scheduler 调度 ComputeCapabilitiesFilter 根据计算节点的特性来筛选可以从 Metadata 中筛选架构之类的 ImagePropertiesFilter 根据所选 image 的属性来筛选匹配的计算节点镜像也带 Metadata，可以限定比如只能运行在 kvm 上之类的 ServerGroupAntiAffinityFilter 可以尽量将 Instance 分散部署到不同的节点上 ServerGroupAffinityFilter 会尽量将 instance 部署到同一个计算节点上 nova-scheduler 的默认实现是根据计算节点空闲的内存量计算权重值：空闲内存越多，权重越大，instance 将被部署到当前空闲内存最多的计算节点上 看 Nova-Scheduler 如何选择计算节点 – 每天 5 分钟玩转 OpenStack（27） 每隔一段时间，nova-compute 就会报告当前计算节点的资源使用情况和自己的状态 这不就是微服务么，eureka 既视感 instance 的 launch、shutdown、reboot、suspend、resume、terminate、resize、migration、snapshot Nova-Compute 部署 Instance 详解 – 每天 5 分钟玩转 OpenStack（28） 生命周期OpenStack 的日志格式都是统一的，如下&lt;时间戳&gt;&lt;日志等级&gt;&lt;代码模块&gt;&lt;Request ID&gt;&lt;日志内容&gt;&lt;源代码位置&gt; 教你看懂 OpenStack 日志 – 每天 5 分钟玩转 OpenStack（29）Launch 和 Shut Off 操作详解 – 每天 5 分钟玩转 OpenStack（30）Start Instance 操作详解 – 每天 5 分钟玩转 OpenStack（31）Nova reboot 和 lock 操作 – 每天 5 分钟玩转 OpenStack（32）Terminate Instance 操作详解 – 每天 5 分钟玩转 OpenStack（33）Pause/Resume Instance 操作详解 – 每天 5 分钟玩转 OpenStack（34）Nova Suspend/Rescue 操作详解 – 每天 5 分钟玩转 OpenStack（35）Snapshot Instance 操作详解 – 每天 5 分钟玩转 OpenStack（36）Rebuild Instance 操作详解 – 每天 5 分钟玩转 OpenStack（37）Shelve Instance 操作详解 – 每天 5 分钟玩转 OpenStack（38）Unshelve Instance 操作详解 – 每天 5 分钟玩转 OpenStack（39）Migrate Instance 操作详解 – 每天 5 分钟玩转 OpenStack（40）Resize Instance 操作详解 – 每天 5 分钟玩转 OpenStack（41）Live Migrate 操作 – 每天 5 分钟玩转 OpenStack（42）计算节点宕机了怎么办？Evacuate - 每天 5 分钟玩转 OpenStack（43）1 张图秒懂 Nova 16 种操作 – 每天 5 分钟玩转 OpenStack（44） 上面这一大堆操作都是属于遇到了现查来得更快，而且很多都浅显易懂，盲猜也能用个大概","link":"/Cloud/OpenStack/OpenStack-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E7%AC%AC%E4%B8%80%E5%A4%A9/"},{"title":"Turing Machines","text":"自动寄 删除 010创建一个图灵机，它复制二进制输入到输出，并删除所有的 010 States Start End Tape Head Position Start Start Stop A0 0 A B0 0 B Copy Stop 1234567891011121314151617181920212223// 处理 0 开头，转到 A[Start; 0; SP]-&gt;[A; ANY; ANY; &gt;; S]// 处理 1 开头，直接复制[Start; 1; SP]-&gt;[Start; ANY; 1; &gt;; &gt;]// 为空，结束[Start; SP; SP]-&gt;[Stop; ANY; ANY; S; S]// 在 0 1 _ 时，转 B[A; 1; SP]-&gt;[B; ANY; ANY; &gt;; S]// 在 0 0 _ 时，写入 0，转 Start[A; 0; SP]-&gt;[Start; ANY; 0; S; &gt;]// 在 0 0 S 时，写入 0，结束[A; SP; SP]-&gt;[Stop; ANY; 0; S; &gt;]// 在 0 1 0 时，略过，回到 Start[B; 0; SP]-&gt;[Start; ANY; ANY; &gt;; S]// 在 0 1 1 时，将 0 复制，转 Copy 1[B; 1; SP]-&gt;[Copy; ANY; 0; S; &gt;]// 在 0 1 S 时，将 0 复制，转 Copy 1[B; SP; SP]-&gt;[Copy; ANY; 0; S; &gt;]// Copy 1[Copy; ANY; SP]-&gt;[Start; ANY; 1; S; &gt;] 把 00 变成 ##但是不处理超过 2 个 0 的情况 States Start End Tape Head Position Start Start Stop A0 0 Zero1 Zero2 FindOne Trans Trans2 Stop 1234567891011121314151617181920212223242526272829303132// 0 _ 转 Zero1[Start; 0]-&gt;[Zero1; 0; &gt;]// 1 _ 回到开始[Start; 1]-&gt;[Start; 1; &gt;]// 为空，结束[Start; SP]-&gt;[Stop; SP; S]// 0 0 _ 继续计数[Zero1; 0]-&gt;[Zero2; 0; &gt;]// 0 1 _ 回到开始[Zero1; 1]-&gt;[Start; 1; &gt;]// 0 S 结束[Zero1; SP]-&gt;[Stop; SP; S]// 0 0 0 不处理[Zero2; 0]-&gt;[FindOne; 0; &gt;]// 0 0 1 变换前两个为 #[Zero2; 1]-&gt;[Trans; 1; 2*&lt;]// 0 0 S 变换前两个为 #[Zero2; SP]-&gt;[Trans; SP; 2*&lt;]// 第一次写入[Trans; 0]-&gt;[Trans2; #; &gt;]// 第二次写入[Trans2; 0]-&gt;[Start; #; &gt;]// 找到下一个 1[FindOne; 1]-&gt;[Start; 1; &gt;]// 仍然是 0[FindOne; 0]-&gt;[FindOne; 0; &gt;]// 结束[FindOne; SP]-&gt;[Stop; SP; S] 011 变 ABCD States Start End Tape Head Position Start Start Stop A0 0 Zero B0 0 One Copy BCD CD D Stop 1234567891011121314151617181920212223242526272829303132// 0 _ 计数[Start; 0; SP]-&gt;[Zero; 0; SP; &gt;; S]// 1 _ 复制[Start; 1; SP]-&gt;[Start; 1; 1; &gt;; &gt;]// 为空，结束[Start; SP; SP]-&gt;[Stop; SP; SP; S; S]// 0 1 _ 计数[Zero; 1; SP]-&gt;[One; 1; SP; &gt;; S]// 0 0 _ 复制 0，回到开始[Zero; 0; SP]-&gt;[Start; 0; 0; S; &gt;]// 0 S 复制 0，停止[Zero; SP; SP]-&gt;[Stop; SP; 0; S; &gt;]// 0 1 1 变换，写入 A[One; 1; SP]-&gt;[BCD; 1; A; S; &gt;]// 0 1 0 复制 0，转 Copy 1[One; 0; SP]-&gt;[Copy; 0; 0; &lt;; &gt;]// 0 1 S 复制 0，转 Copy 1[One; SP; SP]-&gt;[Copy; SP; 0; &lt;; &gt;]// 写入 B[BCD; ANY; SP]-&gt;[CD; ANY; B; S; &gt;]// 写入 C[CD; ANY; SP]-&gt;[D; ANY; C; S; &gt;]// 写入 D，回到开始[D; ANY; SP]-&gt;[Start; ANY; D; &gt;; &gt;]// Copy 0[Copy; 0; SP]-&gt;[Start; 0; 0; &gt;; &gt;]// Copy 1[Copy; 1; SP]-&gt;[Start; 1; 1; &gt;; &gt;] 多个 1 变一个 1 States Start End Tape Head Position Start Start Stop A0 0 One B0 0 Stop 12345678910111213// 0 复制[Start; 0; SP]-&gt;[Start; 0; 0; &gt;; &gt;]// 1 复制并计数[Start; 1; SP]-&gt;[One; 1; 1; &gt;; &gt;]// 为空，停止[Start; SP; SP]-&gt;[Stop; SP; SP; S; S]// 1 0 复制，回到开始[One; 0; SP]-&gt;[Start; 0; 0; &gt;; &gt;]// 1 1 找到下一个 0[One; 1; SP]-&gt;[One; 1; ANY; &gt;; S]// 1 S 停止[One; SP; SP]-&gt;[Stop; SP; SP; S; S] 11 变 112 States Start End Tape Head Position Start Start Stop A0 0 One B0 0 Two Stop 12345678910111213141516// 0 复制[Start; 0; SP]-&gt;[Start; 0; 0; &gt;; &gt;]// 1 复制并计数[Start; 1; SP]-&gt;[One; 1; 1; &gt;; &gt;]// 为空，停止[Start; SP; SP]-&gt;[Stop; SP; SP; S; S]// 1 1 添加 2[One; 1; SP]-&gt;[Two; 1; 1; S; &gt;]// 1 0 复制并回到开始[One; 0; SP]-&gt;[Start; 0; 0; &gt;; &gt;]// 1 S 停止[One; SP; SP]-&gt;[Stop; SP; SP; S; S]// +2s[Two; ANY; SP]-&gt;[Start; ANY; 2; &gt;; &gt;] 0000… 变 4444… States Start End Tape Head Position Start Start Stop A0 0 One Two Three Trans Stop 1234567891011121314151617181920212223242526272829303132// 0，计数[Start; 0]-&gt;[One; 0; &gt;]// 1，跳过[Start; 1]-&gt;[Start; 1; &gt;]// 为空，停止[Start; SP]-&gt;[Stop; SP; S]// 0 0[One; 0]-&gt;[Two; 0; &gt;]// 0 1 回[One; 1]-&gt;[Start; 1; &gt;]// 0 S 停止[One; SP]-&gt;[Stop; SP; S]// 0 0 0[Two; 0]-&gt;[Three; 0; &gt;]// 0 0 1[Two; 1]-&gt;[Start; 1; &gt;]// 0 0 S 停止[Two; SP]-&gt;[Stop; SP; S]// 0 0 0 0，转换[Three; 0]-&gt;[Trans; 4; 3*&lt;]// 0 0 0 1 回[Three; 1]-&gt;[Start; 1; &gt;]// 0 0 0 S 停止[Three; SP]-&gt;[Stop; SP; S]// 4 0 0 4[Trans; 0]-&gt;[Trans; 4; &gt;]// Stop Trans[Trans; 4]-&gt;[Start; ANY; &gt;] 二进制乘 3 States Start End Tape Head Position Start Start Stop A0 0 X Non Carry Stop 1234567891011121314151617181920212223// 在结果最前加一个 0[Start; 0; SP]-&gt;[X; 0; 0; S; &gt;][Start; 1; SP]-&gt;[X; 1; 0; S; &gt;]// 复制[X; 0; SP]-&gt;[X; 0; 0; &gt;; &gt;][X; 1; SP]-&gt;[X; 1; 1; &gt;; &gt;]// 在输入最后加一个 0[X; SP; SP]-&gt;[Non; 0; SP; S; &lt;]// 不进位[Non; 0; 0]-&gt;[Non; 0; 0; &lt;; &lt;][Non; 0; 1]-&gt;[Non; 0; 1; &lt;; &lt;][Non; 1; 0]-&gt;[Non; 1; 1; &lt;; &lt;][Non; 1; 1]-&gt;[Carry; 1; 0; &lt;; &lt;][Non; SP; SP]-&gt;[Stop; SP; SP; S; S]// 进位[Carry; 0; 0]-&gt;[Non; 0; 1; &lt;; &lt;][Carry; 0; 1]-&gt;[Carry; 0; 0; &lt;; &lt;][Carry; 1; 0]-&gt;[Carry; 1; 0; &lt;; &lt;][Carry; 1; 1]-&gt;[Carry; 1; 1; &lt;; &lt;][Carry; SP; SP]-&gt;[Stop; SP; 1; S; S]","link":"/Algorithm/TM/Turing-Machines/"},{"title":"OpenStack 学习日记 第二天","text":"Cinder操作系统挂载储存空间的方法有： Block Storage 块储存：通过本地协议（SCSI、SAS）等挂载裸磁盘，每个磁盘叫做 Volume 卷 文件系统储存：通过网络协议（NFS、CIFS）等挂载远程文件系统，分布式就是这种 Block Storage Service 提供对 volume 从创建到删除整个生命周期的管理从 instance 的角度看，挂载的每一个 Volume 都是一块硬盘 Cinder： 提供 REST API 使用户能够查询和管理 volume、volume snapshot 以及 volume type 提供 scheduler 调度 volume 创建请求，合理优化存储资源的分配 通过 driver 架构支持多种 back-end（后端）存储方式，包括 LVM，NFS，Ceph 和其他诸如 EMC、IBM 等商业存储产品和方案 组件 cinder-api接收 API 请求，调用 cinder-volume 执行操作 cinder-volume管理 volume 的服务，与 volume provider 协调工作，管理 volume 的生命周期运行 cinder-volume 服务的节点被称作为存储节点，LVM 是默认的 provider cinder-schedulerscheduler 通过调度算法选择最合适的存储节点创建 volume volume provider数据的存储设备，为 volume 提供物理存储空间支持多种 volume provider，每种 provider 通过自己的 driver 与 cinder-volume 协调工作 Message QueueCinder 各个子服务通过消息队列实现进程间通信和相互协作因为有了消息队列，子服务之间实现了解耦，这种松散的结构也是分布式系统的重要特征 Database数据库是安装在控制节点上的 其他 理解 Cinder 架构 – 每天 5 分钟玩转 OpenStack（45） 主要还是在讲传统分布式设计 掌握 Cinder 的设计思想 – 每天 5 分钟玩转 OpenStack（46） cinder-api 是整个 Cinder 组件的门户，所有 cinder 的请求都首先由 nova-api 处理 cinder-volume 在存储节点上运行，OpenStack 对 Volume 的操作，最后都是交给 cinder-volume 来完成的cinder-volume 自身并不管理真正的存储设备，存储设备是由 volume provider 管理的。cinder-volume 与 volume provider 一起实现 volume 生命周期的管理 Cinder 组件详解 – 每天 5 分钟玩转 OpenStack（47） 调度器Filter scheduler 是 cinder-scheduler 默认的调度器 AvailabilityZoneFilter为提高容灾性和提供隔离服务，可以将存储节点和计算节点划分到不同的 Availability Zone 中 CapacityFilter将存储空间不能满足 Volume 创建需求的存储节点过滤掉 CapabilitiesFilter不同的 Volume Provider 有自己的特性（Capabilities），比如是否支持 thin provision 等Cinder 允许用户创建 Volume 时通过 Volume Type 指定需要的 Capabilities Weighter通过 scheduler_default_weighers 指定计算权重的 weigher，默认为 CapacityWeigherCapacityWeigher 基于存储节点的空闲容量计算权重值，空闲容量最大的胜出 掌握 cinder-scheduler 调度逻辑 – 每天 5 分钟玩转 OpenStack（48） 操作 准备 LVM Volume Provider – 每天 5 分钟玩转 OpenStack（49） Create Volume 操作（Part I） – 每天 5 分钟玩转 OpenStack（50） Create Volume 操作（Part II） – 每天 5 分钟玩转 OpenStack（51） Create Volume 操作（Part III） – 每天 5 分钟玩转 OpenStack（52） Attach Volume 操作（Part I） – 每天 5 分钟玩转 OpenStack（53） Attach Volume 操作（Part II） – 每天 5 分钟玩转 OpenStack（54） Detach Volume 操作 – 每天 5 分钟玩转 OpenStack（55） Extend Volume 操作 – 每天 5 分钟玩转 OpenStack（56） Delete Volume 操作 – 每天 5 分钟玩转 OpenStack（57） Snapshot Volume 操作 – 每天 5 分钟玩转 OpenStack（58） Backup Volume 操作 – 每天 5 分钟玩转 OpenStack（59） Restore Volume 操作 – 每天 5 分钟玩转 OpenStack（60） Boot From Volume – 每天 5 分钟玩转 OpenStack（61） NFS NFS Volume Provider（Part I） – 每天 5 分钟玩转 OpenStack（62） NFS Volume Provider（Part II） – 每天 5 分钟玩转 OpenStack（63） NFS Volume Provider（Part III） – 每天 5 分钟玩转 OpenStack（64） Neutron“软件定义网络（software-defined networking, SDN）”所具有的灵活性和自动化优势 Neutron 的设计目标是实现“网络即服务（Networking as a Service）”在设计上遵循了基于 SDN 实现网络虚拟化的原则，在实现上充分利用了 Linux 系统上的各种网络相关的技术 Neutron 为整个 OpenStack 环境提供网络支持，包括二层交换，三层路由，负载均衡，防火墙和 VPN 等 二层交换 SwitchingNova 的 Instance 是通过虚拟交换机连接到虚拟二层网络的Neutron 支持多种虚拟交换机，包括 Linux 原生的 Linux Bridge 和 Open vSwitchNeutron 除了可以创建传统的 VLAN 网络，还可以创建基于隧道技术的 Overlay 网络，比如 VxLAN 和 GRE 三层路由 RoutingNeutron 支持多种路由，包括 Linux 原生的 Linux Bridge 和 Open vSwitchInstance 可以配置不同网段的 IP，Neutron 的 router（虚拟路由器）实现 instance 跨网段通信router 通过 IP forwarding，iptables 等技术来实现路由和 NAT 负载均衡 Load BalancingLoad-Balancing-as-a-Service（LBaaS）支持多种负载均衡产品和方案，不同的实现以 Plugin 的形式集成到 Neutron，目前默认的 Plugin 是 HAProxy。 防火墙 FirewallingSecurity Group：通过 iptables 限制进出 instance 的网络包FWaaS：限制进出虚拟路由器的网络包，也是通过 iptables 实现 Neutron 功能概述 – 每天 5 分钟玩转 OpenStack（65） 概念Neutron 支持多种类型的 network，包括 local, flat, VLAN, VxLAN 和 GRE。 locallocal 网络与其他网络和节点隔离。local 网络中的 instance 只能与位于同一节点上同一网络的 instance 通信，local 网络主要用于单机测试 flatflat 网络是无 vlan tagging 的网络。flat 网络中的 instance 能与位于同一网络的 instance 通信，并且可以跨多个节点。 vlanvlan 网络是具有 802.1q tagging 的网络。vlan 是一个二层的广播域，同一 vlan 中的 instance 可以通信，不同 vlan 只能通过 router 通信。vlan 网络可以跨节点，是应用最广泛的网络类型 vxlanvxlan 是基于隧道技术的 overlay 网络。vxlan 网络通过唯一的 segmentation ID（也叫 VNI）与其他 vxlan 网络区分vxlan 中数据包会通过 VNI 封装成 UDP 包进行传输因为二层的包通过封装在三层传输，能够克服 vlan 和物理网络基础设施的限制 gregre 是与 vxlan 类似的一种 overlay 网络。主要区别在于使用 IP 包而非 UDP 进行封装 Neutron 网络基本概念 – 每天 5 分钟玩转 OpenStack（66） 组件 Neutron Server对外提供 OpenStack 网络 API，接收请求，并调用 Plugin 处理请求。 Plugin处理 Neutron Server 发来的请求，维护 OpenStack 逻辑网络的状态， 并调用 Agent 处理请求。 Agent处理 Plugin 的请求，负责在 network provider 上真正实现各种网络功能。 network provider提供网络服务的虚拟或物理网络设备，例如 Linux Bridge，Open vSwitch 或者其他支持 Neutron 的物理交换机。 QueueNeutron Server，Plugin 和 Agent 之间通过 Messaging Queue 通信和调用。 Database存放 OpenStack 的网络状态信息，包括 Network, Subnet, Port, Router 等。 Neutron 架构 – 每天 5 分钟玩转 OpenStack（67） 部署 方案 1：控制节点 + 计算节点控制节点：部署的服务包括：neutron server, core plugin 的 agent 和 service plugin 的 agent计算节点：部署 core plugin 的 agent，负责提供二层网络功能。 方案 2：控制节点 + 网络节点 + 计算节点控制节点：部署 neutron server 服务网络节点：部署的服务包括：core plugin 的 agent 和 service plugin 的 agent计算节点：部署 core plugin 的 agent，负责提供二层网络功能。 Neutron 物理部署方案 – 每天 5 分钟玩转 OpenStack（68） 结构 Core API对外提供管理 network, subnet 和 port 的 RESTful API。 Extension API对外提供管理 router, load balance, firewall 等资源 的 RESTful API。 Commnon Service认证和校验 API 请求。 Neutron CoreNeutron server 的核心处理程序，通过调用相应的 Plugin 处理请求。 Core Plugin API定义了 Core Plgin 的抽象功能集合，Neutron Core 通过该 API 调用相应的 Core Plgin。 Extension Plugin API定义了 Service Plgin 的抽象功能集合，Neutron Core 通过该 API 调用相应的 Service Plgin。 Core Plugin实现了 Core Plugin API，在数据库中维护 network, subnet 和 port 的状态，并负责调用相应的 agent 在 network provider 上执行相关操作，比如创建 network。 Service Plugin实现了 Extension Plugin API，在数据库中维护 router, load balance, security group 等资源的状态，并负责调用相应的 agent 在 network provider 上执行相关操作，比如创建 router。 理解 Neutron Server 分层模型 – 每天 5 分钟玩转 OpenStack（69） Neutron 如何支持多种 network provider – 每天 5 分钟玩转 OpenStack（70） ML2Moduler Layer 2（ML2）是 Neutron 在 Havana 版本实现的一个新的 core plugin，用于替代原有的 linux bridge plugin 和 open vswitch plugin 传统 core plugin 存在两个突出的问题: 无法同时使用多种 network provider 开发新的 core plugin 工作量大 详解 ML2 Core Plugin（I） – 每天 5 分钟玩转 OpenStack（71） ML2 对二层网络进行抽象和建模，引入了 type driver 和 mechanism driver这两类 driver 解耦了 Neutron 所支持的网络类型（type）与访问这些网络类型的机制（mechanism）其结果就是使得 ML2 具有非常好的弹性，易于扩展，能够灵活支持多种 type 和 mechanism。 Type DriverNeutron 支持的每一种网络类型都有一个对应的 ML2 type driver。type driver 负责维护网络类型的状态，执行验证，创建网络等。ML2 支持的网络类型包括 local, flat, vlan, vxlan 和 gre Mechanism DriverNeutron 支持的每一种网络机制都有一个对应的 ML2 mechanism driver mechanism driver 负责获取由 type driver 维护的网络状态，并确保在相应的网络设备（物理或虚拟）上正确实现这些状态 mechanism driver 有三种类型 Agent-based包括 linux bridge, open vswitch 等 Controller-based包括 OpenDaylight, VMWare NSX 等 基于物理交换机包括 Cisco Nexus, Arista, Mellanox 等 详解 ML2 Core Plugin（II） – 每天 5 分钟玩转 OpenStack（72） Service PluginCore Plugin/Agent 负责管理核心实体：net, subnet 和 port而对于更高级的网络服务，则由 Service Plugin/Agent 管理Service Plugin 及其 Agent 提供更丰富的扩展功能，包括路由，load balance，firewall 等 DHCPdhcp agent 通过 dnsmasq 为 instance 提供 dhcp 服务 Routingl3 agent 可以为 project（租户）创建 router，提供 Neutron subnet 之间的路由服务路由功能默认通过 IPtables 实现 Firewalll3 agent 可以在 router 上配置防火墙策略，提供网络安全防护另一个与安全相关的功能是 Security Group，也是通过 IPtables 实现Firewall 安全策略位于 router，保护的是某个 project 的所有 networkSecurity Group 安全策略位于 instance，保护的是单个 instance Load BalanceNeutron 默认通过 HAProxy 为 project 中的多个 instance 提供 load balance 服务 Service Plugin / Agent – 每天 5 分钟玩转 OpenStack（73） 两张图总结 Neutron 架构 – 每天 5 分钟玩转 OpenStack（74） 为 Neutron 准备物理基础设施（I） – 每天 5 分钟玩转 OpenStack（75） 为 Neutron 准备物理基础设施（II） – 每天 5 分钟玩转 OpenStack（76）","link":"/Cloud/OpenStack/OpenStack-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E5%A4%A9/"},{"title":"数据库概念入门","text":"所以说我们老师考这些的意义是什么呢 第一周Data -&gt; Database -&gt; Data Warehouse都什么年代了还在用数据仓库 Physical Data 是储存在实体介质上的数据Logical Data 是指数据的逻辑结构有 Add / Modify / Delete / Merging / Breaking 这什么玩意写的乱七八糟的 数据独立性物理独立性 程序与磁盘数据相互独立 程序不需要了解如何储存数据 数据如何储存由 DBMS 管理 物理储存改变，程序无需改变 逻辑独立性 程序与数据库的逻辑结构相互独立 数据逻辑结构改变，程序无需改变 数据独立性的重要性 数据质量 维护成本 安全性 结构化 Implementation (Layers of data) 减少重复 备份 物理层面容易修改，提高性能 合着真就不说人话 三级模式结构Physical Schema内模式（储存模式），对应 物理（内部）级描述了数据在磁盘上的存储方式和物理结构 Conceptual Schema概念模式（逻辑模式），对应 概念（逻辑）级是对数据库中全部数据的逻辑结构和特征的总体描述是全局视图，由 Data Description Language 描述 External Schema外模式（用户模式），对应 用户（视图）级是用户所看到的数据库的数据视图是概念模式的一个子集，包换特定用户使用的那部分数据由 Data Manipulation Language 操作 关系模型突然发现老师的 PPT 内容都是网上抄的 概念 Attribute: Column Table: Relation Tuple: Row Degree: Count(Column) Cardinality: Count(Row) Relation key: 比如主键 Domain: 数据类型，约束等 Relation Schema: 表名 和 其中的列 Relation Instance: 表中的数据 完整性约束Domain Constraints123... ColName INT CHECK(ColName = 3) NOT NULL ...-- AndCREATE TRIGGER SomeName ... Key Constraints主键约束 Referential Integrity Constraints外键约束 优势 简单 结构独立 易用 能够查询 数据独立 可扩展 第二周 RDBMS: Relational Database Management System关系型数据库管理系统 SQLWhy 方便存取数据 有助于描述数据 允许对数据库中的数据进行定义和操作 创建和删除表 创建和使用 函数，View，储存过程 设置权限 这些都是老师说的，我持保留意见 Types DDL: Data Definition Language 定义 CREATE ALTER DROP TRUNCATE DML: Data Manipulation Language 操作 INSERT UPDATE DELETE DCL: Data Control Language 权限 GRANT REVOKE TCL: Transaction Control Language 事务 COMMIT ROLLBACK SAVEPOINT DQL: Data Query Language 查询 SELECT 索引查看索引 1EXEC sp_helpindex 表名 聚集索引Clustered Index 表中行数据的物理顺序与索引的逻辑顺序相同 一个表只能有一个聚集索引 Primary Key 默认 非聚集索引Nonclustered Index 储存的是指向表中行的指针 UNIQUE 默认 索引覆盖Covering Indexes 索引中包含了所有要查询的字段 提高性能 第三周维护Maintenance Repair 重组索引 重建索引 更新统计信息 一致性和完整性检查Consistency and Integrity 修复和清理 Normalization数据库规范化 保护数据 消除冗余 消除不一致的依赖关系 不一致用户在 Customer 表中查找 Address 是合理的但是在这里查找 负责这个客户的 员工的 Salary 就不合理了这应该去 Employee 表中查找 不一致的依赖关系 会使数据难以访问 非规范化表 学生编号 指导教师 咨询室 课程 1 课程 2 课程 3 1022 Jones 412 101-07 143-01 159-02 4123 Smith 216 101-07 143-01 179-04 1NF：消除重复的列 消除单个表中的重复列 为每组相关数据单独创建一个表 使用主键标识每组相关数据 学生编号 指导教师 咨询室 课程 1022 Jones 412 101-07 1022 Jones 412 143-01 1022 Jones 412 159-02 4123 Smith 216 101-07 4123 Smith 216 143-01 4123 Smith 216 179-04 2NF：消除重复的行 为应用于多条记录的值，创建单独的表 用外键连接这些表 Table Student 学生编号 指导教师 咨询室 1022 Jones 412 4123 Smith 216 Table Course 学生编号 课程 1022 101-07 1022 143-01 1022 159-02 4123 101-07 4123 143-01 4123 179-04 3NF：消除与主键无关的数据指导教师和咨询室是与学生编号无关的数据 Table Student 学生编号 指导教师 1022 Jones 4123 Smith Table Teacher 名称 咨询室 Jones 412 Smith 216 主键 不能为空 唯一 几乎不会改变 Composite Key复合主键是指由多个字段组成的主键 外键 可空 不唯一 依赖完整性 ER 图 实体 Entity用矩形表示，也就是表 属性 Attribute用椭圆表示，也就是列 关系 Relationship用菱形表示，也就是表之间的关系 派生属性可以由其他属性计算得出，虚线比如 Age 可以由 Birthday 计算得出 多值属性可以有多个值，双椭圆比如书有多个作者 复合属性由多个属性组成比如名字由姓和名组成 可选属性 复合实体用于多对多联系，矩形内加一个菱形 弱实体必须依赖另一个实体存在比如学生是强实体，成绩单是弱实体必须是一对一或者一对多的关系用双层矩形表示 一对一 一对多 多对多需要复合实体帮助 步骤 Entity Identification找实体 Relationship Identification找关系 Cardinality Identification一对多之类的 Identify Attributes找 Column Create the ER Diagram画图 数据仓库数据仓库，OLAP，使用数据库系统来帮助洞察业务典型的有 Redshift，主要用于数据分析比如，20~30 岁女性用户在过去五年的第一季度化妆品类商品的购买行为与公司进行的促销活动方案之间的关系 数据库是为读写优化的，而数据仓库是为只读优化的 事实表主要特点是含有大量的数据，并且这些数据是可以汇总，并被记录的 维度表分析数据的窗口，包含事实表中事实记录的特性 星形模式 Star一张事实表和多张维度表组成 雪花模式 Snowflake每一个维度表都可以向外连接多个子维度表 星系模式 Galaxy多个事实表版本的星型模型，多张事实表共用模型中的维度表 Data Cube专指那些远大于内存的数据集合，它用来存储和表示多维度数据 钻取 Drill Down从高维度到低维度比如，对第二季度的总销售数据进行钻取可以得到第二季度中每个月的销售数据 上卷 Roll Up从低维度到高维度比如，将 4，5，6 月的销售数据进行上卷可以得到第二季度的销售数据 切片 Slice对特定值进行分析比如，只选择电子产品的销售数据 切块 Dice对特定范围进行分析比如，选择第一季度和第二季度的销售数据 旋转 Rotate交换维度比如，通过旋转实现产品和地域的维度互换 元数据元数据通常包括有关数据仓库中数据的描述信息、数据的属性和结构、以及数据之间的关系等元数据可以帮助人们更好地理解和使用数据仓库中的数据，并且在数据仓库的管理和维护方面也起着重要作用","link":"/Database/Theory/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E5%BF%B5%E5%85%A5%E9%97%A8/"},{"title":"数理逻辑2 B卷","text":"Mathematical Logic 完全理解！ CoqideAP ∧ (Q ∧ R), (S ∧ E) ∧ U, E ⇒ W ⊢ (Q ∧ P) ∧ W 123456789101112131415161718192021222324252627Require Import Classical.Parameters P Q R S U E W: Prop.Hypothesis P1: P /\\ (Q /\\ R).Hypothesis P2: (S /\\ E) /\\ U.Hypothesis P3: E -&gt; W.Goal (Q /\\ P) /\\ W.Proof.pose proof(proj1 P1).pose proof(proj2 P1).pose proof(proj1 H0).pose proof(conj H1 H).pose proof(proj1 P2).pose proof(proj2 H3).pose proof(P3 H4).pose proof(conj H1 H).pose proof(conj H6 H5).exact H7.Qed. BQ, Q ⇒ P ∨ R, R ⇒ S ⊢ P ∨ S 12345678910111213141516171819202122Require Import Classical.Parameters P Q R S: Prop.Hypothesis P1: Q.Hypothesis P2: Q -&gt; P \\/ R.Hypothesis P3: R -&gt; S.Goal P \\/ S.Proof.pose proof(P2 P1).destruct H.left.exact H.right.pose proof(P3 H).exact H0.Qed. CS ⇒ P, Q ⇒ E ⊢ (P ⇒ Q) ⇒ (S ⇒ E) 1234567891011121314151617181920Require Import Classical.Parameters P Q E S: Prop.Hypothesis P1: S -&gt; P.Hypothesis P2: Q -&gt; E.Goal (P -&gt; Q) -&gt; (S -&gt; E).Proof.intros H.assert(S -&gt; E).intros H1.apply P2.apply H.apply P1.exact H1.exact H0.Qed. D(P ⇒ Q) ⇒ (P ⇒ R) ⇒ (Q ⇒ R ⇒ W) ⇒ P ⇒ W 1234567891011121314Require Import Classical.Theorem Implies : forall P Q R W : Prop, (P -&gt; Q) -&gt; (P -&gt; R) -&gt; (Q -&gt; R -&gt; W) -&gt; P -&gt; W.Proof.intros P Q R W PQ PR QR PW.apply QR.apply PQ.exact PW.apply PR.exact PW.Qed. Symbolize No superhero is faster than Spiderman. Some evil superheros can climb on the wall. Evil superheros are not faster than Spiderman. If someone is faster than Spiderman, then Spiderman is evil. Everone who is faster than Spiderman is evil and can climb on the wall. There is someone who is faster than anyone who can climb on the wall. Someone who is faster than Spiderman is evil. Only those who are evil can be faster than those who are not faster than Spiderman. Find TruthUD: { Potter, Granger, Weasley }Extension H: { Potter, Weasley }Extension W: { Granger, Weasley }Extension R: { (Potter, Granger), (Granger, Potter), (Weasley, Granger) }Referent a: Potter ∃x(Rxa ∧ Rax) ∀x(Rxa ∨ Rax) ∀x(Hx ⇔ Wx) ∀x(Rxa ⇒ Wx) ∀x[Wx ⇒ (Hx ∧ Wx)] ∃x(Rxx) ∃x∃y(Rxy) ∀x∀y(Rxy) ∀x∀y(Rxy ∨ Ryx) ∀x∀y∀z[(Rxy ∧ Ryz) ⇒ Rxz] IsConsistentP ⇒ Q, Q ∧ (P ∨ P), ¬(Q ∨ R) IsValid R ⇒ (P ∨ Q), R ∧ Q ⊢ R ⇒ P ¬R ⇒ Q, ¬P ∨ ¬Q, ¬(P ⇔ Q) ⊢ ¬(P ∨ Q) Symbolize &amp; IsValidEvery dwarf that saw Snowhite biting into the apple want to save her.Someone (a dwarf) let the stepmother into the house.Those dwarfs that want to save Snowite did not let the stepmother into the house.Therefore: Not every dwaft saw Snowhite biting the apple. Natural Deduction P ∨ Q ⇒ R ⊢ (P ∧ Q) ⇒ R 1234567891011121314151617Require Import Classical.Parameters P Q R: Prop.Hypothesis P1: P \\/ Q -&gt; R.Goal (P /\\ Q) -&gt; R.Proof.intro.destruct H.apply P1.left.exact H.Qed. (R ∧ S) ⇒ (P ∧ ¬Q), E ∧ (E ⇒ S), Q ⊢ R ⇒ P 123456789101112131415161718192021222324Require Import Classical.Parameters P Q R S E: Prop.Hypothesis P1: (R /\\ S) -&gt; (P /\\ ~Q).Hypothesis P2: E /\\ (E -&gt; S).Hypothesis P3: Q.Goal R -&gt; P.Proof.intro.pose proof(proj1 P2).pose proof(proj2 P2).pose proof(H1 H0).pose proof(conj H H2).pose proof(P1 H3).pose proof(proj1 H4).exact H5.Qed. j is a constant, ∀x(¬Mx ∨ Ljx), ∀x(Bx ⇒ Ljx), ∀x(Mx ∨ Bx) ⊢ ∀xLjx ∃x∀yPxy ⊢ ∀y∃xPxy ∀xPx, ∃x(Px ⇒ ∀yQy), ∀x(Qx ⇒ Rx) ⊢ ∃x(Qx ∧ Rx) Argument invalid, Prove∃x(Dx), ∃x(Ex), ∀x(Dx ∨ Ex) ⊢ ∃x(Dx ∧ Ex)","link":"/Math/Logic/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%912-B%E5%8D%B7/"},{"title":"记一次面试题","text":"参加了一次 黑客排名 的技术面试 得到的经验就是别去看那有的没的的题干，很浪费时间，而是要： 看示例输入 看示例输出 找输入输出的关系 写框架代码 找题中的细节要求 完善代码 Test &amp; Debug 我有 70 分钟作答 ，但是吧，这题弱智都做得出来，无非是时间问题 算法题从 List&lt;List&lt;int&gt;&gt; 中找出最大相邻相同数字的方阵长度，比如 输入 1231 1 11 1 01 0 1 输出 2 解本题需要用到 动态规划 的思想 二维数组 dp 来记录以每个元素为右下角的最大相邻相同数字的方阵长度然后遍历输入的矩阵，根据当前元素的值来更新 dp最后，返回 dp 中的最大值作为最大相邻相同数字的方阵长度 12345678910111213141516171819202122232425262728static int FindMaxSquareLength(List&lt;List&lt;int&gt;&gt; matrix) { var rows = matrix.Count; var cols = matrix[0].Count; var maxLength = 0; var dp = new int[rows, cols]; for (var i = 0; i &lt; rows; i++) for (var j = 0; j &lt; cols; j++) { if (i == 0 || j == 0) dp[i, j] = matrix[i][j]; else if (matrix[i][j] == 1) dp[i, j] = Math.Min(dp[i - 1, j - 1], Math.Min(dp[i - 1, j], dp[i, j - 1])) + 1; maxLength = Math.Max(maxLength, dp[i, j]); } return maxLength;}List&lt;List&lt;int&gt;&gt; matrix = new() { new() { 1, 1, 1 }, new() { 1, 1, 0 }, new() { 1, 0, 1 }};var maxLength = FindMaxSquareLength(matrix);Console.WriteLine(&quot;最大相邻相同数字的方阵长度为: &quot; + maxLength); 技能题编写一个 HTTP GET 查询 URL: https://jsonmock.hackerrank.com/api/transactions它不提供除了 ?page=num 以外的查询参数 编写代码以实现 1List&lt;string&gt; maximumTransfer(string name, string city) 其中，找出最大的 credit 为 [0]，最大的 debit 为 [1] 解这个真没啥好说的，单纯考基本功 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596static async Task&lt;List&lt;string&gt;&gt; maximumTransfer(string name, string city) { var result = new List&lt;string&gt;(); var allData = await GetAllData(); var maxCredit = decimal.MinValue; var maxDebit = decimal.MinValue; var maxCreditAmount = &quot;&quot;; var maxDebitAmount = &quot;&quot;; foreach (var data in allData.Where(data =&gt; data.userName == name &amp;&amp; data.location.city == city)) switch (data.txnType) { case &quot;credit&quot;: { var creditAmount = ParseAmount(data.amount); if (creditAmount &gt; maxCredit) { maxCredit = creditAmount; maxCreditAmount = data.amount; } break; } case &quot;debit&quot;: { var debitAmount = ParseAmount(data.amount); if (debitAmount &gt; maxDebit) { maxDebit = debitAmount; maxDebitAmount = data.amount; } break; } } result.Add(maxCreditAmount); result.Add(maxDebitAmount); return result;}static async Task&lt;List&lt;Data&gt;&gt; GetAllData() { var allData = new List&lt;Data&gt;(); var currentPage = 1; var totalPages = 1; while (currentPage &lt;= totalPages) { var url = $&quot;https://jsonmock.hackerrank.com/api/transactions?page={currentPage}&quot;; using (var client = new HttpClient()) { var response = await client.GetAsync(url); if (response.IsSuccessStatusCode) { var json = await response.Content.ReadAsStringAsync(); Root root = JsonConvert.DeserializeObject&lt;Root&gt;(json); allData.AddRange(root.data); totalPages = root.total_pages; } else throw new($&quot;Failed to retrieve data from {url}. Status code: {response.StatusCode}&quot;); } currentPage++; } return allData;}static decimal ParseAmount(string amount) { var cleanedAmount = amount.Replace(&quot;$&quot;, &quot;&quot;).Replace(&quot;,&quot;, &quot;&quot;); return decimal.Parse(cleanedAmount);}var maxTransfer = await maximumTransfer(&quot;John Doe&quot;, &quot;New York&quot;);Console.WriteLine(&quot;Max Credit: &quot; + maxTransfer[0]);Console.WriteLine(&quot;Max Debit: &quot; + maxTransfer[1]);internal class Data { public int id { get; set; } public int userId { get; set; } public string userName { get; set; } public object timestamp { get; set; } public string txnType { get; set; } public string amount { get; set; } public Location location { get; set; } public string ip { get; set; }}internal class Location { public int id { get; set; } public string address { get; set; } public string city { get; set; } public int zipCode { get; set; }}internal class Root { public int page { get; set; } public int per_page { get; set; } public int total { get; set; } public int total_pages { get; set; } public List&lt;Data&gt; data { get; set; }} SQL 题写一个 SQL 查询，有表 12customers(id: smallint, name:varchar)warehouses(customer_id, volume: decimal, is_active:smallint) 期望输出 1record(name, warehouses, min_volume, max_volume, total_volume) 只有 active 的仓库才被列出，按 name 排序 解或许 ChatGPT 写的比你更快更好 ，有的时候找找自己原因，好吧，这么多年了工资涨没涨，有没有认真工作，好不，这么多年都是这个代码质量我真的疯掉了。 123456789101112131415SELECT c.name AS name, COUNT(w.customer_id) AS warehouses, MIN(w.volume) AS min_volume, MAX(w.volume) AS max_volume, SUM(w.volume) AS total_volumeFROM customers c INNER JOIN warehouses w ON c.id = w.customer_idWHERE w.is_active = 1GROUP BY c.id, c.nameORDER BY c.name;","link":"/Program/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"title":"论使用WebCodecs对视频进行处理","text":"原文 更新于 2022-02-10，由 Aloento 翻译，具体以原文为准 现代的 Web 技术为视频提供了丰富的处理能力，例如 Media Stream API、Media Recording API、Media Source API, 和 WebRTC API 等，它们提供了丰富的工具以便 录制、传输、回放视频流。这些 API 虽然封装了很多高级功能以便方便的完成既定任务，但它们并不能让你处理视频流的内部细节，如 按帧处理 和 处理未 Muxed 的视频或音频块等。为了实现以上目的，你不得不使用一些类似 WebAssembly 的方式来把浏览器本就自带的编解码器（通常它们都有硬件加速）又一次的引入，这属实是对资源的浪费。 而 WebCodecs API 为程序员提供了使用浏览器自带编解码器的能力，来提高你的工作流效率，具体而言： 音视频的编解码 视频原始帧 图像解码 WebCodecs API 对于需要完全控制媒体内容处理方式的场景是非常有用的，例如视频编辑、视频会议、视频流等。 视频处理工作流帧 是视频处理的基本单位，因此，在 WebCodecs 中，大多数类要么使用帧，要么产生帧。编码器将帧转为编码的 chunks（块），而解码器则做相反的事情。VideoFrame 有一个可以接受 CanvasImageSource 的构造函数来于其他的 Web API 很好的配合。所以它可以被用于 drawImage() 和 texImage2D() 等函数中. 此外，它还可以从 canvases, bitmaps, video elements 和 其他 video frames 中创建。 WebCodecs API 可以用 Insertable Streams API，让 WebCodecs 和 media stream tracks 一起工作。 MediaStreamTrackProcessor 将媒体流分解为单个帧。 MediaStreamTrackGenerator 从帧序列中创建媒体流。 WebCodecs 和 Web Workers按照设计，WebCodecs API 以异步方式在主线程之外完成所有繁重的工作。但是由于帧和 Chunk 的回调经常在一秒之类被调用多次，这可能导致主线程的混乱，导致网页 UI 的缓慢和卡顿，所以我们最好将处理工作放到 Worker 线程中。 而 ReadableStream 有一个简便的方法可以将来自媒体流的帧全部自动转移到 Worker 线程中，例如，从摄像头的来的流通过 MediaStreamTrackProcessor 获取到 ReadableStream 后，就可以在 Worker 线程中被 VideoEncoder 处理。 我们甚至可以通过 HTMLCanvasElement.transferControlToOffscreen 在主线程之外进行渲染。但如果所有的高级接口都不满足你的需求，VideoFrame 本身也是可以在不同的 Worker 中转移的。 WebCodecs 的编解码Encoding / 编码 我们从 VideoFrame 开始，有三种方法来构建视频帧。 从图片源，如 canvas, image bitmap, 或 video element. 1234const canvas = document.createElement(&quot;canvas&quot;);// Draw something on the canvas...const frameFromCanvas = new VideoFrame(canvas, { timestamp: 0 }); 使用 MediaStreamTrackProcessor 从 MediaStreamTrack 中提取帧 1234567891011const stream = await navigator.mediaDevices.getUserMedia({…});const track = stream.getTracks()[0];const trackProcessor = new MediaStreamTrackProcessor(track);const reader = trackProcessor.readable.getReader();while (true) { const result = await reader.read(); if (result.done) break; const frameFromCamera = result.value;} 从 BufferSource 中的原始二进制像素中创建帧 123456789101112131415161718const pixelSize = 4;const init = { timestamp: 0, codedWidth: 320, codedHeight: 200, format: &quot;RGBA&quot;,};const data = new Uint8Array(init.codedWidth * init.codedHeight * pixelSize);for (let x = 0; x &lt; init.codedWidth; x++) { for (let y = 0; y &lt; init.codedHeight; y++) { const offset = (y * init.codedWidth + x) * pixelSize; data[offset] = 0x7f; // Red data[offset + 1] = 0xff; // Green data[offset + 2] = 0xd4; // Blue data[offset + 3] = 0x0ff; // Alpha }}const frame = new VideoFrame(data, init); 无论它们来自哪里，帧都可以用 VideoEncoder 编码为 EncodedVideoChunk。而 VideoEncoder 需要两个参数： 两个函数，用来处理已编码数据块和产生的错误，传入后不可变。 编码器配置，用来配置输出的视频流参数，可以使用 configure() 进行修改。 如果你指定的配置不被浏览器支持，configure() 方法将抛出 NotSupportedError。所以我们建议你调用异步静态方法 VideoEncoder.isConfigSupported() 来预先检查你的配置是否被用户的浏览器支持。 12345678910111213141516171819202122const init = { output: handleChunk, error: (e) =&gt; { console.log(e.message); },};const config = { codec: &quot;vp8&quot;, width: 640, height: 480, bitrate: 2_000_000, // 2 Mbps framerate: 30,};const { supported } = await VideoEncoder.isConfigSupported(config);if (supported) { const encoder = new VideoEncoder(init); encoder.configure(config);} else { // Try another config.} 编码器设置好以后，你就可以通过 encode() 方法来传入帧了。configure() 和 encode() 都不需要等待实际工作结束，它们会立刻返回。编码器允许多个帧同时排队等待编码，encodeQueueSize 表示队列中有多少帧还未处理。 如果你传入的参数或调用方法的顺序不正确，则方法可以立刻抛出错误，也可以通过你设置的 error() 回调函数报告错误。如果编码成功，就会调用你设置的 output() 回调函数。这里需要强调一点，如果你的帧不再使用，你应该调用 close() 来释放资源。 12345678910111213141516171819202122let frameCounter = 0;const track = stream.getVideoTracks()[0];const trackProcessor = new MediaStreamTrackProcessor(track);const reader = trackProcessor.readable.getReader();while (true) { const result = await reader.read(); if (result.done) break; const frame = result.value; if (encoder.encodeQueueSize &gt; 2) { // Too many frames in flight, encoder is overwhelmed // let's drop this frame. frame.close(); } else { frameCounter++; const keyframe = frameCounter % 150 == 0; encoder.encode(frame, { keyFrame }); frame.close(); }} 最后，我们编写一个处理从编码器中得到的 Chunks 的函数，来完成最终的编码。一般来说，这个函数会把 Chunk 发往服务器，或者将 Chunk Muxing 到一个容器中来生成一个视频文件。 1234567891011121314151617181920212223function handleChunk(chunk, metadata) { if (metadata.decoderConfig) { // Decoder needs to be configured (or reconfigured) with new parameters // when metadata has a new decoderConfig. // Usually it happens in the beginning or when the encoder has a new // codec specific binary configuration. (VideoDecoderConfig.description). fetch(&quot;/upload_extra_data&quot;, { method: &quot;POST&quot;, headers: { &quot;Content-Type&quot;: &quot;application/octet-stream&quot; }, body: metadata.decoderConfig.description, }); } // actual bytes of encoded data const chunkData = new Uint8Array(chunk.byteLength); chunk.copyTo(chunkData); fetch(`/upload_chunk?timestamp=${chunk.timestamp}&amp;type=${chunk.type}`, { method: &quot;POST&quot;, headers: { &quot;Content-Type&quot;: &quot;application/octet-stream&quot; }, body: chunkData, });} 如果你需要确保所有的编码请求都已经完成，你可以调用异步函数 flush()。 1await encoder.flush(); Decoding / 解码 设置 VideoDecoder 的方法与设置 VideoEncoder 的类似：在创建解码器的是否传入两个参数，并调用 configure() 修改解码器参数。解码器的参数会因编码器的不同而不同，比如一个 H.264 解码器可能需要一个 AVCC 格式的二进制 blob，除非流是以 Annex B 编码的。(encoderConfig.avc = { format: &quot;annexb&quot; }) 1234567891011121314151617181920const init = { output: handleFrame, error: (e) =&gt; { console.log(e.message); },};const config = { codec: &quot;vp8&quot;, codedWidth: 640, codedHeight: 480,};const { supported } = await VideoDecoder.isConfigSupported(config);if (supported) { const decoder = new VideoDecoder(init); decoder.configure(config);} else { // Try another config.} 在准备好解码器后，你需要给它一个 EncodedVideoChunk。要创建 Chunk，你需要： 一个编码视频数据的 BufferSource Chunk 的开始时间戳，单位是微秒（Chunk 中第一个编码帧的媒体时间） Chunk 的类型： key，如果 Chunk 可以独立于之前的数据块进行解码，则为关键帧类型 delta Chunk 必须在其他块被解码以后才能被解码 编码器产生的所有 Chunk 都是可以用解码器解码的。之前提到的错误报告和方法的异步等事项，对解码器也是如此。 12345678910const responses = await downloadVideoChunksFromServer(timestamp);for (let i = 0; i &lt; responses.length; i++) { const chunk = new EncodedVideoChunk({ timestamp: responses[i].timestamp, type: responses[i].key ? &quot;key&quot; : &quot;delta&quot;, data: new Uint8Array(responses[i].body), }); decoder.decode(chunk);}await decoder.flush(); 现在，我们把解码好的帧展现在页面上。最好确保解码器的输出回调函数(handleFrame())迅速返回。在下面的例子中，它只是将一个帧添加到准备渲染的帧队列中。渲染是独立进行的，由两个步骤组成： 等待合适的时机来展示帧 在 Canvas 上绘制帧 一旦帧不再被使用，就调用 close() 来在 GC 之前释放底层内存，这将减少平均内存使用量。 1234567891011121314151617181920212223242526272829303132333435const canvas = document.getElementById(&quot;canvas&quot;);const ctx = canvas.getContext(&quot;2d&quot;);let pendingFrames = [];let underflow = true;let baseTime = 0;function handleFrame(frame) { pendingFrames.push(frame); if (underflow) setTimeout(renderFrame, 0);}function calculateTimeUntilNextFrame(timestamp) { if (baseTime == 0) baseTime = performance.now(); let mediaTime = performance.now() - baseTime; return Math.max(0, timestamp / 1000 - mediaTime);}async function renderFrame() { underflow = pendingFrames.length == 0; if (underflow) return; const frame = pendingFrames.shift(); // Based on the frame's timestamp calculate how much of real time waiting // is needed before showing the next frame. const timeUntilNextFrame = calculateTimeUntilNextFrame(frame.timestamp); await new Promise((r) =&gt; { setTimeout(r, timeUntilNextFrame); }); ctx.drawImage(frame, 0, 0); frame.close(); // Immediately schedule rendering of the next frame setTimeout(renderFrame, 0);} Dev Tips在 Chrome DevTools 中使用 Media Panel，查看媒体日志和调试 WebCodecs。 Demo下面这个例子展示了 Canvas 上的动画是如何被： 通过 MediaStreamTrackProcessor 以 25fps 的帧率采集到 ReadableStream 中 转发到 Worker 线程 编码成 H.264 的视频 再次解码为帧序列 使用 transferControlToOffscreen() 在另一个 Canvas 上渲染 new-webcodecs-blogpost-demo Other demosAlso check out our other demos: Decoding gifs with ImageDecoder Capture camera input to a file MP4 playback Other samples 使用 WebCodecs API兼容性检查检查对 WebCodecs 的支持: 123if (&quot;VideoEncoder&quot; in window) { // WebCodecs API is supported.} 请注意，WebCodecs API 只在 secure contexts 下运行，所以如果 self.isSecureContext 是 false，则检测会失败。 FeedbackThe Chrome team wants to hear about your experiences with the WebCodecs API. Tell us about the API designIs there something about the API that doesn’t work like you expected? Or arethere missing methods or properties that you need to implement your idea? Have aquestion or comment on the security model? File a spec issue on thecorresponding GitHub repo, or addyour thoughts to an existing issue. Report a problem with the implementationDid you find a bug with Chrome’s implementation? Or is the implementationdifferent from the spec? File a bug at new.crbug.com.Be sure to include as much detail as you can, simple instructions forreproducing, and enter Blink&gt;Media&gt;WebCodecs in the Components box.Glitch works great for sharing quick and easy repros. Show support for the APIAre you planning to use the WebCodecs API? Your public support helps theChrome team to prioritize features and shows other browser vendors how criticalit is to support them. Send emails to media-dev@chromium.org or send a tweetto @ChromiumDev using the hashtag#WebCodecsand let us know where and how you’re using it. Hero image byDenise Janson Unsplash.","link":"/Program/FrontEnd/WebCodecs/%E8%AE%BA%E4%BD%BF%E7%94%A8WebCodecs%E5%AF%B9%E8%A7%86%E9%A2%91%E8%BF%9B%E8%A1%8C%E5%A4%84%E7%90%86/"},{"title":"论如何在C++&#x2F;CLI中使用LINQ：记一次奇妙的C++大作业","text":"123456“救我，你一定要救我啊！” 我的同学对我如是说“¿”“C++要考试了！我整不来啊，我感觉挺简单的题”“......”“请你吃顿饭”“彳亍” 然后我就收到了这么两道题目： 准备 生成 20 个可被 2 或 5 整除，介于 1 至 100 之间的无重复随机数 Write a program (in C++) that generates and calculates 20 different random numbers that can be divided by 2 or 5. Random numbers must be generated from 1 to 200,the same number cannot be included in the array! The random number generation should be written in a function, i.e. the return value of the function should be an array! 随机产生 50 个人的工资表，并列出平均、最高低工资 Given a list in which the wages of 50 people are stored (in EUR). Write a program (in C++) that determines what the average wage is, who has the highest wage, who has the lowest wage, and who has the wages below average. 乍一看感觉这题确实就是初学者的题目，不过如果我使用普通的方法完成这题就不能称之为 “奇妙” 的大作业了，所以在犹豫一阵后我决定，使用 C++/CLI 来完成顺带再期待一下老师如果看到一堆 CLI 代码会作何反应（ 什么是 C++/CLIC++/CLI 是 C++ 的扩展，让我们可以同时享受 C# 和 C++ 的特性，是微软的就我个人而言，如果能用 C++/CLI 的话那我绝对不会用传统的 C++而且这玩意据我了解在中国没多少人用，或者说老外也不怎么用因为这玩意不上不下的，说实话 C# 的 unsafe 已经足够了 而且就目前为止，它仍然不能跨平台，Core 以后也无法生成独立程序了 寄 There isn’t currently a template for C++/CLI console or Windows applications that can be used with .NET Core.Instead you must put application entry point outside of the C++/CLI code. 所以作业是用 .NET Framework，不过本文使用 .NET Core所以查个资料，学习起来着实有点费力，以后有空可以专门讲讲 在撰写这篇文章时我目前心目中的优先级：C# &gt; Go &gt; Rust &gt; C++/CLI &gt; TS &gt; Java &gt; Python &gt; JS &gt; C++ &gt; C一天到晚只想用托管类语言的我已经是个废物了 话费不多的请直接跳到文章最后看结果接下来我会一点点讲述我的心路历程 做题 准备项目 用 VS 2022 创建一个新的 C# .NET Core 解决方案 在解决方案中添加一个 C++/CLI .NET Core 类库项目 这里如果使用空白项目的话需要自己配置很多东西而且微软对 C++/CLI 的支持是越来越不好了注意：CLI 项目更改以后需要生成一下才能在 C# 中看到变化 Func: GetRandoms首先我们来实现生成随机数的函数既然两个题目都要求了随机数的产生那么我们就专门做一个函数出来复用 尽可能多的复用我认为是一件非常好的习惯无论是在写代码，还是在生活中 函数定义12345678910using namespace System;using namespace Collections::Generic;namespace Aloento::CLILinq { public ref class CLILinq { public: static List&lt;int&gt;^ GetRandoms(int min, int max, int num) { return nullptr; }}; 这就是我的格式习惯，一股子 Java 味让我们来分析一下这个代码 这是在一个 .h 头文件里面的代码 声明函数的写法就是传统的 C++ namespace 和 using 都和 C# 一样，只不过把 . 变成 :: public 是为了让 C# 可以访问 ref 表明这是一个托管类 static 在我这里是 Helper 的统一写法 List&lt;int&gt;^ 返回一个 托管的 ^ List&lt;int&gt; 类型 托管类型都是从 C# 来的用 C++/CLI 托管的代码可以无缝在 C# 中使用，反之亦然 基本功能1234567891011121314static List&lt;int&gt;^ GetRandoms(int min, int max, int num) { auto random = Random::Shared; auto res = gcnew List&lt;int&gt;(num); for (auto i = 0; i &lt; num;) { auto r = random-&gt;Next(min, max); if (!res-&gt;Contains(r) &amp;&amp; (r % 2 == 0 || r % 5 == 0)) { i++; res-&gt;Add(r); } } return res;} Random::Shared 说明了我们现在在使用 .NET Core gcnew 表明了我们要生成一个 托管的 对象 if 语句用来排除重复的随机数，并且确保是 2 和 5 的倍数 i++ 表明我们已经得到了目标，所以我们要让 i 加一，不可以让 for 语句来完成 至此，有一些编程基础的都应该轻松看懂除了一些 CLI 的独特语法以外，其余的和传统 C++ / C# 并无太大区别 数据验证我们写代码的时候还是不要过于相信用户会按照你的想法来使用它毕竟 一个测试工程师走进一家酒吧，啥也没干酒吧就炸了 所以我们简单的加一句： 12if (max / 2 + max / 5 - (min / 2 + min / 5) &lt; num) throw gcnew ArgumentOutOfRangeException(); 这里我没有写具体的说明，不过正式写代码的时候，报错一定要写清楚原因 完全体123456789101112131415161718192021222324252627#pragma onceusing namespace System;using namespace Collections::Generic;namespace Aloento::CLILinq { public ref class CLILinq sealed { public: static List&lt;int&gt;^ GetRandoms(const int min, const int max, const int num) { if (max / 2 + max / 5 - (min / 2 + min / 5) &lt; num) { throw gcnew ArgumentOutOfRangeException(); } auto random = Random::Shared; auto res = gcnew List&lt;int&gt;(num); for (auto i = 0; i &lt; num;) { auto r = random-&gt;Next(min, max); if (!res-&gt;Contains(r) &amp;&amp; (r % 2 == 0 || r % 5 == 0)) { i++; res-&gt;Add(r); } } return res; } };} Func: GetWagesList我是把两道题一起做的，所以在这个 CLILinq 类里应该还有第二题的方法这个方法用来产生一些随机的 Name:Wages 键值对由于时间关系，我们这里生成的名字就直接按 ASCII 取了 123456789101112static Dictionary&lt;Char, double&gt;^ GetWagesList() { auto random = Random::Shared; auto dictionary = gcnew Dictionary&lt;Char, double&gt;(); Char c = 65; for (auto i = 0; i &lt; 50; i++) { auto wage = random-&gt;NextDouble() * 1000; dictionary-&gt;Add(c++, wage); } return dictionary;} 因为比较简单，所以直接上代码这里不用 char 而是 Char，这样可以直接被 C# 转字符串，方便输出 调用：第一题第一题的调用比较无脑，直接用就行了 123456static void Invoke() { auto randomList = GetRandoms(1, 200, 20); for each (auto num in randomList) { Console::WriteLine(num); }} LINQ：第二题第二题的实际逻辑就在这里也是 LINQ 出场的地方 （原谅我前面瞎扯了那么多） 我们先看实现代码 123456789101112131415161718static void Invoke() { auto wageDic = GetWagesList(); auto v = wageDic-&gt;Values; double sum = 0; for each (auto num in v) { sum += num; } auto avg = sum / 50; auto c = System::Globalization::CultureInfo::CultureInfo::CreateSpecificCulture(&quot;eu-ES&quot;); Console::WriteLine(&quot;Average: &quot; + avg.ToString(&quot;C&quot;, c) + &quot;\\n&quot;); auto ordered = Enumerable::OrderBy(wageDic, gcnew Func&lt;KeyValuePair&lt;Char, double&gt;, double&gt;(Select)); for each (auto one in ordered) { Console::WriteLine(one.Key + &quot;: &quot; + one.Value.ToString(&quot;C&quot;, c)); }} for each (auto num in v) 这部分其实就是 Enumerable.Aggregate 的简单实现毕竟要交作业，不能写的那么高级 （其实是嫌麻烦） CultureInfo 就是设置个格式化区域，这里转成欧洲的货币格式avg.ToString(&quot;C&quot;, c) 就是把 avg 转成 Currency LINQ接下来就是 Enumerable.OrderBy 的实现为了搞懂如何传入这个方法需要的参数，我搞了一个多小时到处找资料和 debug… 由于 C++ 11 之前就没有 lambda 表达式，后面有了也非常奇怪所以 LINQ 压根就没有提供类似的调用方式所以我们必须使用 gcnew Func() 的方式传递一个委托 首先，我们必须清楚 Func 的泛型类型到底是什么C++/CLI 在这里 IDE 是完全没有代码提示的，所以我们需要自行分析最好的方式就是在 C# 里面写同样的代码，然后看它们的类型 在这里，Dictionary&lt;Char, double&gt; 的单个元素的类型是 KeyValuePair&lt;Char, double&gt;所以很显然我们需要 Func&lt;KeyValuePair&lt;Char, double&gt;, double&gt;现在我们就有了它的类型，然后我们需要实现这个委托 这个委托是一个选择器，它的作用是从类型中选择出一个对象来作为排序的依据在我们这里，就是要从 KeyValuePair 中把 Value 选出来 随后就有了以下代码 123static double Select(KeyValuePair&lt;Char, double&gt; a) { return a.Value;} 非常简单，在特定情况下，你也可以尝试直接内联它之后的事情就非常简单了，该调用调用，该输出输出 实际上先贴一堆代码，可以粗略看看 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697namespace Aloento.SCLILinq;using System.Globalization;public sealed class SCLILinq { public static List&lt;int&gt; GetRandoms(int min, int max, int num) { Random random = null; List&lt;int&gt; list = null; if (max / 2 + max / 5 - (min / 2 + min / 5) &lt; num) { throw new ArgumentOutOfRangeException(); } random = Random.Shared; list = new List&lt;int&gt;(num); int num2 = 0; while (num2 &lt; num) { int num3 = random.Next(min, max); if (!list.Contains(num3) &amp;&amp; (num3 % 2 == 0 || num3 % 5 == 0)) { num2++; list.Add(num3); } } return list; } public static Dictionary&lt;char, double&gt; GetWagesList() { Random random = null; Dictionary&lt;char, double&gt; dictionary = null; random = Random.Shared; dictionary = new Dictionary&lt;char, double&gt;(); char c = 'A'; for (int i = 0; i &lt; 50; i++) { double value = random.NextDouble() * 1000.0; char key = c; c = (char)(c + 1); dictionary.Add(key, value); } return dictionary; } public static double Select(KeyValuePair&lt;char, double&gt; a) { return a.Value; } public static void Invoke() { List&lt;int&gt; list = null; Dictionary&lt;char, double&gt; dictionary = null; Dictionary&lt;char, double&gt;.ValueCollection valueCollection = null; CultureInfo cultureInfo = null; IOrderedEnumerable&lt;KeyValuePair&lt;char, double&gt;&gt; orderedEnumerable = null; IEnumerator&lt;KeyValuePair&lt;char, double&gt;&gt; enumerator = null; list = GetRandoms(1, 200, 20); List&lt;int&gt;.Enumerator enumerator2 = list.GetEnumerator(); while (enumerator2.MoveNext()) { int current = enumerator2.Current; Console.WriteLine(current); } Console.WriteLine(&quot;\\n-------------------------------\\n&quot;); dictionary = GetWagesList(); valueCollection = dictionary.Values; double num = 0.0; Dictionary&lt;char, double&gt;.ValueCollection.Enumerator enumerator3 = valueCollection.GetEnumerator(); while (enumerator3.MoveNext()) { double current2 = enumerator3.Current; num += current2; } double num2 = num / 50.0; cultureInfo = CultureInfo.CreateSpecificCulture(&quot;eu-ES&quot;); string str = &quot;\\n&quot;; double num3 = num2; string str2 = num3.ToString(&quot;C&quot;, cultureInfo); Console.WriteLine(string.Concat(&quot;Average: &quot; + str2, str)); orderedEnumerable = Enumerable.OrderBy(dictionary, new Func&lt;KeyValuePair&lt;char, double&gt;, double&gt;(Select)); enumerator = orderedEnumerable.GetEnumerator(); try { while (enumerator.MoveNext()) { KeyValuePair&lt;char, double&gt; current3 = enumerator.Current; double value = current3.Value; string format = &quot;C&quot;; string str3 = value.ToString(format, cultureInfo); string arg = &quot;: &quot;; Console.WriteLine(string.Concat(current3.Key + arg, str3)); } } finally { IEnumerator&lt;KeyValuePair&lt;char, double&gt;&gt; enumerator4 = enumerator; if (enumerator4 != null) { enumerator4.Dispose(); long num4 = 0L; } else { long num4 = 0L; } } }} 这是直接对 C++/CLI 生成的库反编译的结果我们可以发现，这就相当于是写了一堆 C# 而已如果带指针之类的，就是 unsafe所以：没必要，别用 C++/CLI 适用范围 如果你想 Wrapper 一个 C / C++ 的库给 C# 用 如果你想让 .NET 与其他语言一起工作 让 C++ 享受 .NET 的生态 如果你闲得慌想找点事情干 在大部分情况下，C++/CLI 的存在都是为了高效的让 C# 与 C / C++ 交互而使用使用它可以让你的 .NET 项目享受到 C++ 全套的生态，反之亦然毕竟 P/Invoke 并不优雅 在托管类语言中，C++/CLI 在一定程度上让 C# 成了最容易与 C / C++ 交互的语言进而让它也更容易与能够和 C / C++ 交互的语言交互 使用它，你需要同时掌握 C# 和 C++而且在很多时候，IDE 不会给你有效的提示所以学习它需要很多时间来尝试 结论12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970using namespace System;using namespace Linq;using namespace Collections::Generic;namespace Aloento::CLILinq { public ref class CLILinq sealed { public: static List&lt;int&gt;^ GetRandoms(const int min, const int max, const int num) { if (max / 2 + max / 5 - (min / 2 + min / 5) &lt; num) { throw gcnew ArgumentOutOfRangeException(); } auto random = Random::Shared; auto res = gcnew List&lt;int&gt;(num); for (auto i = 0; i &lt; num;) { auto r = random-&gt;Next(min, max); if (!res-&gt;Contains(r) &amp;&amp; (r % 2 == 0 || r % 5 == 0)) { i++; res-&gt;Add(r); } } return res; } static Dictionary&lt;Char, double&gt;^ GetWagesList() { auto random = Random::Shared; auto dictionary = gcnew Dictionary&lt;Char, double&gt;(); Char c = 65; for (auto i = 0; i &lt; 50; i++) { auto wage = random-&gt;NextDouble() * 1000; dictionary-&gt;Add(c++, wage); } return dictionary; } static double Select(KeyValuePair&lt;Char, double&gt; a) { return a.Value; } static void Invoke() { auto randomList = GetRandoms(1, 200, 20); for each (auto num in randomList) { Console::WriteLine(num); } Console::WriteLine(&quot;\\n-------------------------------\\n&quot;); auto wageDic = GetWagesList(); auto v = wageDic-&gt;Values; double sum = 0; for each (auto num in v) { sum += num; } auto avg = sum / 50; auto c = System::Globalization::CultureInfo::CultureInfo::CreateSpecificCulture(&quot;eu-ES&quot;); Console::WriteLine(&quot;Average: &quot; + avg.ToString(&quot;C&quot;, c) + &quot;\\n&quot;); auto ordered = Enumerable::OrderBy(wageDic, gcnew Func&lt;KeyValuePair&lt;Char, double&gt;, double&gt;(Select)); for each (auto one in ordered) { Console::WriteLine(one.Key + &quot;: &quot; + one.Value.ToString(&quot;C&quot;, c)); } } };}","link":"/Diary/%E8%AE%BA%E5%A6%82%E4%BD%95%E5%9C%A8CPPCLI%E4%B8%AD%E4%BD%BF%E7%94%A8LINQ%E4%B9%8B%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%A5%87%E5%A6%99%E7%9A%84CPP%E5%A4%A7%E4%BD%9C%E4%B8%9A/"}],"tags":[{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"笔记","slug":"笔记","link":"/tags/%E7%AC%94%E8%AE%B0/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"习题","slug":"习题","link":"/tags/%E4%B9%A0%E9%A2%98/"},{"name":"SQLServer","slug":"SQLServer","link":"/tags/SQLServer/"},{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"},{"name":"数值方法","slug":"数值方法","link":"/tags/%E6%95%B0%E5%80%BC%E6%96%B9%E6%B3%95/"},{"name":"云","slug":"云","link":"/tags/%E4%BA%91/"},{"name":"OpenStack","slug":"OpenStack","link":"/tags/OpenStack/"},{"name":"图灵机","slug":"图灵机","link":"/tags/%E5%9B%BE%E7%81%B5%E6%9C%BA/"},{"name":"逻辑","slug":"逻辑","link":"/tags/%E9%80%BB%E8%BE%91/"},{"name":"编程","slug":"编程","link":"/tags/%E7%BC%96%E7%A8%8B/"},{"name":"C#","slug":"C","link":"/tags/C/"},{"name":"SQL","slug":"SQL","link":"/tags/SQL/"},{"name":"面试","slug":"面试","link":"/tags/%E9%9D%A2%E8%AF%95/"},{"name":"前端","slug":"前端","link":"/tags/%E5%89%8D%E7%AB%AF/"},{"name":"翻译","slug":"翻译","link":"/tags/%E7%BF%BB%E8%AF%91/"},{"name":"音视频","slug":"音视频","link":"/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"},{"name":"WebCodecs","slug":"WebCodecs","link":"/tags/WebCodecs/"},{"name":"JS","slug":"JS","link":"/tags/JS/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"CLI","slug":"CLI","link":"/tags/CLI/"},{"name":"LINQ","slug":"LINQ","link":"/tags/LINQ/"},{"name":".NET","slug":"NET","link":"/tags/NET/"},{"name":"OrderBy","slug":"OrderBy","link":"/tags/OrderBy/"}],"categories":[{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"},{"name":"Database","slug":"Database","link":"/categories/Database/"},{"name":"Math","slug":"Math","link":"/categories/Math/"},{"name":"Cloud","slug":"Cloud","link":"/categories/Cloud/"},{"name":"TM","slug":"Algorithm/TM","link":"/categories/Algorithm/TM/"},{"name":"MSSQL","slug":"Database/MSSQL","link":"/categories/Database/MSSQL/"},{"name":"Theory","slug":"Database/Theory","link":"/categories/Database/Theory/"},{"name":"Logic","slug":"Math/Logic","link":"/categories/Math/Logic/"},{"name":"Matlab","slug":"Math/Matlab","link":"/categories/Math/Matlab/"},{"name":"Program","slug":"Program","link":"/categories/Program/"},{"name":"OpenStack","slug":"Cloud/OpenStack","link":"/categories/Cloud/OpenStack/"},{"name":"FrontEnd","slug":"Program/FrontEnd","link":"/categories/Program/FrontEnd/"},{"name":"C++","slug":"Program/C","link":"/categories/Program/C/"},{"name":"WebCodecs","slug":"Program/FrontEnd/WebCodecs","link":"/categories/Program/FrontEnd/WebCodecs/"},{"name":"CLI","slug":"Program/C/CLI","link":"/categories/Program/C/CLI/"},{"name":"Diary","slug":"Diary","link":"/categories/Diary/"}],"pages":[]}