{"pages":[],"posts":[{"title":"OpenStack 学习日记 | 第一天","text":"由于本人最近需要从事 OpenStack 相关工作，所以急需对 OpenStack 进行学习本系列日记仅作为本人的学习记录学习材料为 《每天 5 分钟玩转 OpenStack》 学习前需要知道的OpenStack 涉及的范围广计算，储存，网络，虚拟化，可用性，安全性，灾备等一些列关于 IT 基础设施的范围 OpenStack 都有涵盖 OpenStack 是一个平台它的各个组件都采用了 Driver 架构，支持各种的具体实现。比如 OpenStack 储存服务 Cinder 只定义抽象 API，而具体实现交给具体的 Driver比如基于 LVM 的 iSCSI， EMC，或者开源的 Ceph，GlusterFS 等等 这里我们可以类比到 Entity Framework，它只定义了上层的 API而具体的数据库操作交给了你指定的 Driver，如 Npgsql OpenStack 是一个分布式系统这也是学习它的比较大的阻碍，因为它原生就是分布式的，各个组件拆的很散不过我们学习的时候都使用 All-in-one 部署模式 我们要学习的内容 预备知识 虚拟化 云计算 核心组件 架构 认证 Keystone 镜像 Glance 计算 Nova 储存 Cinder 网络 Neutron 写在最前面 – 每天 5 分钟玩转 OpenStack（1） 虚拟化虚拟化是云计算的基础虚拟机(Guest)共享物理机(Host)的资源，比如 CPU，内存，硬盘，网络，磁盘等 这主要通过 Hypervisor 来实现，比如 KVM，Xen，VMWare 等等 1 类虚拟化Hypervisor 是一个操作系统，直接安装在物理机上最典型的就是 Windows 上的 Hyper-V其他的还有 Xen 和 ESXi 2 类虚拟化Hypervisor 作为操作系统中的一个程序或者模块运行最典型的有 KVM 和 VMware Workstation 对比理论上讲，1 类虚拟化性能比 2 类的要好而 2 类虚拟化会更灵活，比如支持嵌套虚拟化 KVM对我来说 KVM 已经是一个听过无数次的词了OpenStack 对 KVM 的支持最好，全称叫 Kernel-based Virtual Machine也就是说它基于 Linux 的内核实现，它有一个模块叫 kvm.ko，只用于管理虚拟 CPU 和内存 那我们就要问了，那 IO 虚拟化呢，这个交给 Linux 内核与 QEMU 实现 Libvirt这是 KVM 的管理工具，包含三个模块后台 daemon，api 库，和 命令行工具 virshvirsh 和 virt-manager 是一定要会用的 虚拟化 – 每天 5 分钟玩转 OpenStack（2） 安装我们使用 Ubuntu，安装 KVM 需要的包 1sudo apt install qemu-kvm qemu-system libvirt-bin virt-manager bridge-util qemu-kvm 和 qemu-system 是 KVM 和 QEMU 的核心包，提供 CPU、内存和 IO 虚拟化功能 libvirt-bin 就是 libvirt，用于管理 KVM 等 Hypervisor virt-manager 是 KVM 图形化管理工具 bridge-utils 和 vlan，主要是网络虚拟化需要，KVM 网络虚拟化的实现是基于 linux-bridge 和 VLAN 准备 KVM 实验环境 – 每天 5 分钟玩转 OpenStack（3） 对于我自己来说，使用 KVM 等本来就是轻车熟路了，所以我跳过这一部分 启动第一个 KVM 虚机 – 每天 5 分钟玩转 OpenStack（4） 远程管理 KVM 虚机 – 每天 5 分钟玩转 OpenStack（5） CPU 虚拟化KVM 虚拟机 在宿主机中其实是一个 QEMU-KVM 进程，与其他进程一同被调度虚拟中的每一个 vCPU 就对应 QEMU-KVM 进程中的一个 线程 这就表明 vCPU 的总数可以超过物理机的 CPU 总数，这叫 CPU OverCommit 超配这个特性让虚拟机能充分利用宿主机的 CPU 资源，但是这也导致了 VPS 中令人诟病的超售行为 内存虚拟化这一段算是我看的比较迷糊的一段不过说到底也不需要了解多少，只需要知道它并不是像一个普通程序那样分配内存即可中间存在大量的内存地址转换，各个厂家也为了转换效率做了很多特殊的优化Guest Virtual Address -&gt; Guest Physical Address -&gt;Host Virtual Address -&gt; Host Physical Address 内存也是可以超配的，所以超售机一大堆 CPU 和内存虚拟化原理 – 每天 5 分钟玩转 OpenStack（6） 储存虚拟化目录类型文件目录类型是最常用的KVM 将宿主机目录 /var/lib/libvirt/images/ 作为默认的 Storage Pool 这个目录下面的每一个文件就是一个 Volume说白了就是用文件来当磁盘，我们最常用的方式存储方便、移植性好、可复制、可远程访问KVM 支持 raw, qcow2, qed, vmdk, vdl 格式的磁盘文件 KVM 存储虚拟化 – 每天 5 分钟玩转 OpenStack（7） LVM 类型这个用的不多，也就是把实际的磁盘划出来给虚拟机用，跳过 LVM 类型的 Storage Pool – 每天 5 分钟玩转 OpenStack（8） 网络虚拟化这章是虚拟化中最复杂，最重要的部分 Linux Bridge其实就是网桥，用来做 TCP/IP 二层协议交换的模块对于我来说这玩意接触的也比较多 KVM 网络虚拟化基础 – 每天 5 分钟玩转 OpenStack（9） 这里记录几个重点 修改 /etc/network/interfaces 以配置网桥 使用 ifconfig 查看 IP 配置 brctl show 查看当前 Linux Bridge 的配置 动手实践虚拟网络 – 每天 5 分钟玩转 OpenStack（10） virbr0virbr0 是 KVM 默认创建的一个 Bridge，其作用是为连接其上的虚机网卡提供 NAT 访问外网的功能。virbr0 默认分配了一个 IP 192.168.122.1，并为连接其上的其他虚拟网卡提供 DHCP 服务。这没啥好难的就是一个 NAT 网关而已 理解 Virbr0 – 每天 5 分钟玩转 OpenStack（11） VLAN也就是虚拟局域网，隔离用，二层交换机，不需要想的太复杂在一张网卡下面划分多个空间而已 Linux 如何实现 VLAN – 每天 5 分钟玩转 OpenStack（12） 具体如何配置就等到要用的时候现查不过还是修改 /etc/network/interfaces 动手实践 Linux VLAN – 每天 5 分钟玩转 OpenStack（13） 云计算 IaaS（Infrastructure as a Service）提供的服务是虚拟机典型的有 AWS，OpenStack 等 PaaS（Platform as a Service）提供的服务是应用的运行环境比如 Github Pages SaaS（Software as a Service）提供的是应用服务对象通常是最终用户，就像 Gmail OpenStack is a cloud operating system that controls large pools of compute, storage,and networking resources throughout a datacenter, all managed through a dashboard that gives administrators control while empowering their users to provision resources through a web interface. OpenStack 对数据中心的计算、存储和网络资源进行统一管理 云计算与 OpenStack – 每天 5 分钟玩转 OpenStack（14） OpenStack写日记的时候最新版本是 Yoga，下一个版本是 Zed 首先列出模块列表 名称 用途 中文 cyborg Accelerator Life Cycle Management 用于管理硬件和软件加速资源（如 GPU）的框架 freezer Backup, Restore, and Disaster Recovery service 备份、恢复和灾难恢复服务 ironic Bare Metal service 裸机服务 cinder Block Storage service 存储服务 ceilometer Data collection service 数据收集服务 kuryr Bridge between container framework and OpenStack abstractions 容器框架和 OpenStack 抽象之间的桥梁 keystone Identity Service 管理身份验证、服务规则和服务令牌功能 senlin Clustering service 集群服务 storlets Compute inside Object Storage service 对象存储服务中的计算 nova Compute service 计算服务，管理 VM 的生命周期 neutron network connectivity as a service 网络连接服务，负责创建和管理 L2、L3 网络， 为 VM 提供虚拟网络和物理网络连接 zun Containers service 容器服务 horizon Dashboard 仪表盘 designate DNS service DNS 服务 ec2-api EC2 API compatibility layer EC2 API 兼容层 glance Image service 启动镜像服务 watcher Infrastructure Optimization service 基础设施优化服务 masakari Instances High Availability Service 实例高可用性服务 barbican Key Manager service 密钥管理器服务 octavia Load-balancer service 负载均衡器服务 neutron Networking service 网络服务 tacker NFV Orchestration service NFV 管理器，用于监视、配置 NFV 和管理 NFV 全生命周期 swift Object Storage service 对象存储服务 heat Orchestration service REST 服务，能够基于一个声明式的模板，通过装配引擎装配组合若干个云应用 placement Placement service REST API 堆栈和数据模型，用于跟踪资源提供程序的清单和使用情况，以及不同的资源类别 cloudkitty Rating service 计费服务 vitrage RCA (Root Cause Analysis) service 用于组织、分析和扩展 OpenStack 的告警和事件 blazar Resource reservation service 资源保留服务 manila Shared File Systems service 共享文件系统服务 aodh Telemetry Alarming services 遥测报警服务 ceilometer Telemetry Data Collection service 遥测数据采集服务 https://www.openstack.org/software/project-navigator/这么一大堆模块一时半会肯定是学不完的，我们挑重点学习搞清楚 OpenStack 是图和对计算，网络，储存资源进行管理的 核心组件 Nova 管理计算资源，是核心服务。 Neutron 管理网络资源，是核心服务。 Glance 为 VM 提供 OS 镜像，属于存储范畴，是核心服务。 Cinder 提供块存储，VM 怎么也得需要数据盘吧，是核心服务。 Swift 提供对象存储，不是必须的，是可选服务。 Keystone 认证服务，没它 OpenStack 转不起来，是核心服务。 Ceilometer 监控服务，不是必须的，可选服务。 Horizon 大家都需要一个操作界面吧。 OpenStack 本身是一个分布式系统，不但各个服务可以分布部署，服务中的组件也可以分布部署这也使得 OpenStack 比一般系统复杂，学习难度也更大 OpenStack 架构 – 每天 5 分钟玩转 OpenStack（15） 搭建 Dev 环境我一般使用 MicroStack 一键解决 搭建 OpenStack 实验环境 – 每天 5 分钟玩转 OpenStack（16） 部署 DevStack – 每天 5 分钟玩转 OpenStack（17） Keystone对于天天跟 OAuth 打交道的我这部分其实可以跳过 Authentication 解决的是“你是谁？”的问题 Authorization 解决的是“你能干什么？”的问题 Keystone 负责管理和维护每个 Service 的 Endpoint Service 通过 Endpoint 暴露自己的 API 理解 Keystone 核心概念 – 每天 5 分钟玩转 OpenStack（18） 通过例子学习 Keystone – 每天 5 分钟玩转 OpenStack（19） Glance这玩意还储存快照 Glance 支持多种 backend，包括 A directory on a local file system（这是默认配置） GridFS Ceph RBD Amazon S3 Sheepdog OpenStack Block Storage (Cinder) OpenStack Object Storage (Swift) VMware ESX 没啥好讲的，需要用到时候现查，而且大部分操作都可以通过 GUI 完成 理解 Glance – 每天 5 分钟玩转 OpenStack（20） 创建 Image – 每天 5 分钟玩转 OpenStack（21） 如何使用 OpenStack CLI – 每天 5 分钟玩转 OpenStack（22） NovaCompute Service Nova 是 OpenStack 最核心的服务，负责维护和管理云环境的计算资源。OpenStack 作为 IaaS 的云操作系统，虚拟机生命周期管理也就是通过 Nova 来实现的。 nova-api接收和响应客户的 API 调用， 还支持 Amazon EC2 API nova-scheduler虚机调度服务，负责决定在哪个计算节点上运行虚机 nova-compute管理虚机的核心服务，通过调用 Hypervisor API 实现虚机生命周期管理 nova-conductornova-compute 经常需要更新数据库，比如更新虚机的状态出于安全性和伸缩性的考虑，nova-compute 并不会直接访问数据库 nova-console用户可以通过多种方式访问虚机的控制台：nova-novncproxy，基于 Web 浏览器的 VNC 访问nova-spicehtml5proxy，基于 HTML5 浏览器的 SPICE 访问nova-xvpnvncproxy，基于 Java 客户端的 VNC 访问 nova-consoleauth负责对访问虚机控制台请求提供 Token 认证 nova-cert提供 x509 证书支持 总之我越看越觉得 OpenStack 就是在 Hypervisor 上套了一层又一层而且我个人对 Python 写的大型项目是完全没有好感 理解 Nova 架构 – 每天 5 分钟玩转 OpenStack（23） 部署方案哪里有那么复杂，专门负责装 VPS 的 Hypervisor 就装 nova-compute然后其他服务放别处就行了 OpenStack 默认是用 RabbitMQ 作为 Message Queue，好评 Nova 组件如何协同工作 – 每天 5 分钟玩转 OpenStack（24） 设计思路说那么多到底还是解耦，疯狂解耦然后各种抽象 API，疯狂增加项目体积再加入各种调度，最离谱的是居然默认用 MySQL当然对大型集群这都不算什么 OpenStack 通用设计思路 – 每天 5 分钟玩转 OpenStack（25） 组件 Nova 组件详解 – 每天 5 分钟玩转 OpenStack（26） flavor 就是 plan，选 VPS 配置 Filter scheduler 是 nova-scheduler 默认的调度器 通过过滤器（filter）选择满足条件的计算节点 通过权重计算（weighting）选择在最优（权重值最大）的计算节点上创建 Instance RetryFilter 的作用是刷掉之前已经调度过的节点 为提高容灾性和提供隔离服务，可以将计算节点划分到不同的 Availability Zone 中 RamFilter 将不能满足 flavor 内存需求的计算节点过滤掉 DiskFilter 将不能满足 flavor 磁盘需求的计算节点过滤掉 CoreFilter 将不能满足 flavor vCPU 需求的计算节点过滤掉 ComputeFilter 保证只有 nova-compute 服务正常工作的计算节点才能够被 nova-scheduler 调度 ComputeCapabilitiesFilter 根据计算节点的特性来筛选可以从 Metadata 中筛选架构之类的 ImagePropertiesFilter 根据所选 image 的属性来筛选匹配的计算节点镜像也带 Metadata，可以限定比如只能运行在 kvm 上之类的 ServerGroupAntiAffinityFilter 可以尽量将 Instance 分散部署到不同的节点上 ServerGroupAffinityFilter 会尽量将 instance 部署到同一个计算节点上 nova-scheduler 的默认实现是根据计算节点空闲的内存量计算权重值：空闲内存越多，权重越大，instance 将被部署到当前空闲内存最多的计算节点上 看 Nova-Scheduler 如何选择计算节点 – 每天 5 分钟玩转 OpenStack（27） 每隔一段时间，nova-compute 就会报告当前计算节点的资源使用情况和自己的状态 这不就是微服务么，eureka 既视感 instance 的 launch、shutdown、reboot、suspend、resume、terminate、resize、migration、snapshot Nova-Compute 部署 Instance 详解 – 每天 5 分钟玩转 OpenStack（28） 生命周期OpenStack 的日志格式都是统一的，如下&lt;时间戳&gt;&lt;日志等级&gt;&lt;代码模块&gt;&lt;Request ID&gt;&lt;日志内容&gt;&lt;源代码位置&gt; 教你看懂 OpenStack 日志 – 每天 5 分钟玩转 OpenStack（29）Launch 和 Shut Off 操作详解 – 每天 5 分钟玩转 OpenStack（30）Start Instance 操作详解 – 每天 5 分钟玩转 OpenStack（31）Nova reboot 和 lock 操作 – 每天 5 分钟玩转 OpenStack（32）Terminate Instance 操作详解 – 每天 5 分钟玩转 OpenStack（33）Pause/Resume Instance 操作详解 – 每天 5 分钟玩转 OpenStack（34）Nova Suspend/Rescue 操作详解 – 每天 5 分钟玩转 OpenStack（35）Snapshot Instance 操作详解 – 每天 5 分钟玩转 OpenStack（36）Rebuild Instance 操作详解 – 每天 5 分钟玩转 OpenStack（37）Shelve Instance 操作详解 – 每天 5 分钟玩转 OpenStack（38）Unshelve Instance 操作详解 – 每天 5 分钟玩转 OpenStack（39）Migrate Instance 操作详解 – 每天 5 分钟玩转 OpenStack（40）Resize Instance 操作详解 – 每天 5 分钟玩转 OpenStack（41）Live Migrate 操作 – 每天 5 分钟玩转 OpenStack（42）计算节点宕机了怎么办？Evacuate - 每天 5 分钟玩转 OpenStack（43）1 张图秒懂 Nova 16 种操作 – 每天 5 分钟玩转 OpenStack（44） 上面这一大堆操作都是属于遇到了现查来得更快，而且很多都浅显易懂，盲猜也能用个大概 Cinder","link":"/Diary/OpenStack-%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0-%E7%AC%AC%E4%B8%80%E5%A4%A9/"},{"title":"论使用WebCodecs对视频进行处理","text":"原文 更新于 2022-02-10，由 Aloento 翻译，具体以原文为准 现代的 Web 技术为视频提供了丰富的处理能力，例如 Media Stream API、Media Recording API、Media Source API, 和 WebRTC API 等，它们提供了丰富的工具以便 录制、传输、回放视频流。这些 API 虽然封装了很多高级功能以便方便的完成既定任务，但它们并不能让你处理视频流的内部细节，如 按帧处理 和 处理未 Muxed 的视频或音频块等。为了实现以上目的，你不得不使用一些类似 WebAssembly 的方式来把浏览器本就自带的编解码器（通常它们都有硬件加速）又一次的引入，这属实是对资源的浪费。 而 WebCodecs API 为程序员提供了使用浏览器自带编解码器的能力，来提高你的工作流效率，具体而言： 音视频的编解码 视频原始帧 图像解码 WebCodecs API 对于需要完全控制媒体内容处理方式的场景是非常有用的，例如视频编辑、视频会议、视频流等。 视频处理工作流帧 是视频处理的基本单位，因此，在 WebCodecs 中，大多数类要么使用帧，要么产生帧。编码器将帧转为编码的 chunks（块），而解码器则做相反的事情。VideoFrame 有一个可以接受 CanvasImageSource 的构造函数来于其他的 Web API 很好的配合。所以它可以被用于 drawImage() 和 texImage2D() 等函数中. 此外，它还可以从 canvases, bitmaps, video elements 和 其他 video frames 中创建。 WebCodecs API 可以用 Insertable Streams API，让 WebCodecs 和 media stream tracks 一起工作。 MediaStreamTrackProcessor 将媒体流分解为单个帧。 MediaStreamTrackGenerator 从帧序列中创建媒体流。 WebCodecs 和 Web Workers按照设计，WebCodecs API 以异步方式在主线程之外完成所有繁重的工作。但是由于帧和 Chunk 的回调经常在一秒之类被调用多次，这可能导致主线程的混乱，导致网页 UI 的缓慢和卡顿，所以我们最好将处理工作放到 Worker 线程中。 而 ReadableStream 有一个简便的方法可以将来自媒体流的帧全部自动转移到 Worker 线程中，例如，从摄像头的来的流通过 MediaStreamTrackProcessor 获取到 ReadableStream 后，就可以在 Worker 线程中被 VideoEncoder 处理。 我们甚至可以通过 HTMLCanvasElement.transferControlToOffscreen 在主线程之外进行渲染。但如果所有的高级接口都不满足你的需求，VideoFrame 本身也是可以在不同的 Worker 中转移的。 WebCodecs 的编解码Encoding / 编码 我们从 VideoFrame 开始，有三种方法来构建视频帧。 从图片源，如 canvas, image bitmap, 或 video element. 1234const canvas = document.createElement(&quot;canvas&quot;);// Draw something on the canvas...const frameFromCanvas = new VideoFrame(canvas, { timestamp: 0 }); 使用 MediaStreamTrackProcessor 从 MediaStreamTrack 中提取帧 1234567891011const stream = await navigator.mediaDevices.getUserMedia({…});const track = stream.getTracks()[0];const trackProcessor = new MediaStreamTrackProcessor(track);const reader = trackProcessor.readable.getReader();while (true) { const result = await reader.read(); if (result.done) break; const frameFromCamera = result.value;} 从 BufferSource 中的原始二进制像素中创建帧 123456789101112131415161718const pixelSize = 4;const init = { timestamp: 0, codedWidth: 320, codedHeight: 200, format: &quot;RGBA&quot;,};const data = new Uint8Array(init.codedWidth * init.codedHeight * pixelSize);for (let x = 0; x &lt; init.codedWidth; x++) { for (let y = 0; y &lt; init.codedHeight; y++) { const offset = (y * init.codedWidth + x) * pixelSize; data[offset] = 0x7f; // Red data[offset + 1] = 0xff; // Green data[offset + 2] = 0xd4; // Blue data[offset + 3] = 0x0ff; // Alpha }}const frame = new VideoFrame(data, init); 无论它们来自哪里，帧都可以用 VideoEncoder 编码为 EncodedVideoChunk。而 VideoEncoder 需要两个参数： 两个函数，用来处理已编码数据块和产生的错误，传入后不可变。 编码器配置，用来配置输出的视频流参数，可以使用 configure() 进行修改。 如果你指定的配置不被浏览器支持，configure() 方法将抛出 NotSupportedError。所以我们建议你调用异步静态方法 VideoEncoder.isConfigSupported() 来预先检查你的配置是否被用户的浏览器支持。 12345678910111213141516171819202122const init = { output: handleChunk, error: (e) =&gt; { console.log(e.message); },};const config = { codec: &quot;vp8&quot;, width: 640, height: 480, bitrate: 2_000_000, // 2 Mbps framerate: 30,};const { supported } = await VideoEncoder.isConfigSupported(config);if (supported) { const encoder = new VideoEncoder(init); encoder.configure(config);} else { // Try another config.} 编码器设置好以后，你就可以通过 encode() 方法来传入帧了。configure() 和 encode() 都不需要等待实际工作结束，它们会立刻返回。编码器允许多个帧同时排队等待编码，encodeQueueSize 表示队列中有多少帧还未处理。 如果你传入的参数或调用方法的顺序不正确，则方法可以立刻抛出错误，也可以通过你设置的 error() 回调函数报告错误。如果编码成功，就会调用你设置的 output() 回调函数。这里需要强调一点，如果你的帧不再使用，你应该调用 close() 来释放资源。 12345678910111213141516171819202122let frameCounter = 0;const track = stream.getVideoTracks()[0];const trackProcessor = new MediaStreamTrackProcessor(track);const reader = trackProcessor.readable.getReader();while (true) { const result = await reader.read(); if (result.done) break; const frame = result.value; if (encoder.encodeQueueSize &gt; 2) { // Too many frames in flight, encoder is overwhelmed // let's drop this frame. frame.close(); } else { frameCounter++; const keyframe = frameCounter % 150 == 0; encoder.encode(frame, { keyFrame }); frame.close(); }} 最后，我们编写一个处理从编码器中得到的 Chunks 的函数，来完成最终的编码。一般来说，这个函数会把 Chunk 发往服务器，或者将 Chunk Muxing 到一个容器中来生成一个视频文件。 1234567891011121314151617181920212223function handleChunk(chunk, metadata) { if (metadata.decoderConfig) { // Decoder needs to be configured (or reconfigured) with new parameters // when metadata has a new decoderConfig. // Usually it happens in the beginning or when the encoder has a new // codec specific binary configuration. (VideoDecoderConfig.description). fetch(&quot;/upload_extra_data&quot;, { method: &quot;POST&quot;, headers: { &quot;Content-Type&quot;: &quot;application/octet-stream&quot; }, body: metadata.decoderConfig.description, }); } // actual bytes of encoded data const chunkData = new Uint8Array(chunk.byteLength); chunk.copyTo(chunkData); fetch(`/upload_chunk?timestamp=${chunk.timestamp}&amp;type=${chunk.type}`, { method: &quot;POST&quot;, headers: { &quot;Content-Type&quot;: &quot;application/octet-stream&quot; }, body: chunkData, });} 如果你需要确保所有的编码请求都已经完成，你可以调用异步函数 flush()。 1await encoder.flush(); Decoding / 解码 设置 VideoDecoder 的方法与设置 VideoEncoder 的类似：在创建解码器的是否传入两个参数，并调用 configure() 修改解码器参数。解码器的参数会因编码器的不同而不同，比如一个 H.264 解码器可能需要一个 AVCC 格式的二进制 blob，除非流是以 Annex B 编码的。(encoderConfig.avc = { format: &quot;annexb&quot; }) 1234567891011121314151617181920const init = { output: handleFrame, error: (e) =&gt; { console.log(e.message); },};const config = { codec: &quot;vp8&quot;, codedWidth: 640, codedHeight: 480,};const { supported } = await VideoDecoder.isConfigSupported(config);if (supported) { const decoder = new VideoDecoder(init); decoder.configure(config);} else { // Try another config.} 在准备好解码器后，你需要给它一个 EncodedVideoChunk。要创建 Chunk，你需要： 一个编码视频数据的 BufferSource Chunk 的开始时间戳，单位是微秒（Chunk 中第一个编码帧的媒体时间） Chunk 的类型： key，如果 Chunk 可以独立于之前的数据块进行解码，则为关键帧类型 delta Chunk 必须在其他块被解码以后才能被解码 编码器产生的所有 Chunk 都是可以用解码器解码的。之前提到的错误报告和方法的异步等事项，对解码器也是如此。 12345678910const responses = await downloadVideoChunksFromServer(timestamp);for (let i = 0; i &lt; responses.length; i++) { const chunk = new EncodedVideoChunk({ timestamp: responses[i].timestamp, type: responses[i].key ? &quot;key&quot; : &quot;delta&quot;, data: new Uint8Array(responses[i].body), }); decoder.decode(chunk);}await decoder.flush(); 现在，我们把解码好的帧展现在页面上。最好确保解码器的输出回调函数(handleFrame())迅速返回。在下面的例子中，它只是将一个帧添加到准备渲染的帧队列中。渲染是独立进行的，由两个步骤组成： 等待合适的时机来展示帧 在 Canvas 上绘制帧 一旦帧不再被使用，就调用 close() 来在 GC 之前释放底层内存，这将减少平均内存使用量。 1234567891011121314151617181920212223242526272829303132333435const canvas = document.getElementById(&quot;canvas&quot;);const ctx = canvas.getContext(&quot;2d&quot;);let pendingFrames = [];let underflow = true;let baseTime = 0;function handleFrame(frame) { pendingFrames.push(frame); if (underflow) setTimeout(renderFrame, 0);}function calculateTimeUntilNextFrame(timestamp) { if (baseTime == 0) baseTime = performance.now(); let mediaTime = performance.now() - baseTime; return Math.max(0, timestamp / 1000 - mediaTime);}async function renderFrame() { underflow = pendingFrames.length == 0; if (underflow) return; const frame = pendingFrames.shift(); // Based on the frame's timestamp calculate how much of real time waiting // is needed before showing the next frame. const timeUntilNextFrame = calculateTimeUntilNextFrame(frame.timestamp); await new Promise((r) =&gt; { setTimeout(r, timeUntilNextFrame); }); ctx.drawImage(frame, 0, 0); frame.close(); // Immediately schedule rendering of the next frame setTimeout(renderFrame, 0);} Dev Tips在 Chrome DevTools 中使用 Media Panel，查看媒体日志和调试 WebCodecs。 Demo下面这个例子展示了 Canvas 上的动画是如何被： 通过 MediaStreamTrackProcessor 以 25fps 的帧率采集到 ReadableStream 中 转发到 Worker 线程 编码成 H.264 的视频 再次解码为帧序列 使用 transferControlToOffscreen() 在另一个 Canvas 上渲染 new-webcodecs-blogpost-demo Other demosAlso check out our other demos: Decoding gifs with ImageDecoder Capture camera input to a file MP4 playback Other samples 使用 WebCodecs API兼容性检查检查对 WebCodecs 的支持: 123if (&quot;VideoEncoder&quot; in window) { // WebCodecs API is supported.} 请注意，WebCodecs API 只在 secure contexts 下运行，所以如果 self.isSecureContext 是 false，则检测会失败。 FeedbackThe Chrome team wants to hear about your experiences with the WebCodecs API. Tell us about the API designIs there something about the API that doesn’t work like you expected? Or arethere missing methods or properties that you need to implement your idea? Have aquestion or comment on the security model? File a spec issue on thecorresponding GitHub repo, or addyour thoughts to an existing issue. Report a problem with the implementationDid you find a bug with Chrome’s implementation? Or is the implementationdifferent from the spec? File a bug at new.crbug.com.Be sure to include as much detail as you can, simple instructions forreproducing, and enter Blink&gt;Media&gt;WebCodecs in the Components box.Glitch works great for sharing quick and easy repros. Show support for the APIAre you planning to use the WebCodecs API? Your public support helps theChrome team to prioritize features and shows other browser vendors how criticalit is to support them. Send emails to media-dev@chromium.org or send a tweetto @ChromiumDev using the hashtag#WebCodecsand let us know where and how you’re using it. Hero image byDenise Janson Unsplash.","link":"/Program/FrontEnd/WebCodecs/%E8%AE%BA%E4%BD%BF%E7%94%A8WebCodecs%E5%AF%B9%E8%A7%86%E9%A2%91%E8%BF%9B%E8%A1%8C%E5%A4%84%E7%90%86/"},{"title":"论如何在C++&#x2F;CLI中使用LINQ：记一次奇妙的C++大作业","text":"123456“救我，你一定要救我啊！” 我的同学对我如是说“¿”“C++要考试了！我整不来啊，我感觉挺简单的题”“......”“请你吃顿饭”“彳亍” 然后我就收到了这么两道题目： 准备 生成 20 个可被 2 或 5 整除，介于 1 至 100 之间的无重复随机数 Write a program (in C++) that generates and calculates 20 different random numbers that can be divided by 2 or 5. Random numbers must be generated from 1 to 200,the same number cannot be included in the array! The random number generation should be written in a function, i.e. the return value of the function should be an array! 随机产生 50 个人的工资表，并列出平均、最高低工资 Given a list in which the wages of 50 people are stored (in EUR). Write a program (in C++) that determines what the average wage is, who has the highest wage, who has the lowest wage, and who has the wages below average. 乍一看感觉这题确实就是初学者的题目，不过如果我使用普通的方法完成这题就不能称之为 “奇妙” 的大作业了，所以在犹豫一阵后我决定，使用 C++/CLI 来完成顺带再期待一下老师如果看到一堆 CLI 代码会作何反应（ 什么是 C++/CLIC++/CLI 是 C++ 的扩展，让我们可以同时享受 C# 和 C++ 的特性，是微软的就我个人而言，如果能用 C++/CLI 的话那我绝对不会用传统的 C++而且这玩意据我了解在中国没多少人用，或者说老外也不怎么用因为这玩意不上不下的，说实话 C# 的 unsafe 已经足够了 而且就目前为止，它仍然不能跨平台，Core 以后也无法生成独立程序了 寄 There isn’t currently a template for C++/CLI console or Windows applications that can be used with .NET Core.Instead you must put application entry point outside of the C++/CLI code. 所以作业是用 .NET Framework，不过本文使用 .NET Core所以查个资料，学习起来着实有点费力，以后有空可以专门讲讲 在撰写这篇文章时我目前心目中的优先级：C# &gt; Go &gt; Rust &gt; C++/CLI &gt; TS &gt; Java &gt; Python &gt; JS &gt; C++ &gt; C一天到晚只想用托管类语言的我已经是个废物了 话费不多的请直接跳到文章最后看结果接下来我会一点点讲述我的心路历程 做题 准备项目 用 VS 2022 创建一个新的 C# .NET Core 解决方案 在解决方案中添加一个 C++/CLI .NET Core 类库项目 这里如果使用空白项目的话需要自己配置很多东西而且微软对 C++/CLI 的支持是越来越不好了注意：CLI 项目更改以后需要生成一下才能在 C# 中看到变化 Func: GetRandoms首先我们来实现生成随机数的函数既然两个题目都要求了随机数的产生那么我们就专门做一个函数出来复用 尽可能多的复用我认为是一件非常好的习惯无论是在写代码，还是在生活中 函数定义12345678910using namespace System;using namespace Collections::Generic;namespace Aloento::CLILinq { public ref class CLILinq { public: static List&lt;int&gt;^ GetRandoms(int min, int max, int num) { return nullptr; }}; 这就是我的格式习惯，一股子 Java 味让我们来分析一下这个代码 这是在一个 .h 头文件里面的代码 声明函数的写法就是传统的 C++ namespace 和 using 都和 C# 一样，只不过把 . 变成 :: public 是为了让 C# 可以访问 ref 表明这是一个托管类 static 在我这里是 Helper 的统一写法 List&lt;int&gt;^ 返回一个 托管的 ^ List&lt;int&gt; 类型 托管类型都是从 C# 来的用 C++/CLI 托管的代码可以无缝在 C# 中使用，反之亦然 基本功能1234567891011121314static List&lt;int&gt;^ GetRandoms(int min, int max, int num) { auto random = Random::Shared; auto res = gcnew List&lt;int&gt;(num); for (auto i = 0; i &lt; num;) { auto r = random-&gt;Next(min, max); if (!res-&gt;Contains(r) &amp;&amp; (r % 2 == 0 || r % 5 == 0)) { i++; res-&gt;Add(r); } } return res;} Random::Shared 说明了我们现在在使用 .NET Core gcnew 表明了我们要生成一个 托管的 对象 if 语句用来排除重复的随机数，并且确保是 2 和 5 的倍数 i++ 表明我们已经得到了目标，所以我们要让 i 加一，不可以让 for 语句来完成 至此，有一些编程基础的都应该轻松看懂除了一些 CLI 的独特语法以外，其余的和传统 C++ / C# 并无太大区别 数据验证我们写代码的时候还是不要过于相信用户会按照你的想法来使用它毕竟 一个测试工程师走进一家酒吧，啥也没干酒吧就炸了 所以我们简单的加一句： 12if (max / 2 + max / 5 - (min / 2 + min / 5) &lt; num) throw gcnew ArgumentOutOfRangeException(); 这里我没有写具体的说明，不过正式写代码的时候，报错一定要写清楚原因 完全体123456789101112131415161718192021222324252627#pragma onceusing namespace System;using namespace Collections::Generic;namespace Aloento::CLILinq { public ref class CLILinq sealed { public: static List&lt;int&gt;^ GetRandoms(const int min, const int max, const int num) { if (max / 2 + max / 5 - (min / 2 + min / 5) &lt; num) { throw gcnew ArgumentOutOfRangeException(); } auto random = Random::Shared; auto res = gcnew List&lt;int&gt;(num); for (auto i = 0; i &lt; num;) { auto r = random-&gt;Next(min, max); if (!res-&gt;Contains(r) &amp;&amp; (r % 2 == 0 || r % 5 == 0)) { i++; res-&gt;Add(r); } } return res; } };} Func: GetWagesList我是把两道题一起做的，所以在这个 CLILinq 类里应该还有第二题的方法这个方法用来产生一些随机的 Name:Wages 键值对由于时间关系，我们这里生成的名字就直接按 ASCII 取了 123456789101112static Dictionary&lt;Char, double&gt;^ GetWagesList() { auto random = Random::Shared; auto dictionary = gcnew Dictionary&lt;Char, double&gt;(); Char c = 65; for (auto i = 0; i &lt; 50; i++) { auto wage = random-&gt;NextDouble() * 1000; dictionary-&gt;Add(c++, wage); } return dictionary;} 因为比较简单，所以直接上代码这里不用 char 而是 Char，这样可以直接被 C# 转字符串，方便输出 调用：第一题第一题的调用比较无脑，直接用就行了 123456static void Invoke() { auto randomList = GetRandoms(1, 200, 20); for each (auto num in randomList) { Console::WriteLine(num); }} LINQ：第二题第二题的实际逻辑就在这里也是 LINQ 出场的地方 （原谅我前面瞎扯了那么多） 我们先看实现代码 123456789101112131415161718static void Invoke() { auto wageDic = GetWagesList(); auto v = wageDic-&gt;Values; double sum = 0; for each (auto num in v) { sum += num; } auto avg = sum / 50; auto c = System::Globalization::CultureInfo::CultureInfo::CreateSpecificCulture(&quot;eu-ES&quot;); Console::WriteLine(&quot;Average: &quot; + avg.ToString(&quot;C&quot;, c) + &quot;\\n&quot;); auto ordered = Enumerable::OrderBy(wageDic, gcnew Func&lt;KeyValuePair&lt;Char, double&gt;, double&gt;(Select)); for each (auto one in ordered) { Console::WriteLine(one.Key + &quot;: &quot; + one.Value.ToString(&quot;C&quot;, c)); }} for each (auto num in v) 这部分其实就是 Enumerable.Aggregate 的简单实现毕竟要交作业，不能写的那么高级 （其实是嫌麻烦） CultureInfo 就是设置个格式化区域，这里转成欧洲的货币格式avg.ToString(&quot;C&quot;, c) 就是把 avg 转成 Currency LINQ接下来就是 Enumerable.OrderBy 的实现为了搞懂如何传入这个方法需要的参数，我搞了一个多小时到处找资料和 debug… 由于 C++ 11 之前就没有 lambda 表达式，后面有了也非常奇怪所以 LINQ 压根就没有提供类似的调用方式所以我们必须使用 gcnew Func() 的方式传递一个委托 首先，我们必须清楚 Func 的泛型类型到底是什么C++/CLI 在这里 IDE 是完全没有代码提示的，所以我们需要自行分析最好的方式就是在 C# 里面写同样的代码，然后看它们的类型 在这里，Dictionary&lt;Char, double&gt; 的单个元素的类型是 KeyValuePair&lt;Char, double&gt;所以很显然我们需要 Func&lt;KeyValuePair&lt;Char, double&gt;, double&gt;现在我们就有了它的类型，然后我们需要实现这个委托 这个委托是一个选择器，它的作用是从类型中选择出一个对象来作为排序的依据在我们这里，就是要从 KeyValuePair 中把 Value 选出来 随后就有了以下代码 123static double Select(KeyValuePair&lt;Char, double&gt; a) { return a.Value;} 非常简单，在特定情况下，你也可以尝试直接内联它之后的事情就非常简单了，该调用调用，该输出输出 实际上先贴一堆代码，可以粗略看看 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697namespace Aloento.SCLILinq;using System.Globalization;public sealed class SCLILinq { public static List&lt;int&gt; GetRandoms(int min, int max, int num) { Random random = null; List&lt;int&gt; list = null; if (max / 2 + max / 5 - (min / 2 + min / 5) &lt; num) { throw new ArgumentOutOfRangeException(); } random = Random.Shared; list = new List&lt;int&gt;(num); int num2 = 0; while (num2 &lt; num) { int num3 = random.Next(min, max); if (!list.Contains(num3) &amp;&amp; (num3 % 2 == 0 || num3 % 5 == 0)) { num2++; list.Add(num3); } } return list; } public static Dictionary&lt;char, double&gt; GetWagesList() { Random random = null; Dictionary&lt;char, double&gt; dictionary = null; random = Random.Shared; dictionary = new Dictionary&lt;char, double&gt;(); char c = 'A'; for (int i = 0; i &lt; 50; i++) { double value = random.NextDouble() * 1000.0; char key = c; c = (char)(c + 1); dictionary.Add(key, value); } return dictionary; } public static double Select(KeyValuePair&lt;char, double&gt; a) { return a.Value; } public static void Invoke() { List&lt;int&gt; list = null; Dictionary&lt;char, double&gt; dictionary = null; Dictionary&lt;char, double&gt;.ValueCollection valueCollection = null; CultureInfo cultureInfo = null; IOrderedEnumerable&lt;KeyValuePair&lt;char, double&gt;&gt; orderedEnumerable = null; IEnumerator&lt;KeyValuePair&lt;char, double&gt;&gt; enumerator = null; list = GetRandoms(1, 200, 20); List&lt;int&gt;.Enumerator enumerator2 = list.GetEnumerator(); while (enumerator2.MoveNext()) { int current = enumerator2.Current; Console.WriteLine(current); } Console.WriteLine(&quot;\\n-------------------------------\\n&quot;); dictionary = GetWagesList(); valueCollection = dictionary.Values; double num = 0.0; Dictionary&lt;char, double&gt;.ValueCollection.Enumerator enumerator3 = valueCollection.GetEnumerator(); while (enumerator3.MoveNext()) { double current2 = enumerator3.Current; num += current2; } double num2 = num / 50.0; cultureInfo = CultureInfo.CreateSpecificCulture(&quot;eu-ES&quot;); string str = &quot;\\n&quot;; double num3 = num2; string str2 = num3.ToString(&quot;C&quot;, cultureInfo); Console.WriteLine(string.Concat(&quot;Average: &quot; + str2, str)); orderedEnumerable = Enumerable.OrderBy(dictionary, new Func&lt;KeyValuePair&lt;char, double&gt;, double&gt;(Select)); enumerator = orderedEnumerable.GetEnumerator(); try { while (enumerator.MoveNext()) { KeyValuePair&lt;char, double&gt; current3 = enumerator.Current; double value = current3.Value; string format = &quot;C&quot;; string str3 = value.ToString(format, cultureInfo); string arg = &quot;: &quot;; Console.WriteLine(string.Concat(current3.Key + arg, str3)); } } finally { IEnumerator&lt;KeyValuePair&lt;char, double&gt;&gt; enumerator4 = enumerator; if (enumerator4 != null) { enumerator4.Dispose(); long num4 = 0L; } else { long num4 = 0L; } } }} 这是直接对 C++/CLI 生成的库反编译的结果我们可以发现，这就相当于是写了一堆 C# 而已如果带指针之类的，就是 unsafe所以：没必要，别用 C++/CLI 适用范围 如果你想 Wrapper 一个 C / C++ 的库给 C# 用 如果你想让 .NET 与其他语言一起工作 让 C++ 享受 .NET 的生态 如果你闲得慌想找点事情干 在大部分情况下，C++/CLI 的存在都是为了高效的让 C# 与 C / C++ 交互而使用使用它可以让你的 .NET 项目享受到 C++ 全套的生态，反之亦然毕竟 P/Invoke 并不优雅 在托管类语言中，C++/CLI 在一定程度上让 C# 成了最容易与 C / C++ 交互的语言进而让它也更容易与能够和 C / C++ 交互的语言交互 使用它，你需要同时掌握 C# 和 C++而且在很多时候，IDE 不会给你有效的提示所以学习它需要很多时间来尝试 结论12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970using namespace System;using namespace Linq;using namespace Collections::Generic;namespace Aloento::CLILinq { public ref class CLILinq sealed { public: static List&lt;int&gt;^ GetRandoms(const int min, const int max, const int num) { if (max / 2 + max / 5 - (min / 2 + min / 5) &lt; num) { throw gcnew ArgumentOutOfRangeException(); } auto random = Random::Shared; auto res = gcnew List&lt;int&gt;(num); for (auto i = 0; i &lt; num;) { auto r = random-&gt;Next(min, max); if (!res-&gt;Contains(r) &amp;&amp; (r % 2 == 0 || r % 5 == 0)) { i++; res-&gt;Add(r); } } return res; } static Dictionary&lt;Char, double&gt;^ GetWagesList() { auto random = Random::Shared; auto dictionary = gcnew Dictionary&lt;Char, double&gt;(); Char c = 65; for (auto i = 0; i &lt; 50; i++) { auto wage = random-&gt;NextDouble() * 1000; dictionary-&gt;Add(c++, wage); } return dictionary; } static double Select(KeyValuePair&lt;Char, double&gt; a) { return a.Value; } static void Invoke() { auto randomList = GetRandoms(1, 200, 20); for each (auto num in randomList) { Console::WriteLine(num); } Console::WriteLine(&quot;\\n-------------------------------\\n&quot;); auto wageDic = GetWagesList(); auto v = wageDic-&gt;Values; double sum = 0; for each (auto num in v) { sum += num; } auto avg = sum / 50; auto c = System::Globalization::CultureInfo::CultureInfo::CreateSpecificCulture(&quot;eu-ES&quot;); Console::WriteLine(&quot;Average: &quot; + avg.ToString(&quot;C&quot;, c) + &quot;\\n&quot;); auto ordered = Enumerable::OrderBy(wageDic, gcnew Func&lt;KeyValuePair&lt;Char, double&gt;, double&gt;(Select)); for each (auto one in ordered) { Console::WriteLine(one.Key + &quot;: &quot; + one.Value.ToString(&quot;C&quot;, c)); } } };}","link":"/Program/C/CLI/%E8%AE%BA%E5%A6%82%E4%BD%95%E5%9C%A8CPPCLI%E4%B8%AD%E4%BD%BF%E7%94%A8LINQ%E4%B9%8B%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%A5%87%E5%A6%99%E7%9A%84CPP%E5%A4%A7%E4%BD%9C%E4%B8%9A/"}],"tags":[{"name":"云","slug":"云","link":"/tags/%E4%BA%91/"},{"name":"OpenStack","slug":"OpenStack","link":"/tags/OpenStack/"},{"name":"日记","slug":"日记","link":"/tags/%E6%97%A5%E8%AE%B0/"},{"name":"编程","slug":"编程","link":"/tags/%E7%BC%96%E7%A8%8B/"},{"name":"前端","slug":"前端","link":"/tags/%E5%89%8D%E7%AB%AF/"},{"name":"翻译","slug":"翻译","link":"/tags/%E7%BF%BB%E8%AF%91/"},{"name":"音视频","slug":"音视频","link":"/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"},{"name":"WebCodecs","slug":"WebCodecs","link":"/tags/WebCodecs/"},{"name":"JS","slug":"JS","link":"/tags/JS/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"CLI","slug":"CLI","link":"/tags/CLI/"},{"name":"LINQ","slug":"LINQ","link":"/tags/LINQ/"},{"name":"C#","slug":"C","link":"/tags/C/"},{"name":".NET","slug":"NET","link":"/tags/NET/"},{"name":"OrderBy","slug":"OrderBy","link":"/tags/OrderBy/"}],"categories":[{"name":"Cloud","slug":"Cloud","link":"/categories/Cloud/"},{"name":"Program","slug":"Program","link":"/categories/Program/"},{"name":"OpenStack","slug":"Cloud/OpenStack","link":"/categories/Cloud/OpenStack/"},{"name":"FrontEnd","slug":"Program/FrontEnd","link":"/categories/Program/FrontEnd/"},{"name":"C++","slug":"Program/C","link":"/categories/Program/C/"},{"name":"Diary","slug":"Diary","link":"/categories/Diary/"},{"name":"WebCodecs","slug":"Program/FrontEnd/WebCodecs","link":"/categories/Program/FrontEnd/WebCodecs/"},{"name":"CLI","slug":"Program/C/CLI","link":"/categories/Program/C/CLI/"}]}