---
title: NLP-Tokenization
toc: true
categories:
  - [AI, NLP]
tags: [笔记, AI, NLP]
date: 2024-09-23 23:04:11
---

本章主要讲述了 NLP 的令牌化

<!-- more -->

## 基准：按空白字符分割

对于许多书写系统，按*空白字符*分割文本是一个有用的基准：

'This isn't an easy sentence to tokenize!' $\Rightarrow$\
\['This', \"isn't\", 'an', 'easy', 'sentence', 'to', 'tokenize!'\]

问题：

- 我们通常希望将标点符号视为单独的标记（但仅当它们确实是标点符号时，例如 'U.K.' 或 '10,000.00\$'）；
- 这种解决方案无法分隔没有空白字符的标记对，例如带有附加成分的表达式，如 \"isn't\"。

# 正则表达式和语言

## 正则表达式

我们需要引入更复杂的模式来以上下文相关的方式描述标记边界。一种流行的解决方案是使用**正则表达式**（简称 regex）。

给定一个有限的 $\Sigma$ 符号字母表，$\Sigma$ 上的正则表达式及其在 $\Sigma^*$ 中的匹配通过同时递归定义如下：

1. 空字符串和 $\Sigma$ 中的任何单个符号都是 $\Sigma$ 上的正则表达式，并匹配其自身。

2. 如果 $r_1$ 和 $r_2$ 是 $\Sigma$ 上的正则表达式，那么

    1. 它们的 **连接**，$r_1 r_2$ 也是 $\Sigma$ 上的正则表达式，并且匹配那些恰好是匹配 $r_1$ 的字符串和匹配 $r_2$ 的字符串连接起来的字符串，且

    2. 它们的 **交替**，$r_1 \vert r_2$ 也是 $\Sigma$ 上的正则表达式，并且匹配那些恰好匹配 $r_1$ 或 $r_2$ 的字符串。

3. 如果 $r$ 是 $\Sigma$ 上的正则表达式，那么对 $r$ 应用__Kleene 星号__运算符，我们可以形成一个新的正则表达式 $r^*$，它恰好匹配那些由 0 个或多个匹配 $r$ 的字符串连接起来的字符串。

## 形式语言

给定一个有限的字母表 $\Sigma$，一个 **形式语言** $\mathcal L$ 是 $\Sigma$ 上字符串的任意集合。这些字符串通常通过__语法__定义。

根据语法的复杂性，语言可以分为不同的 **类型**。最著名的是乔姆斯基层次结构：

![https://en.wikipedia.org/wiki/Chomsky_hierarchy](https://upload.wikimedia.org/wikipedia/commons/thumb/9/9a/Chomsky-hierarchy.svg/200px-Chomsky-hierarchy.svg.png)

- 正则语言：可以描述线性结构

  - 编程：状态机
  - 语言：单词，名词短语

- 上下文无关语言：可以描述树结构

  - 编程：XML DOM，解析树
  - 语言：短语结构语法（句子）

- 上下文相关语言：大多数人类语言是轻度上下文相关的

- 递归可枚举语言：所有可以通过算法解决的问题

## 回到正则表达式

一个形式语言 $\mathcal L$ 当且仅当存在一个正则表达式恰好匹配 $\mathcal L$ 的元素时，才是 **正则的**。

有一些简单的形式语言不是正则的，例如“孪生语言” $\{ww ~\vert~ w \in \{a, b\}^* \}$。

尽管如此，正则表达式对于许多实际任务来说已经足够灵活，并且存在高效的算法来决定字符串 $s$ 是否匹配正则表达式（时间复杂度为 $\mathcal O(\mathrm{length}(s))$）。

## 有限状态接受器与正则语言

有限状态接受器是消耗字符输入序列并可以“接受”或“拒绝”输入的有限状态机。它们与最简单的 FSA (有限状态自动机) 不同之处在于：

- 有一个明确的 **开始状态**，

- 一组指定的 **接受状态**，以及

- 它们的转换由有限字母表中的符号或空字符串标记。

当且仅当有限状态接受器具有从开始状态开始、在接受状态结束的转换序列，并且转换标签的连接是所讨论的输入时，它才 **接受** 输入。

接受单词“car”、“cars”、“cat”和“cats”的接受器：

![FSA-Comp](fsa1.jpg)

可以简化为：

![FSA-Simp](fsa2.jpg)

有限状态接受器与 正则语言/表达式 之间的联系由 Kleene 的 **等价定理** 建立：

- 当且仅当存在一个 FSA 接受器恰好接受其元素时，一个语言是正则的。

这种等价性在理论和实践中都很重要：有非常高效的算法可以 简化/最小化 有限状态接受器，并决定它们是否接受一个字符串。

## 正则表达式：扩展

**便利扩展** 不增加表达能力，只是添加了一些有用的快捷方式，例如：

- 字符类匹配集合中的任何单个符号，例如 \[0-9\]；
- 补充字符类匹配 *不在* 补充集合中的任何字符，例如 \[\^ab\]；
- 用于指定模式重复次数的运算符，例如，$r\{m,n\}$ 匹配 $s$ 如果 $s$ 重复 $r$ 模式 $k$ 次，其中 $m\leq k \leq n$。
- 可选匹配：$r? = r\{0,1\}$
- Kleene plus：$r+ \approx r\{1,\infty\}$

## 正则表达式：反向引用

所谓的 **反向引用** 结构，允许命名和引用与正则表达式的早期部分相对应的匹配项，从而*增加*了表达能力。

例如，大多数当前的正则表达式库允许类似于以下的正则表达式：

```regex
(?P<a>[ab]*)(?P=a)
```

它使用反向引用来定义前面提到的非正则“孪生语言”。

## 基于正则表达式的查找和替换

除了将整个字符串与正则表达式匹配之外，还有两个基于正则表达式的常见任务：

- 查找与正则表达式匹配的字符串子串，

- 基于正则表达式的查找和替换：在其最简单的形式中，这是用给定的字符串替换匹配的子串，但现代正则表达式库提供了两个显著的额外功能：
  - 正则表达式可以有前瞻和后顾部分，这些部分在查找匹配时使用，但不计入被替换的部分；
  - 替换不必是固定的——它们可以包含对匹配部分的反向引用。

# 基于规则的分词

## 基于正则表达式级联的分词

核心思想：对输入执行基于正则表达式的替换，最终只需按空白字符分割即可。

Penn Tree Bank 附带的
[分词器 sed 脚本](ftp://ftp.cis.upenn.edu/pub/treebank/public_html/tokenizer.sed)
是一个很好的例子。
几个具有代表性的规则（`\&` 指代完整匹配，`\n` 指代第 $n$ 个组）：

- '\...' $\Rightarrow$ ' \... '（分隔省略号）
- '\[,;:#\$%&\]' $\Rightarrow$ ' \\& '（分隔各种符号）
- (\[\^.\])(\[.\])(\[\])}\"'\]\*)\[\]\*\$ $\Rightarrow$ '\\1 \\2\\3'（假设句子输入并仅分隔最终句号）
- \"'ll\" $\Rightarrow$ \" 'll\"（分隔缩略词 'll）
