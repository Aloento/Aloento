---
title: NLP-Tokenization
toc: true
categories:
  - [AI, NLP]
tags: [笔记, AI, NLP]
date: 2024-09-23 23:04:11
---

本章主要讲述了 NLP 的令牌化

<!-- more -->

## 基准：按空白字符分割

对于许多书写系统，按*空白字符*分割文本是一个有用的基准：

'This isn't an easy sentence to tokenize!' $\Rightarrow$\
\['This', \"isn't\", 'an', 'easy', 'sentence', 'to', 'tokenize!'\]

问题：

- 我们通常希望将标点符号视为单独的标记（但仅当它们确实是标点符号时，例如 'U.K.' 或 '10,000.00\$'）；
- 这种解决方案无法分隔没有空白字符的标记对，例如带有附加成分的表达式，如 \"isn't\"。

# 正则表达式和语言

## 正则表达式

我们需要引入更复杂的模式来以上下文相关的方式描述标记边界。一种流行的解决方案是使用**正则表达式**（简称 regex）。

给定一个有限的 $\Sigma$ 符号字母表，$\Sigma$ 上的正则表达式及其在 $\Sigma^*$ 中的匹配通过同时递归定义如下：

1. 空字符串和 $\Sigma$ 中的任何单个符号都是 $\Sigma$ 上的正则表达式，并匹配其自身。

2. 如果 $r_1$ 和 $r_2$ 是 $\Sigma$ 上的正则表达式，那么

    1. 它们的 **连接**，$r_1 r_2$ 也是 $\Sigma$ 上的正则表达式，并且匹配那些恰好是匹配 $r_1$ 的字符串和匹配 $r_2$ 的字符串连接起来的字符串，且

    2. 它们的 **交替**，$r_1 \vert r_2$ 也是 $\Sigma$ 上的正则表达式，并且匹配那些恰好匹配 $r_1$ 或 $r_2$ 的字符串。

3. 如果 $r$ 是 $\Sigma$ 上的正则表达式，那么对 $r$ 应用__Kleene 星号__运算符，我们可以形成一个新的正则表达式 $r^*$，它恰好匹配那些由 0 个或多个匹配 $r$ 的字符串连接起来的字符串。

## 形式语言

给定一个有限的字母表 $\Sigma$，一个 **形式语言** $\mathcal L$ 是 $\Sigma$ 上字符串的任意集合。这些字符串通常通过__语法__定义。

根据语法的复杂性，语言可以分为不同的 **类型**。最著名的是乔姆斯基层次结构：

![https://en.wikipedia.org/wiki/Chomsky_hierarchy](https://upload.wikimedia.org/wikipedia/commons/thumb/9/9a/Chomsky-hierarchy.svg/200px-Chomsky-hierarchy.svg.png)

- 正则语言：可以描述线性结构

  - 编程：状态机
  - 语言：单词，名词短语

- 上下文无关语言：可以描述树结构

  - 编程：XML DOM，解析树
  - 语言：短语结构语法（句子）

- 上下文相关语言：大多数人类语言是轻度上下文相关的

- 递归可枚举语言：所有可以通过算法解决的问题

## 回到正则表达式

一个形式语言 $\mathcal L$ 当且仅当存在一个正则表达式恰好匹配 $\mathcal L$ 的元素时，才是 **正则的**。

有一些简单的形式语言不是正则的，例如“孪生语言” $\{ww ~\vert~ w \in \{a, b\}^* \}$。

尽管如此，正则表达式对于许多实际任务来说已经足够灵活，并且存在高效的算法来决定字符串 $s$ 是否匹配正则表达式（时间复杂度为 $\mathcal O(\mathrm{length}(s))$）。

## 有限状态接受器与正则语言

有限状态接受器是消耗字符输入序列并可以“接受”或“拒绝”输入的有限状态机。它们与最简单的 FSA (有限状态自动机) 不同之处在于：

- 有一个明确的 **开始状态**，

- 一组指定的 **接受状态**，以及

- 它们的转换由有限字母表中的符号或空字符串标记。

当且仅当有限状态接受器具有从开始状态开始、在接受状态结束的转换序列，并且转换标签的连接是所讨论的输入时，它才 **接受** 输入。

接受单词“car”、“cars”、“cat”和“cats”的接受器：

![FSA-Comp](fsa1.jpg)

可以简化为：

![FSA-Simp](fsa2.jpg)
